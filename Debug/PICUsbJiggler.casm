;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PICUSBJIGGLER_H_
#define _PICUSBJIGGLER_H_

#define LED (portb.1) // LED pin
#define BUTTON (portb.2) // Button (switch) pin

bit isJiggling = 0; // When 0, device does nothing
0E36  905F      	BCF gbl_isJiggling,0

bit buttonOld = 1;
0E38  825F      	BSF gbl_buttonOld,1


#define TRUE   1
#define FALSE  0
#define NULL   0

#define DEBUG_SERIAL 	1
#define NUM_CONFIGURATIONS      1
#define NUM_INTERFACES          1

#define ConfiguredUSB() ((USWSTAT&0x3) == CONFIG_STATE)
#define STALL_EP0    	set_bit(uep0,EPSTALL)
#define STALL_PID_EP0IN 	bd0statie = 0xCC  /* REQUEST ERROR */
#define Send_0Len_pkt	bd0cntie = 0;	bd0statie = 0xc8;	USB_dev_req = NULL

#define POWERED_STATE	        0x00
#define DEFAULT_STATE	        0x01
#define ADDRESS_STATE	        0x02
#define CONFIG_STATE	        0x03
#define ENDPT_DISABLED	        0x10  // For 18F2455 with handshaking
#define ENDPT_IN_ONLY	        0x12
#define ENDPT_OUT_ONLY	        0x14
#define ENDPT_CONTROL	        0x16	/* enable for in, out and setup */
#define ENDPT_NON_CONTROL		0x1E	/* enable for in, and out */
#define TOKEN_OUT	(0x01<<2)
#define TOKEN_ACK	(0x02<<2)
#define TOKEN_IN	(0x09<<2)
#define TOKEN_SETUP	(0x0D<<2)
#define CLEAR_FEATURE	        0x01
#define GET_CONFIGURATION	0x08
#define GET_DESCRIPTOR	        0x06
#define GET_INTERFACE	        0x0A
#define GET_STATUS	        0x00
#define SET_ADDRESS	        0x05
#define SET_CONFIGURATION	0x09
#define SET_FEATURE	        0x03
#define SET_INTERFACE	        0x0B
#define HID_GET_REPORT		0x01
#define	HID_GET_IDLE		0x02
#define	HID_GET_PROTOCOL	0x03
#define HID_SET_REPORT		0x09
#define HID_SET_IDLE		0x0A
#define HID_SET_PROTOCOL	0x0B
#define HID_REPORT_DESCRIPTOR 	0x22
#define HID_DESCRIPTOR 			0x21
#define VEND_SET_MEMORY	        0x80
#define HOSTTODEVICE            0x00
#define HOSTTOINTERFACE         0x01
#define HOSTTOENDPOINT          0x02
#define DEVICETOHOST            0x80
#define INTERFACETOHOST         0x81
#define ENDPOINTTOHOST          0x82
#define EP0OUT                  0
#define EP0IN                   1
#define EP1OUT                  2
#define EP1IN                   3
#define EP2OUT                  4
#define EP2IN                   5

// Descriptor Types
#define DEVICE                  1
#define CONFIGURATION           2
#define STRING                  3
#define INTERFACE               4
#define ENDPOINT                5
#define CS_INTERFACE            0x24
#define CS_ENDPOINT             0x25

//define some useful bit variables
volatile  bit  bDEV_ATT@UCON.USBEN;
volatile bit   bSUSPND@UCON.SUSPND;
volatile bit   bPKT_DIS@UCON.PKTDIS;
volatile  bit  bUIDLE@UIE.IDLEIE;
//ENABLE BITS
volatile  bit  bACTIVITY_E@UIE.ACTVIE;
volatile bit   bTOK_DONE_E@UIE.TRNIE; 
volatile bit  bPID_ERR_E@UEIE.PIDEE;
volatile bit  bCRC5_E@UEIE.CRC5EE;
volatile bit  bCRC16_E@UEIE.CRC16EE;
volatile bit  bDFN8_E@UEIE.DFN8EE;
volatile bit  bBTO_ERR_E@UEIE.BTOEE;
volatile bit  bBTS_ERR_E@UEIE.BTSEE;
volatile bit  bUSBRST_E@UIE.URSTIE;
volatile bit  bUSBIE@PIE2.USBIE;
//FLAG BITS
volatile bit   bSTALL@UIR.STALLIF;
volatile  bit  bUERR@UIR.UERRIF;
volatile bit  bPID_ERR@UEIR.PIDEF;
volatile bit  bCRC5@UEIR.CRC5EF; 
volatile  bit bCRC16@UEIR.CRC16EF;  
volatile bit  bDFN8@UEIR.DFN8EF;
volatile bit  bBTO_ERR@UEIR.BTOEF; 
volatile bit  bBTS_ERR@UEIR.BTSEF;
volatile bit bUSBIF@PIR2.USBIF;
volatile bit bUSBRST@UIR.URSTIF;
volatile bit bTMR0IF@INTCON.TMR0IF;
volatile bit   bACTIVITY@UIR.ACTVIF;
volatile bit   bTOK_DONE@UIR.TRNIF;

//BUFFER REGISTERS
//NAMING CONVENTION bdNXXXXDP  where 
//N is endpoint# = 0,1,2,3
//XXXX is the type: stat, cnt, adrl or adrh
//D is direction=i,o (in,out) 
//P is pingpong=e,o  (even,odd)
/* non-pingpong buffering, 8 byte buffers*/
char bd0statoe@0x400;
char bd0cntoe@0x401=8;
0E3A  0E08      	MOVLW 0x08
0E3C  0104      	MOVLB 0x04
0E3E  6F01      	MOVWF gbl_bd0cntoe, 1

char bd0adrloe@0x402 =0x00;
0E40  6B02      	CLRF gbl_bd0adrloe, 1

char bd0adrhoe@0x403 =0x05;
0E42  0E05      	MOVLW 0x05
0E44  6F03      	MOVWF gbl_bd0adrhoe, 1


char bd0statie@0x404;
char bd0cntie@0x405=8;
0E46  0E08      	MOVLW 0x08
0E48  6F05      	MOVWF gbl_bd0cntie, 1

char bd0adrlie@0x406= 0x80;
0E4A  0E80      	MOVLW 0x80
0E4C  6F06      	MOVWF gbl_bd0adrlie, 1

char bd0adrhie@0x407=0x05;
0E4E  0E05      	MOVLW 0x05
0E50  6F07      	MOVWF gbl_bd0adrhie, 1


char bd1statoe@0x408;
char bd1cntoe@0x409=8;
0E52  0E08      	MOVLW 0x08
0E54  6F09      	MOVWF gbl_bd1cntoe, 1

char bd1adrloe@0x40A =0x00;
0E56  6B0A      	CLRF gbl_bd1adrloe, 1

char bd1adrhoe@0x40B=0x06;
0E58  0E06      	MOVLW 0x06
0E5A  6F0B      	MOVWF gbl_bd1adrhoe, 1


char bd1statie@0x40C;
char bd1cntie@0x40D=8;
0E5C  0E08      	MOVLW 0x08
0E5E  6F0D      	MOVWF gbl_bd1cntie, 1

char bd1adrlie@0x40E=0x80;
0E60  0E80      	MOVLW 0x80
0E62  6F0E      	MOVWF gbl_bd1adrlie, 1

char bd1adrhie@0x40F=0x06;
0E64  0E06      	MOVLW 0x06
0E66  6F0F      	MOVWF gbl_bd1adrhie, 1


char bd2statoe@0x410;
char bd2cntoe@0x411=8;
0E68  0E08      	MOVLW 0x08
0E6A  6F11      	MOVWF gbl_bd2cntoe, 1

char bd2adrloe@0x412 =0x00;
0E6C  6B12      	CLRF gbl_bd2adrloe, 1

char bd2adrhoe@0x413 =0x07;
0E6E  0E07      	MOVLW 0x07
0E70  6F13      	MOVWF gbl_bd2adrhoe, 1


char bd2statie@0x414;
char bd2cntie@0x415=8;
0E72  0E08      	MOVLW 0x08
0E74  6F15      	MOVWF gbl_bd2cntie, 1

char bd2adrlie@0x416= 0x80;
0E76  0E80      	MOVLW 0x80
0E78  6F16      	MOVWF gbl_bd2adrlie, 1

char bd2adrhie@0x417=0x07;
0E7A  0E07      	MOVLW 0x07
0E7C  6F17      	MOVWF gbl_bd2adrhie, 1



#endif //_PICUSBJIGGLER_H_

//###########################################################################
// filename:		usbtestCC.c
//##########################################################################
// The Irritating Mouse - This program causes the mouse pointer to move in a 
//                        figure 8 (infinity) shape
//   CC indicates changes from original Circuit Cellar source
//
// Author:	                Copyright 2005 by Robert Lang		
// Building on the work of: Reston Condit
//                          Dan Butler
//                          Andrew Smallridge
//
// Revision:		1.1 
// Date:		January 2005
// Compiled using:	BOOSTC 1.93
//
// Revision History:
//   1.0 Initial development and conversion to BOOSTC and PIC18F2455 based on 
//       program "Mouse in a circle" example
//   1.1 Added serial port for debugging messages
//
// Comments:
// bXXX indicate specific bits in registers defined in usb_defs.h
// usb buffers are defined in usbdefs.h

//################################################################################
//
// include files:
#include "system.h" //pic definition files required by boostc
#include "PICUsbJiggler.h" 

// Configuration registers
// FOSC3:FOSC0 = HSPLL PLLDIV2:PLLDIV0 = 0, CPUDIV1:CPUDIV0 = 10 (/4)
#pragma DATA    _CONFIG1L, 00110000b // USBDIV on, CPU divide by 4, PLL direct
#pragma DATA    _CONFIG1H, 00001110b // disable oscillator switchover, disable failsafe clock monitor, HSPLL
#pragma DATA    _CONFIG2L, 00111110b // USB voltage regulator enabled, brownout set for 2.1 volts, hardware brownout only, PWRT enabled
#pragma DATA    _CONFIG2H, 00011110b // Watchdog timer disabled
#pragma DATA    _CONFIG3H, 00000000b // MCLR disabled, RB4:RB0 digital on POR
#pragma DATA    _CONFIG4L, 10000000b // Debug off, extended instructions disabled, LVP disabled, disable stack full/underflow reset
#pragma DATA    _CONFIG5L, 00001111b // Read code protection off
#pragma DATA    _CONFIG5H, 11000000b // Read EEPROM and boot block protection off
#pragma DATA    _CONFIG6L, 00001111b // Write code protection off
#pragma DATA    _CONFIG6H, 11100000b // Write EEPROM, boot block and config register protection off
#pragma DATA    _CONFIG7L, 00001111b // Table read protection off
#pragma DATA    _CONFIG7H, 01000000b // Boot block table read protection off

// 4 MHz crystal but the system clock is 24MHz due to CPUDIV configuration
#pragma CLOCK_FREQ 24000000

unsigned char USB_IsIdle;
unsigned char USB_status_device;
unsigned char USB_Curr_Config; 
unsigned char USB_address_pending;
unsigned char USB_dev_req;
unsigned char USB_Interface [3];
unsigned char USB_USTAT;
unsigned char ACTIVE_BUF;
unsigned char USB_protocol;
unsigned char USWSTAT;
unsigned int USB_PID_ERR   = 0; //error counters
0E7E  0100      	MOVLB 0x00
0E80  6BD4      	CLRF gbl_USB_PID_ERR, 1
0E82  6BD5      	CLRF gbl_USB_PID_ERR+D'1', 1

unsigned int USB_CRC5_ERR  = 0;
0E84  6BD6      	CLRF gbl_USB_CRC5_ERR, 1
0E86  6BD7      	CLRF gbl_USB_CRC5_ERR+D'1', 1

unsigned int USB_CRC16_ERR = 0;
0E88  6BD8      	CLRF gbl_USB_CRC16_ERR, 1
0E8A  6BD9      	CLRF gbl_USB_CRC16_ERR+D'1', 1

unsigned int USB_DFN8_ERR  = 0;
0E8C  6BDA      	CLRF gbl_USB_DFN8_ERR, 1
0E8E  6BDB      	CLRF gbl_USB_DFN8_ERR+D'1', 1

unsigned int USB_BTO_ERR   = 0;
0E90  6BDC      	CLRF gbl_USB_BTO_ERR, 1
0E92  6BDD      	CLRF gbl_USB_BTO_ERR+D'1', 1

unsigned int USB_WRT_ERR   = 0;
0E94  6BDE      	CLRF gbl_USB_WRT_ERR, 1
0E96  6BDF      	CLRF gbl_USB_WRT_ERR+D'1', 1

unsigned int USB_OWN_ERR   = 0;
0E98  6BE0      	CLRF gbl_USB_OWN_ERR, 1
0E9A  6BE1      	CLRF gbl_USB_OWN_ERR+D'1', 1

unsigned int USB_BTS_ERR   = 0;
0E9C  6BE2      	CLRF gbl_USB_BTS_ERR, 1
0E9E  6BE3      	CLRF gbl_USB_BTS_ERR+D'1', 1


unsigned char * EP0_start;  //ep0 pointers modified from CC
unsigned char * EP0_end;    // modified from CC
unsigned char EP0_maxLength;

struct BufferDescriptorEntry { // buffer descriptor
	unsigned char EPStat;
	unsigned char bytes;
	unsigned int address;
};

struct BufferStruct { // buffer structure
	unsigned char bmRequestType;
	unsigned char bRequest;
	unsigned int   wValue;
	unsigned int   wIndex;
	unsigned int   wLength;
};

struct BufferDescriptorEntry * BDT= (struct BufferDescriptorEntry *)0x400; 
0EA0  6BE8      	CLRF gbl_BDT, 1
0EA2  0E04      	MOVLW 0x04
0EA4  6FE9      	MOVWF gbl_BDT+D'1', 1

struct BufferStruct *  Buffer;  //define Buffer as pointer to a BufferStruct
struct BufferStruct  BufferCopy;
struct BufferDescriptorEntry BDTCopy; 

//string descriptors in unicode format
const char String0 []  = {4, STRING, 9, 4};
0EA6  0E04      	MOVLW 0x04
0EA8  6FCD      	MOVWF gbl_String0, 1
0EAA  0E03      	MOVLW 0x03
0EAC  6FCE      	MOVWF gbl_String0+D'1', 1
0EAE  0E09      	MOVLW 0x09
0EB0  6FCF      	MOVWF gbl_String0+D'2', 1
0EB2  0E04      	MOVLW 0x04
0EB4  6FD0      	MOVWF gbl_String0+D'3', 1

const char String1 [] = {20, STRING,
0EB6  0E14      	MOVLW 0x14
0EB8  6F92      	MOVWF gbl_String1, 1
0EBA  0E03      	MOVLW 0x03
0EBC  6F93      	MOVWF gbl_String1+D'1', 1

'M',0,
0EBE  0E4D      	MOVLW 0x4D
0EC0  6F94      	MOVWF gbl_String1+D'2', 1
0EC2  6B95      	CLRF gbl_String1+D'3', 1

'i',0,
0EC4  0E69      	MOVLW 0x69
0EC6  6F96      	MOVWF gbl_String1+D'4', 1
0EC8  6B97      	CLRF gbl_String1+D'5', 1

'c',0,
0ECA  0E63      	MOVLW 0x63
0ECC  6F98      	MOVWF gbl_String1+D'6', 1
0ECE  6B99      	CLRF gbl_String1+D'7', 1

'r',0,
0ED0  0E72      	MOVLW 0x72
0ED2  6F9A      	MOVWF gbl_String1+D'8', 1
0ED4  6B9B      	CLRF gbl_String1+D'9', 1

'o',0,
0ED6  0E6F      	MOVLW 0x6F
0ED8  6F9C      	MOVWF gbl_String1+D'10', 1
0EDA  6B9D      	CLRF gbl_String1+D'11', 1

'c',0,
0EDC  0E63      	MOVLW 0x63
0EDE  6F9E      	MOVWF gbl_String1+D'12', 1
0EE0  6B9F      	CLRF gbl_String1+D'13', 1

'h',0,
0EE2  0E68      	MOVLW 0x68
0EE4  6FA0      	MOVWF gbl_String1+D'14', 1
0EE6  6BA1      	CLRF gbl_String1+D'15', 1

'i',0,
0EE8  0E69      	MOVLW 0x69
0EEA  6FA2      	MOVWF gbl_String1+D'16', 1
0EEC  6BA3      	CLRF gbl_String1+D'17', 1

'p',0};
0EEE  0E70      	MOVLW 0x70
0EF0  6FA4      	MOVWF gbl_String1+D'18', 1
0EF2  6BA5      	CLRF gbl_String1+D'19', 1

const char String2[] = {56,STRING,
0EF4  0E38      	MOVLW 0x38
0EF6  6E05      	MOVWF gbl_String2
0EF8  0E03      	MOVLW 0x03
0EFA  6E06      	MOVWF gbl_String2+D'1'

'P',0,
0EFC  0E50      	MOVLW 0x50
0EFE  6E07      	MOVWF gbl_String2+D'2'
0F00  6A08      	CLRF gbl_String2+D'3'

'i',0,
0F02  0E69      	MOVLW 0x69
0F04  6E09      	MOVWF gbl_String2+D'4'
0F06  6A0A      	CLRF gbl_String2+D'5'

'c',0,
0F08  0E63      	MOVLW 0x63
0F0A  6E0B      	MOVWF gbl_String2+D'6'
0F0C  6A0C      	CLRF gbl_String2+D'7'

'1',0,
0F0E  0E31      	MOVLW 0x31
0F10  6E0D      	MOVWF gbl_String2+D'8'
0F12  6A0E      	CLRF gbl_String2+D'9'

'8',0,
0F14  0E38      	MOVLW 0x38
0F16  6E0F      	MOVWF gbl_String2+D'10'
0F18  6A10      	CLRF gbl_String2+D'11'

'F',0,
0F1A  0E46      	MOVLW 0x46
0F1C  6E11      	MOVWF gbl_String2+D'12'
0F1E  6A12      	CLRF gbl_String2+D'13'

'2',0,
0F20  0E32      	MOVLW 0x32
0F22  6E13      	MOVWF gbl_String2+D'14'
0F24  6A14      	CLRF gbl_String2+D'15'

'5',0,
0F26  0E35      	MOVLW 0x35
0F28  6E15      	MOVWF gbl_String2+D'16'
0F2A  6A16      	CLRF gbl_String2+D'17'

'5',0,
0F2C  0E35      	MOVLW 0x35
0F2E  6E17      	MOVWF gbl_String2+D'18'
0F30  6A18      	CLRF gbl_String2+D'19'

'0',0,
0F32  0E30      	MOVLW 0x30
0F34  6E19      	MOVWF gbl_String2+D'20'
0F36  6A1A      	CLRF gbl_String2+D'21'

' ',0,
0F38  0E20      	MOVLW 0x20
0F3A  6E1B      	MOVWF gbl_String2+D'22'
0F3C  6A1C      	CLRF gbl_String2+D'23'

'I',0,
0F3E  0E49      	MOVLW 0x49
0F40  6E1D      	MOVWF gbl_String2+D'24'
0F42  6A1E      	CLRF gbl_String2+D'25'

'r',0,
0F44  0E72      	MOVLW 0x72
0F46  6E1F      	MOVWF gbl_String2+D'26'
0F48  6A20      	CLRF gbl_String2+D'27'

'r',0,
0F4A  0E72      	MOVLW 0x72
0F4C  6E21      	MOVWF gbl_String2+D'28'
0F4E  6A22      	CLRF gbl_String2+D'29'

'i',0,
0F50  0E69      	MOVLW 0x69
0F52  6E23      	MOVWF gbl_String2+D'30'
0F54  6A24      	CLRF gbl_String2+D'31'

't',0,
0F56  0E74      	MOVLW 0x74
0F58  6E25      	MOVWF gbl_String2+D'32'
0F5A  6A26      	CLRF gbl_String2+D'33'

'a',0,
0F5C  0E61      	MOVLW 0x61
0F5E  6E27      	MOVWF gbl_String2+D'34'
0F60  6A28      	CLRF gbl_String2+D'35'

't',0,
0F62  0E74      	MOVLW 0x74
0F64  6E29      	MOVWF gbl_String2+D'36'
0F66  6A2A      	CLRF gbl_String2+D'37'

'i',0,
0F68  0E69      	MOVLW 0x69
0F6A  6E2B      	MOVWF gbl_String2+D'38'
0F6C  6A2C      	CLRF gbl_String2+D'39'

'n',0,
0F6E  0E6E      	MOVLW 0x6E
0F70  6E2D      	MOVWF gbl_String2+D'40'
0F72  6A2E      	CLRF gbl_String2+D'41'

'g',0,
0F74  0E67      	MOVLW 0x67
0F76  6E2F      	MOVWF gbl_String2+D'42'
0F78  6A30      	CLRF gbl_String2+D'43'

' ',0, 
0F7A  0E20      	MOVLW 0x20
0F7C  6E31      	MOVWF gbl_String2+D'44'
0F7E  6A32      	CLRF gbl_String2+D'45'

'M',0,
0F80  0E4D      	MOVLW 0x4D
0F82  6E33      	MOVWF gbl_String2+D'46'
0F84  6A34      	CLRF gbl_String2+D'47'

'o',0,
0F86  0E6F      	MOVLW 0x6F
0F88  6E35      	MOVWF gbl_String2+D'48'
0F8A  6A36      	CLRF gbl_String2+D'49'

'u',0,
0F8C  0E75      	MOVLW 0x75
0F8E  6E37      	MOVWF gbl_String2+D'50'
0F90  6A38      	CLRF gbl_String2+D'51'

's',0,
0F92  0E73      	MOVLW 0x73
0F94  6E39      	MOVWF gbl_String2+D'52'
0F96  6A3A      	CLRF gbl_String2+D'53'

'e',0};
0F98  0E65      	MOVLW 0x65
0F9A  6E3B      	MOVWF gbl_String2+D'54'
0F9C  6A3C      	CLRF gbl_String2+D'55'


// Report descriptor prepared by USB DESCRIPTOR TOOL
// http://www.usb.org/developers/hidpage/#Descriptor_Tool
const char ReportDescriptor1[] = {
   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
0F9E  0E05      	MOVLW 0x05
0FA0  6F60      	MOVWF gbl_ReportDescriptor1, 1
0FA2  0E01      	MOVLW 0x01
0FA4  6F61      	MOVWF gbl_ReportDescriptor1+D'1', 1

   0x09, 0x02,                    //  USAGE (Mouse)
0FA6  0E09      	MOVLW 0x09
0FA8  6F62      	MOVWF gbl_ReportDescriptor1+D'2', 1
0FAA  0E02      	MOVLW 0x02
0FAC  6F63      	MOVWF gbl_ReportDescriptor1+D'3', 1

   0xa1, 0x01,                    //  COLLECTION (Application)
0FAE  0EA1      	MOVLW 0xA1
0FB0  6F64      	MOVWF gbl_ReportDescriptor1+D'4', 1
0FB2  0E01      	MOVLW 0x01
0FB4  6F65      	MOVWF gbl_ReportDescriptor1+D'5', 1

   0x09, 0x01,                    //  USAGE (Pointer)
0FB6  0E09      	MOVLW 0x09
0FB8  6F66      	MOVWF gbl_ReportDescriptor1+D'6', 1
0FBA  0E01      	MOVLW 0x01
0FBC  6F67      	MOVWF gbl_ReportDescriptor1+D'7', 1

   0xa1, 0x00,                    //  COLLECTION (Physical)
0FBE  0EA1      	MOVLW 0xA1
0FC0  6F68      	MOVWF gbl_ReportDescriptor1+D'8', 1
0FC2  6B69      	CLRF gbl_ReportDescriptor1+D'9', 1

   0x05, 0x09,                    //  USAGE_PAGE (Button)
0FC4  0E05      	MOVLW 0x05
0FC6  6F6A      	MOVWF gbl_ReportDescriptor1+D'10', 1
0FC8  0E09      	MOVLW 0x09
0FCA  6F6B      	MOVWF gbl_ReportDescriptor1+D'11', 1

   0x19, 0x01,                    //  USAGE_MINIMUM (Button 1)
0FCC  0E19      	MOVLW 0x19
0FCE  6F6C      	MOVWF gbl_ReportDescriptor1+D'12', 1
0FD0  0E01      	MOVLW 0x01
0FD2  6F6D      	MOVWF gbl_ReportDescriptor1+D'13', 1

   0x29, 0x03,                    //  USAGE_MAXIMUM (Button 3)
0FD4  0E29      	MOVLW 0x29
0FD6  6F6E      	MOVWF gbl_ReportDescriptor1+D'14', 1
0FD8  0E03      	MOVLW 0x03
0FDA  6F6F      	MOVWF gbl_ReportDescriptor1+D'15', 1

   0x15, 0x00,                    //  LOGICAL_MINIMUM (0)
0FDC  0E15      	MOVLW 0x15
0FDE  6F70      	MOVWF gbl_ReportDescriptor1+D'16', 1
0FE0  6B71      	CLRF gbl_ReportDescriptor1+D'17', 1

   0x25, 0x01,                    //  LOGICAL_MAXIMUM (1)
0FE2  0E25      	MOVLW 0x25
0FE4  6F72      	MOVWF gbl_ReportDescriptor1+D'18', 1
0FE6  0E01      	MOVLW 0x01
0FE8  6F73      	MOVWF gbl_ReportDescriptor1+D'19', 1

   0x95, 0x03,                    //  REPORT_COUNT (3)
0FEA  0E95      	MOVLW 0x95
0FEC  6F74      	MOVWF gbl_ReportDescriptor1+D'20', 1
0FEE  0E03      	MOVLW 0x03
0FF0  6F75      	MOVWF gbl_ReportDescriptor1+D'21', 1

   0x75, 0x01,                    //  REPORT_SIZE (1)
0FF2  0E75      	MOVLW 0x75
0FF4  6F76      	MOVWF gbl_ReportDescriptor1+D'22', 1
0FF6  0E01      	MOVLW 0x01
0FF8  6F77      	MOVWF gbl_ReportDescriptor1+D'23', 1

   0x81, 0x02,                    //  INPUT (Data,Var,Abs)
0FFA  0E81      	MOVLW 0x81
0FFC  6F78      	MOVWF gbl_ReportDescriptor1+D'24', 1
0FFE  0E02      	MOVLW 0x02
1000  6F79      	MOVWF gbl_ReportDescriptor1+D'25', 1

   0x95, 0x01,                    //  REPORT_COUNT (1)
1002  0E95      	MOVLW 0x95
1004  6F7A      	MOVWF gbl_ReportDescriptor1+D'26', 1
1006  0E01      	MOVLW 0x01
1008  6F7B      	MOVWF gbl_ReportDescriptor1+D'27', 1

   0x75, 0x05,                    //  REPORT_SIZE (5)
100A  0E75      	MOVLW 0x75
100C  6F7C      	MOVWF gbl_ReportDescriptor1+D'28', 1
100E  0E05      	MOVLW 0x05
1010  6F7D      	MOVWF gbl_ReportDescriptor1+D'29', 1

   0x81, 0x01,                    //  INPUT (Cnst,Ary,Abs)
1012  0E81      	MOVLW 0x81
1014  6F7E      	MOVWF gbl_ReportDescriptor1+D'30', 1
1016  0E01      	MOVLW 0x01
1018  6F7F      	MOVWF gbl_ReportDescriptor1+D'31', 1

   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
101A  0E05      	MOVLW 0x05
101C  6F80      	MOVWF gbl_ReportDescriptor1+D'32', 1
101E  0E01      	MOVLW 0x01
1020  6F81      	MOVWF gbl_ReportDescriptor1+D'33', 1

   0x09, 0x30,                    //  USAGE (X)
1022  0E09      	MOVLW 0x09
1024  6F82      	MOVWF gbl_ReportDescriptor1+D'34', 1
1026  0E30      	MOVLW 0x30
1028  6F83      	MOVWF gbl_ReportDescriptor1+D'35', 1

   0x09, 0x31,                    //  USAGE (Y)
102A  0E09      	MOVLW 0x09
102C  6F84      	MOVWF gbl_ReportDescriptor1+D'36', 1
102E  0E31      	MOVLW 0x31
1030  6F85      	MOVWF gbl_ReportDescriptor1+D'37', 1

   0x15, 0x81,                    //  LOGICAL_MINIMUM (-127)
1032  0E15      	MOVLW 0x15
1034  6F86      	MOVWF gbl_ReportDescriptor1+D'38', 1
1036  0E81      	MOVLW 0x81
1038  6F87      	MOVWF gbl_ReportDescriptor1+D'39', 1

   0x25, 0x7f,                    //  LOGICAL_MAXIMUM (127)
103A  0E25      	MOVLW 0x25
103C  6F88      	MOVWF gbl_ReportDescriptor1+D'40', 1
103E  0E7F      	MOVLW 0x7F
1040  6F89      	MOVWF gbl_ReportDescriptor1+D'41', 1

   0x75, 0x08,                    //  REPORT_SIZE (8)
1042  0E75      	MOVLW 0x75
1044  6F8A      	MOVWF gbl_ReportDescriptor1+D'42', 1
1046  0E08      	MOVLW 0x08
1048  6F8B      	MOVWF gbl_ReportDescriptor1+D'43', 1

   0x95, 0x02,                    //  REPORT_COUNT (2)
104A  0E95      	MOVLW 0x95
104C  6F8C      	MOVWF gbl_ReportDescriptor1+D'44', 1
104E  0E02      	MOVLW 0x02
1050  6F8D      	MOVWF gbl_ReportDescriptor1+D'45', 1

   0x81, 0x06,                    //  INPUT (Data,Var,Rel)
1052  0E81      	MOVLW 0x81
1054  6F8E      	MOVWF gbl_ReportDescriptor1+D'46', 1
1056  0E06      	MOVLW 0x06
1058  6F8F      	MOVWF gbl_ReportDescriptor1+D'47', 1

   0xc0,                          //  END_COLLECTION
105A  0EC0      	MOVLW 0xC0
105C  6F90      	MOVWF gbl_ReportDescriptor1+D'48', 1

   0xc0                           //  END_COLLECTION
105E  0EC0      	MOVLW 0xC0
1060  6F91      	MOVWF gbl_ReportDescriptor1+D'49', 1

};

const char DeviceDescriptor [] = {
    0x12, // 18 bytes long 
1062  0E12      	MOVLW 0x12
1064  6FA6      	MOVWF gbl_DeviceDescriptor, 1

    DEVICE, // descriptor type
1066  0E01      	MOVLW 0x01
1068  6FA7      	MOVWF gbl_DeviceDescriptor+D'1', 1

    0x10, 0x01, // USB specification release (1.10)
106A  0E10      	MOVLW 0x10
106C  6FA8      	MOVWF gbl_DeviceDescriptor+D'2', 1
106E  0E01      	MOVLW 0x01
1070  6FA9      	MOVWF gbl_DeviceDescriptor+D'3', 1

    0x00, // class code
1072  6BAA      	CLRF gbl_DeviceDescriptor+D'4', 1

    0x00, // subclass code
1074  6BAB      	CLRF gbl_DeviceDescriptor+D'5', 1

    0x00, // protocol code
1076  6BAC      	CLRF gbl_DeviceDescriptor+D'6', 1

    0x08, // maximum packet size
1078  0E08      	MOVLW 0x08
107A  6FAD      	MOVWF gbl_DeviceDescriptor+D'7', 1

    0xD8,0x04, // vendor id (04d8) microchip
107C  0ED8      	MOVLW 0xD8
107E  6FAE      	MOVWF gbl_DeviceDescriptor+D'8', 1
1080  0E04      	MOVLW 0x04
1082  6FAF      	MOVWF gbl_DeviceDescriptor+D'9', 1

    0x09,0x00, //product id (0009)
1084  0E09      	MOVLW 0x09
1086  6FB0      	MOVWF gbl_DeviceDescriptor+D'10', 1
1088  6BB1      	CLRF gbl_DeviceDescriptor+D'11', 1

    0x00,0x02, // device release number 2.00
108A  6BB2      	CLRF gbl_DeviceDescriptor+D'12', 1
108C  0E02      	MOVLW 0x02
108E  6FB3      	MOVWF gbl_DeviceDescriptor+D'13', 1

    0x01, // index to string that describes vendor
1090  0E01      	MOVLW 0x01
1092  6FB4      	MOVWF gbl_DeviceDescriptor+D'14', 1

    0x02, // index to string that describes product
1094  0E02      	MOVLW 0x02
1096  6FB5      	MOVWF gbl_DeviceDescriptor+D'15', 1

    0x00, // index to string that describes serial number (none)
1098  6BB6      	CLRF gbl_DeviceDescriptor+D'16', 1

    0x01  // number of possible configurations
109A  0E01      	MOVLW 0x01
109C  6FB7      	MOVWF gbl_DeviceDescriptor+D'17', 1

};

//CONFIG DESCRIPTOR ORDER CORRESPONDS TO HID 1.0 OR LATER
const char ConfigDescriptor [] = {
    0x09, // 9 bytes long
109E  0E09      	MOVLW 0x09
10A0  6E3D      	MOVWF gbl_ConfigDescriptor

    CONFIGURATION, // descriptor type
10A2  0E02      	MOVLW 0x02
10A4  6E3E      	MOVWF gbl_ConfigDescriptor+D'1'

    0x22, 0x00, // total length of config, interface, HID and endpoint descriptors
10A6  0E22      	MOVLW 0x22
10A8  6E3F      	MOVWF gbl_ConfigDescriptor+D'2'
10AA  6A40      	CLRF gbl_ConfigDescriptor+D'3'

    0x01, // number of interfaces
10AC  0E01      	MOVLW 0x01
10AE  6E41      	MOVWF gbl_ConfigDescriptor+D'4'

    0x01, // configuration number
10B0  0E01      	MOVLW 0x01
10B2  6E42      	MOVWF gbl_ConfigDescriptor+D'5'

    0x00, // index to string that describes configuration (none)
10B4  6A43      	CLRF gbl_ConfigDescriptor+D'6'

    0xA0, // configuration attributes , remote wakeup
10B6  0EA0      	MOVLW 0xA0
10B8  6E44      	MOVWF gbl_ConfigDescriptor+D'7'

    0x32, // current consumption in 2mA units (100 mA) 
10BA  0E32      	MOVLW 0x32
10BC  6E45      	MOVWF gbl_ConfigDescriptor+D'8'

    /* Interface Descriptor  */      0x09,// 9 bytes long
10BE  0E09      	MOVLW 0x09
10C0  6E46      	MOVWF gbl_ConfigDescriptor+D'9'

    INTERFACE, // descriptor type
10C2  0E04      	MOVLW 0x04
10C4  6E47      	MOVWF gbl_ConfigDescriptor+D'10'

    0x00, // number of this interface (zerp based)
10C6  6A48      	CLRF gbl_ConfigDescriptor+D'11'

    0x00, // alternate setting (none)
10C8  6A49      	CLRF gbl_ConfigDescriptor+D'12'

    0x01, // number of endpoints used by interface
10CA  0E01      	MOVLW 0x01
10CC  6E4A      	MOVWF gbl_ConfigDescriptor+D'13'

    0x03, // class code
10CE  0E03      	MOVLW 0x03
10D0  6E4B      	MOVWF gbl_ConfigDescriptor+D'14'

    0x01, // subclass code
10D2  0E01      	MOVLW 0x01
10D4  6E4C      	MOVWF gbl_ConfigDescriptor+D'15'

    0x02, // protocol 
10D6  0E02      	MOVLW 0x02
10D8  6E4D      	MOVWF gbl_ConfigDescriptor+D'16'

    0x00, // index to string that describes endpoint (none)
10DA  6A4E      	CLRF gbl_ConfigDescriptor+D'17'

    /* HID descriptor described above */     
    0x09, 0x21, 0x10, 0x01, 0x00, 0x01, 0x22, sizeof(ReportDescriptor1), sizeof(ReportDescriptor1)>>8,
10DC  0E09      	MOVLW 0x09
10DE  6E4F      	MOVWF gbl_ConfigDescriptor+D'18'
10E0  0E21      	MOVLW 0x21
10E2  6E50      	MOVWF gbl_ConfigDescriptor+D'19'
10E4  0E10      	MOVLW 0x10
10E6  6E51      	MOVWF gbl_ConfigDescriptor+D'20'
10E8  0E01      	MOVLW 0x01
10EA  6E52      	MOVWF gbl_ConfigDescriptor+D'21'
10EC  6A53      	CLRF gbl_ConfigDescriptor+D'22'
10EE  0E01      	MOVLW 0x01
10F0  6E54      	MOVWF gbl_ConfigDescriptor+D'23'
10F2  0E22      	MOVLW 0x22
10F4  6E55      	MOVWF gbl_ConfigDescriptor+D'24'
10F6  0E32      	MOVLW 0x32
10F8  6E56      	MOVWF gbl_ConfigDescriptor+D'25'
10FA  6A57      	CLRF gbl_ConfigDescriptor+D'26'

    /* Endpoint 1 descriptor */       0x07, // 7 bytes long
10FC  0E07      	MOVLW 0x07
10FE  6E58      	MOVWF gbl_ConfigDescriptor+D'27'

    ENDPOINT, // descriptor type
1100  0E05      	MOVLW 0x05
1102  6E59      	MOVWF gbl_ConfigDescriptor+D'28'

    0x81, // endpoint characteristics (IN endpoint)
1104  0E81      	MOVLW 0x81
1106  6E5A      	MOVWF gbl_ConfigDescriptor+D'29'

    0x03, // endpoint attributes  (interrupt)
1108  0E03      	MOVLW 0x03
110A  6E5B      	MOVWF gbl_ConfigDescriptor+D'30'

    0x03, 0x00, // max packet size (HID 3 byte report)
110C  0E03      	MOVLW 0x03
110E  6E5C      	MOVWF gbl_ConfigDescriptor+D'31'
1110  6A5D      	CLRF gbl_ConfigDescriptor+D'32'

    0x0A //polling interval in 1 msec increments (10)
1112  0E0A      	MOVLW 0x0A
1114  6E5E      	MOVWF gbl_ConfigDescriptor+D'33'

};

const unsigned int ReportDescrSize = sizeof(ReportDescriptor1);
1116  0E32      	MOVLW 0x32
1118  6FEC      	MOVWF gbl_ReportDescrSize, 1
111A  6BED      	CLRF gbl_ReportDescrSize+D'1', 1

const char  HIDDescriptor [] =    {
    0x09, // 9 bytes long
111C  0E09      	MOVLW 0x09
111E  6FB8      	MOVWF gbl_HIDDescriptor, 1

    0x21, // descriptor type, HID=21
1120  0E21      	MOVLW 0x21
1122  6FB9      	MOVWF gbl_HIDDescriptor+D'1', 1

    0x10, 0x01,  // HUD class version 1.10
1124  0E10      	MOVLW 0x10
1126  6FBA      	MOVWF gbl_HIDDescriptor+D'2', 1
1128  0E01      	MOVLW 0x01
112A  6FBB      	MOVWF gbl_HIDDescriptor+D'3', 1

    0x00, // country code (none)
112C  6BBC      	CLRF gbl_HIDDescriptor+D'4', 1

    0x01, // Number of HID class descriptors
112E  0E01      	MOVLW 0x01
1130  6FBD      	MOVWF gbl_HIDDescriptor+D'5', 1

    0x22, // Type of class descriptor (report)
1132  0E22      	MOVLW 0x22
1134  6FBE      	MOVWF gbl_HIDDescriptor+D'6', 1

    sizeof(ReportDescriptor1), sizeof(ReportDescriptor1)>>8  // Size of report descriptor
1136  0E32      	MOVLW 0x32
1138  6FBF      	MOVWF gbl_HIDDescriptor+D'7', 1
113A  6BC0      	CLRF gbl_HIDDescriptor+D'8', 1

};

/* PutEP1 **************************************************************** */
/* Tests the EP1 IN OWNS bit.  If there is a buffer available to us, your  */
/* buffer is copied and turned over to the SIE for transmission on the     */
/* next IN transfer and returns TRUE (1).  If the buffer is not available, */
/* FALSE is returned (0).                                                  */
/* *********************************************************************** */
unsigned char PutEP1(unsigned char bytes, signed char *buffer) {

	signed char * tobuffer;
	unsigned char i;

	ddrb = 0; //setup b for output
0C58  6A93      	CLRF gbl_ddrb


	if ((bd1statie & 0x80) == 0) { /* do we own the buffer? UOWN=0*/
0C5A  0E80      	MOVLW 0x80
0C5C  0104      	MOVLB 0x04
0C5E  150C      	ANDWF gbl_bd1statie, W, 1
0C60  0101      	MOVLB 0x01
0C62  6F1C      	MOVWF CompTempVar570, 1
0C64  531C      	MOVF CompTempVar570, F, 1
0C66  E13A      	BNZ	label113
0CDC            label113

		bd1cntie = bytes;
0C68  0100      	MOVLB 0x00
0C6A  51FE      	MOVF PutEP1_00000_arg_bytes, W, 1
0C6C  0104      	MOVLB 0x04
0C6E  6F0D      	MOVWF gbl_bd1cntie, 1

        tobuffer = (signed char *) ((unsigned int)bd1adrlie + (unsigned int)(bd1adrhie <<8));
0C70  510E      	MOVF gbl_bd1adrlie, W, 1
0C72  0101      	MOVLB 0x01
0C74  6F1A      	MOVWF PutEP1_00000_1_tobuffer, 1
0C76  6B1E      	CLRF CompTempVar573+D'1', 1
0C78  6B1F      	CLRF CompTempVar574, 1
0C7A  0104      	MOVLB 0x04
0C7C  510F      	MOVF gbl_bd1adrhie, W, 1
0C7E  0101      	MOVLB 0x01
0C80  6F1B      	MOVWF PutEP1_00000_1_tobuffer+D'1', 1
0C82  511F      	MOVF CompTempVar574, W, 1
0C84  271A      	ADDWF PutEP1_00000_1_tobuffer, F, 1
0C86  511E      	MOVF CompTempVar573+D'1', W, 1
0C88  231B      	ADDWFC PutEP1_00000_1_tobuffer+D'1', F, 1


		for (i = 0; i < bytes; i++) {
0C8A  0100      	MOVLB 0x00
0C8C  6BFF      	CLRF PutEP1_00000_1_i, 1
0C8E            label111
0C8E  51FE      	MOVF PutEP1_00000_arg_bytes, W, 1
0C90  61FF      	CPFSLT PutEP1_00000_1_i, 1
0C92  D019      	BRA	label112
0CC0  0100      	MOVLB 0x00
0CC2  2BFF      	INCF PutEP1_00000_1_i, F, 1
0CC4  D7E4      	BRA	label111
0CC6            label112

	        tobuffer[i] = buffer[i];
0C94  0101      	MOVLB 0x01
0C96  5119      	MOVF PutEP1_00000_arg_buffer+D'1', W, 1
0C98  6EEA      	MOVWF FSR0H
0C9A  5118      	MOVF PutEP1_00000_arg_buffer, W, 1
0C9C  6EE9      	MOVWF FSR0L
0C9E  0100      	MOVLB 0x00
0CA0  51FF      	MOVF PutEP1_00000_1_i, W, 1
0CA2  0101      	MOVLB 0x01
0CA4  6F1D      	MOVWF CompTempVar578, 1
0CA6  511D      	MOVF CompTempVar578, W, 1
0CA8  26E9      	ADDWF FSR0L, F
0CAA  50EF      	MOVF INDF0, W
0CAC  6F1E      	MOVWF CompTempVar579, 1
0CAE  511B      	MOVF PutEP1_00000_1_tobuffer+D'1', W, 1
0CB0  6EEA      	MOVWF FSR0H
0CB2  511A      	MOVF PutEP1_00000_1_tobuffer, W, 1
0CB4  0100      	MOVLB 0x00
0CB6  25FF      	ADDWF PutEP1_00000_1_i, W, 1
0CB8  6EE9      	MOVWF FSR0L
0CBA  0101      	MOVLB 0x01
0CBC  511E      	MOVF CompTempVar579, W, 1
0CBE  6EEF      	MOVWF INDF0

		}

	    bd1statie &= 0x40; /* save only the Data 1/0 bit */
0CC6  0E40      	MOVLW 0x40
0CC8  0104      	MOVLB 0x04
0CCA  170C      	ANDWF gbl_bd1statie, F, 1

	    bd1statie ^= 0x40; /* toggle Data 0/1 bit */
0CCC  0E40      	MOVLW 0x40
0CCE  1B0C      	XORWF gbl_bd1statie, F, 1

	    bd1statie ^= 0x88; /* release buffer */ 
0CD0  0E88      	MOVLW 0x88
0CD2  1B0C      	XORWF gbl_bd1statie, F, 1

		return TRUE;
0CD4  0E01      	MOVLW 0x01
0CD6  0101      	MOVLB 0x01
0CD8  6F1D      	MOVWF CompTempVarRet569, 1

	}
	return FALSE;	/* Buffer not available, return false */
0CDC  6B1D      	CLRF CompTempVarRet569, 1

}
0CDA  0012      	RETURN
0CDE  0012      	RETURN


/* ********************************************************************* */
/* Enable Wakeup on interupt and Activity interrupt then put the         */
/* device to sleep to save power.  Activity on the D+/D- lines will      */
/* set the ACTIVITY interrupt, waking up the part.                       */
/* ********************************************************************* */
void USBSleep() {

	bACTIVITY_E = 1; // enable activity interrupt
0138  8469      	BSF gbl_bACTIVITY_E,2

	bUIDLE = 0; //disable idle interrupt
013A  9869      	BCF gbl_bUIDLE,4

	bSUSPND	= 1;  // put in suspend mode
013C  826D      	BSF gbl_bSUSPND,1

	USB_IsIdle = 1; // mark device as idle
013E  0E01      	MOVLW 0x01
0140  0100      	MOVLB 0x00
0142  6FEE      	MOVWF gbl_USB_IsIdle, 1

}
0144  0012      	RETURN


/* ********************************************************************* */
/* Service the Activity Interrupt.  This is only enabled when the        */
/* device is put to sleep as a result of inactivity on the bus.  This    */
/* code wakes up the part, disables the activity interrupt and reenables */
/* the idle interrupt.                                                   */
/* ********************************************************************* */
void USBActivity() {

	bACTIVITY = 0;
00A6  9468      	BCF gbl_bACTIVITY,2

	bACTIVITY_E = 0;
00A8  9469      	BCF gbl_bACTIVITY_E,2

	bSUSPND = 0; //normal operation
00AA  926D      	BCF gbl_bSUSPND,1

	USB_IsIdle = 0;
00AC  0100      	MOVLB 0x00
00AE  6BEE      	CLRF gbl_USB_IsIdle, 1

}
00B0  0012      	RETURN


/* ****************************************************************** */
/* USB Reset interrupt triggered (SE0)                                */
/* initialize the Buffer Descriptor Table,                            */
/* Transition to the DEFAULT state,                                   */
/* Set address to 0                                                   */
/* enable the USB                                                     */
/* ****************************************************************** */
void USBReset() {

	USB_Curr_Config = 0;
0074  0100      	MOVLB 0x00
0076  6BF0      	CLRF gbl_USB_Curr_Config, 1

	USB_IsIdle = 0;
0078  6BEE      	CLRF gbl_USB_IsIdle, 1

	bTOK_DONE = 0; // clear TOK_DNE bit in uir 4 times to 
007A  9668      	BCF gbl_bTOK_DONE,3

	bTOK_DONE = 0; // clear out the USTAT FIFO.  See Microchip 	
007C  9668      	BCF gbl_bTOK_DONE,3

	bTOK_DONE = 0; // 18F2455 data sheet.
007E  9668      	BCF gbl_bTOK_DONE,3

	bTOK_DONE = 0;
0080  9668      	BCF gbl_bTOK_DONE,3

	bd0cntoe = 8; //set up for 8 byte buffer
0082  0E08      	MOVLW 0x08
0084  0104      	MOVLB 0x04
0086  6F01      	MOVWF gbl_bd0cntoe, 1

	bd0statoe = 0x88;	// EP0 Out buffer (USB OWNS)
0088  0E88      	MOVLW 0x88
008A  6F00      	MOVWF gbl_bd0statoe, 1

	bd0statie = 0x08;    // EP0 In buffer (MCU OWNS)
008C  0E08      	MOVLW 0x08
008E  6F04      	MOVWF gbl_bd0statie, 1

	uaddr = 0; // clear address
0090  6A6E      	CLRF gbl_uaddr

	uir = 0; // clear USB interrupt flag
0092  6A68      	CLRF gbl_uir

	uie	= 00000101b; // enable reset and activity interrupt
0094  0E05      	MOVLW 0x05
0096  6E69      	MOVWF gbl_uie

	uep0 = ENDPT_CONTROL;
0098  0E16      	MOVLW 0x16
009A  6E70      	MOVWF gbl_uep0

	USWSTAT = DEFAULT_STATE;
009C  0E01      	MOVLW 0x01
009E  0100      	MOVLB 0x00
00A0  6FF6      	MOVWF gbl_USWSTAT, 1

	USB_status_device = 1;
00A2  6FEF      	MOVWF gbl_USB_status_device, 1

}
00A4  0012      	RETURN


/* ******************* */
/* CopyDescriptorToEP0 ************************************************** */
/* copies the next chunk of buffer descriptor over to the EP0 In buffer.  */
/* Inputs:                                                                */
/*    EP0_start - points to first byte of configuration table to transfer */
/*    EP0_end - total number of bytes to transfer                         */
/*    EP0_maxLength - maximum number of bytes that can be sent during     */
/*    a single transfer                                                   */
/*                                                                        */
/* toggles the data0/1 bit before setting the UOWN bit over to SIE.       */
/* ********************************************************************** */
void CopyDescriptorToEP0() {

	unsigned char *  USBbuffer;  /* pointer to the USB Buffers */
	unsigned char bufindex;
	USBbuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));
00B2  0104      	MOVLB 0x04
00B4  5106      	MOVF gbl_bd0adrlie, W, 1
00B6  0101      	MOVLB 0x01
00B8  6F2A      	MOVWF CopyDescri_0000B_1_USBbuffer, 1
00BA  6B2E      	CLRF CompTempVar582+D'1', 1
00BC  6B2F      	CLRF CompTempVar583, 1
00BE  0104      	MOVLB 0x04
00C0  5107      	MOVF gbl_bd0adrhie, W, 1
00C2  0101      	MOVLB 0x01
00C4  6F2B      	MOVWF CopyDescri_0000B_1_USBbuffer+D'1', 1
00C6  512F      	MOVF CompTempVar583, W, 1
00C8  272A      	ADDWF CopyDescri_0000B_1_USBbuffer, F, 1
00CA  512E      	MOVF CompTempVar582+D'1', W, 1
00CC  232B      	ADDWFC CopyDescri_0000B_1_USBbuffer+D'1', F, 1

	bufindex  = 0;
00CE  6B2C      	CLRF CopyDescri_0000B_1_bufindex, 1

    while ((bufindex < EP0_maxLength) && ((unsigned short)EP0_start <(unsigned short) EP0_end)) {
00D0            label3
00D0  0100      	MOVLB 0x00
00D2  51F7      	MOVF gbl_EP0_maxLength, W, 1
00D4  0101      	MOVLB 0x01
00D6  612C      	CPFSLT CopyDescri_0000B_1_bufindex, 1
00D8  D01B      	BRA	label5
00DA  0100      	MOVLB 0x00
00DC  51E7      	MOVF gbl_EP0_end+D'1', W, 1
00DE  5DE5      	SUBWF gbl_EP0_start+D'1', W, 1
00E0  E102      	BNZ	label4
00E2  51E6      	MOVF gbl_EP0_end, W, 1
00E4  5DE4      	SUBWF gbl_EP0_start, W, 1
00E6            label4
00E6  E214      	BC	label5
010E  D7E0      	BRA	label3
0110            label5

		USBbuffer [bufindex] = *EP0_start;
00E8  51E5      	MOVF gbl_EP0_start+D'1', W, 1
00EA  6EEA      	MOVWF FSR0H
00EC  51E4      	MOVF gbl_EP0_start, W, 1
00EE  6EE9      	MOVWF FSR0L
00F0  50EF      	MOVF INDF0, W
00F2  0101      	MOVLB 0x01
00F4  6F2D      	MOVWF CompTempVar586, 1
00F6  512B      	MOVF CopyDescri_0000B_1_USBbuffer+D'1', W, 1
00F8  6EEA      	MOVWF FSR0H
00FA  512A      	MOVF CopyDescri_0000B_1_USBbuffer, W, 1
00FC  252C      	ADDWF CopyDescri_0000B_1_bufindex, W, 1
00FE  6EE9      	MOVWF FSR0L
0100  512D      	MOVF CompTempVar586, W, 1
0102  6EEF      	MOVWF INDF0

		++ EP0_start;
0104  0100      	MOVLB 0x00
0106  4BE4      	INFSNZ gbl_EP0_start, F, 1
0108  2BE5      	INCF gbl_EP0_start+D'1', F, 1

		++ bufindex;
010A  0101      	MOVLB 0x01
010C  2B2C      	INCF CopyDescri_0000B_1_bufindex, F, 1

	}
	if (bufindex < EP0_maxLength)	/* are we sending a short packet? */
0110  0100      	MOVLB 0x00
0112  51F7      	MOVF gbl_EP0_maxLength, W, 1
0114  0101      	MOVLB 0x01
0116  612C      	CPFSLT CopyDescri_0000B_1_bufindex, 1
0118  D002      	BRA	label6
011E            label6

		USB_dev_req = 0;	/* Yes, clear the device reqest */
011A  0100      	MOVLB 0x00
011C  6BF2      	CLRF gbl_USB_dev_req, 1


	bd0cntie  = bufindex;
011E  0101      	MOVLB 0x01
0120  512C      	MOVF CopyDescri_0000B_1_bufindex, W, 1
0122  0104      	MOVLB 0x04
0124  6F05      	MOVWF gbl_bd0cntie, 1

	bd0statie &= 0x40;		/* save only the DTS bit */
0126  0E40      	MOVLW 0x40
0128  1704      	ANDWF gbl_bd0statie, F, 1

	bd0statie ^= 0x40;		/* toggle data DTS bit */
012A  0E40      	MOVLW 0x40
012C  1B04      	XORWF gbl_bd0statie, F, 1

	bd0statie |= 0x88;		/* set OWN and DTSEN bits */
012E  0E88      	MOVLW 0x88
0130  1304      	IORWF gbl_bd0statie, F, 1

}
0132  0012      	RETURN


/* ******** */
/* Init USB ********************************************************* */
/* Initializes the USB peripheral, sets up the interrupts             */
/* ****************************************************************** */
void InitUSB() {

	//ucfg.UTRDIS = 0; // enable internal transceiver
	ucfg.FSEN = 1; // Full speed enable
0CE0  846F      	BSF gbl_ucfg,2

	ucfg.UPUEN = 1; // Enable on-chip pull-ups
0CE2  886F      	BSF gbl_ucfg,4

	//ucfg.PPB1 = 0; // Disable ping-pong buffering
	//ucfg.PPB0 = 0; // Disable ping-pong buffering
	//uie.STALLIE = 1; // interrupt on stall
	//uie.TRNIE = 1; //   on transaction complete
	uie.URSTIE = 1; //   on reset 
0CE4  8069      	BSF gbl_uie,0

	pie2.USBIE = 1; // general USB interrupts
0CE6  8AA0      	BSF gbl_pie2,5

	
	ucon.PPBRST = 1; // reset pingpong buffers
0CE8  8C6D      	BSF gbl_ucon,6

	ucon.PPBRST = 0; // unlock pingpong buffers
0CEA  9C6D      	BCF gbl_ucon,6

	ucon.USBEN = 1;	// enable usb
0CEC  866D      	BSF gbl_ucon,3

	
	USB_Curr_Config = 0;
0CEE  0100      	MOVLB 0x00
0CF0  6BF0      	CLRF gbl_USB_Curr_Config, 1

	USB_status_device = 1;
0CF2  0E01      	MOVLW 0x01
0CF4  6FEF      	MOVWF gbl_USB_status_device, 1

	char USB_Interface[] = {0,0,0};
0CF6  0101      	MOVLB 0x01
0CF8  6B18      	CLRF InitUSB_00000_1_USB_Interface, 1
0CFA  6B19      	CLRF InitUSB_00000_1_USB_Interface+D'1', 1
0CFC  6B1A      	CLRF InitUSB_00000_1_USB_Interface+D'2', 1

	USB_dev_req = NULL;
0CFE  0100      	MOVLB 0x00
0D00  6BF2      	CLRF gbl_USB_dev_req, 1

	// clear all error counters
	USB_PID_ERR = 0;
0D02  6BD4      	CLRF gbl_USB_PID_ERR, 1
0D04  6BD5      	CLRF gbl_USB_PID_ERR+D'1', 1

	USB_CRC5_ERR = 0;
0D06  6BD6      	CLRF gbl_USB_CRC5_ERR, 1
0D08  6BD7      	CLRF gbl_USB_CRC5_ERR+D'1', 1

	USB_CRC16_ERR = 0;
0D0A  6BD8      	CLRF gbl_USB_CRC16_ERR, 1
0D0C  6BD9      	CLRF gbl_USB_CRC16_ERR+D'1', 1

	USB_DFN8_ERR = 0;
0D0E  6BDA      	CLRF gbl_USB_DFN8_ERR, 1
0D10  6BDB      	CLRF gbl_USB_DFN8_ERR+D'1', 1

	USB_BTO_ERR = 0;
0D12  6BDC      	CLRF gbl_USB_BTO_ERR, 1
0D14  6BDD      	CLRF gbl_USB_BTO_ERR+D'1', 1

	USB_BTS_ERR = 0;
0D16  6BE2      	CLRF gbl_USB_BTS_ERR, 1
0D18  6BE3      	CLRF gbl_USB_BTS_ERR+D'1', 1

	intcon = intcon | 11000000b; // Enable GIE & PEIE
0D1A  0EC0      	MOVLW 0xC0
0D1C  10F2      	IORWF gbl_intcon, W
0D1E  6EF2      	MOVWF gbl_intcon

}
0D20  0012      	RETURN


/* ********************************************************************* */
/* This is activated by the STALL bit in the UIR register.  It really    */
/* just tells us that the SIE sent a STALL handshake.  So far, Don't     */
/* see that any action is required.  Clear the bit and move on.          */
/* ********************************************************************* */
void USBStall() {

	bSTALL = 0;
0134  9A68      	BCF gbl_bSTALL,5

}
0136  0012      	RETURN


/* ****************************************************************** */
/* The SIE detected an error.  This code increments the appropriate   */
/* error counter and clears the flag.                                 */
/* ****************************************************************** */
void Count_Error() {

	if (bPID_ERR && bPID_ERR_E) {
0BE4  A06A      	BTFSS gbl_bPID_ERR,0
0BE6  D005      	BRA	label105
0BE8  A06B      	BTFSS gbl_bPID_ERR_E,0
0BEA  D003      	BRA	label105

		++USB_PID_ERR;
0BEC  0100      	MOVLB 0x00
0BEE  4BD4      	INFSNZ gbl_USB_PID_ERR, F, 1
0BF0  2BD5      	INCF gbl_USB_PID_ERR+D'1', F, 1
0BF2            label105

	}
	if (bCRC5 && bCRC5_E) {
0BF2  A26A      	BTFSS gbl_bCRC5,1
0BF4  D005      	BRA	label106
0BF6  A26B      	BTFSS gbl_bCRC5_E,1
0BF8  D003      	BRA	label106

		++USB_CRC5_ERR;
0BFA  0100      	MOVLB 0x00
0BFC  4BD6      	INFSNZ gbl_USB_CRC5_ERR, F, 1
0BFE  2BD7      	INCF gbl_USB_CRC5_ERR+D'1', F, 1
0C00            label106

	}
	if (bCRC16 && bCRC16_E) {
0C00  A46A      	BTFSS gbl_bCRC16,2
0C02  D005      	BRA	label107
0C04  A46B      	BTFSS gbl_bCRC16_E,2
0C06  D003      	BRA	label107

		++USB_CRC16_ERR;
0C08  0100      	MOVLB 0x00
0C0A  4BD8      	INFSNZ gbl_USB_CRC16_ERR, F, 1
0C0C  2BD9      	INCF gbl_USB_CRC16_ERR+D'1', F, 1
0C0E            label107

	}
	if (bDFN8 && bDFN8_E) {
0C0E  A66A      	BTFSS gbl_bDFN8,3
0C10  D005      	BRA	label108
0C12  A66B      	BTFSS gbl_bDFN8_E,3
0C14  D003      	BRA	label108

		++USB_DFN8_ERR;
0C16  0100      	MOVLB 0x00
0C18  4BDA      	INFSNZ gbl_USB_DFN8_ERR, F, 1
0C1A  2BDB      	INCF gbl_USB_DFN8_ERR+D'1', F, 1
0C1C            label108

	}
	if (bBTO_ERR && bBTO_ERR_E) {
0C1C  A86A      	BTFSS gbl_bBTO_ERR,4
0C1E  D005      	BRA	label109
0C20  A86B      	BTFSS gbl_bBTO_ERR_E,4
0C22  D003      	BRA	label109

		++USB_BTO_ERR;
0C24  0100      	MOVLB 0x00
0C26  4BDC      	INFSNZ gbl_USB_BTO_ERR, F, 1
0C28  2BDD      	INCF gbl_USB_BTO_ERR+D'1', F, 1
0C2A            label109

	}
	if (bBTS_ERR && bBTS_ERR_E) {
0C2A  AE6A      	BTFSS gbl_bBTS_ERR,7
0C2C  D005      	BRA	label110
0C2E  AE6B      	BTFSS gbl_bBTS_ERR_E,7
0C30  D003      	BRA	label110

		++USB_BTS_ERR;
0C32  0100      	MOVLB 0x00
0C34  4BE2      	INFSNZ gbl_USB_BTS_ERR, F, 1
0C36  2BE3      	INCF gbl_USB_BTS_ERR+D'1', F, 1
0C38            label110

	}
	ueir = 0; //Clear all USB error flag bits
0C38  6A6A      	CLRF gbl_ueir

	bUERR = 0; //Clear master USB error flag bit
0C3A  9268      	BCF gbl_bUERR,1

}
0C3C  0012      	RETURN

/* ******************************************************************* */
/* Process token done interrupt...  Most of the work gets done through */
/* this interrupt.  Token Done is signaled in response to an In, Out,  */
/* or Setup transaction.                                               */
/* ******************************************************************* */
void Process_Req() {

	unsigned char *OutBuffer;
	unsigned char *UEPArray;
	unsigned char DescriptorType;
	unsigned char Endpoint;
	unsigned char Interface;
	unsigned char DescriptorID;
	unsigned char StringID;
	USB_USTAT = ustat;
0146  506C      	MOVF gbl_ustat, W
0148  0100      	MOVLB 0x00
014A  6FF3      	MOVWF gbl_USB_USTAT, 1

	ACTIVE_BUF = (USB_USTAT >> 3) * 2; //EP*2 (IF OUTPUT)
014C  31F3      	RRCF gbl_USB_USTAT, W, 1
014E  6FF4      	MOVWF gbl_ACTIVE_BUF, 1
0150  33F4      	RRCF gbl_ACTIVE_BUF, F, 1
0152  33F4      	RRCF gbl_ACTIVE_BUF, F, 1
0154  0E1F      	MOVLW 0x1F
0156  17F4      	ANDWF gbl_ACTIVE_BUF, F, 1
0158  90D8      	BCF STATUS,C
015A  37F4      	RLCF gbl_ACTIVE_BUF, F, 1

	ACTIVE_BUF = (ACTIVE_BUF + (USB_USTAT & 0x4) >> 2);  //=EP*2 + 1 (IF INPUT) 
015C  0E04      	MOVLW 0x04
015E  15F3      	ANDWF gbl_USB_USTAT, W, 1
0160  0101      	MOVLB 0x01
0162  6F22      	MOVWF CompTempVar593, 1
0164  6B23      	CLRF CompTempVar596, 1
0166  5122      	MOVF CompTempVar593, W, 1
0168  0100      	MOVLB 0x00
016A  27F4      	ADDWF gbl_ACTIVE_BUF, F, 1
016C  E302      	BNC	label7
016E  0101      	MOVLB 0x01
0170  2B23      	INCF CompTempVar596, F, 1
0172  0101      	MOVLB 0x01
0174  3323      	RRCF CompTempVar596, F, 1
0176  0100      	MOVLB 0x00
0178  33F4      	RRCF gbl_ACTIVE_BUF, F, 1
017A  0101      	MOVLB 0x01
017C  3323      	RRCF CompTempVar596, F, 1
017E  0100      	MOVLB 0x00
0180  33F4      	RRCF gbl_ACTIVE_BUF, F, 1

//save data in buffer descriptor table
	BDTCopy.EPStat = BDT[ACTIVE_BUF].EPStat;
0182  51E9      	MOVF gbl_BDT+D'1', W, 1
0184  6EEA      	MOVWF FSR0H
0186  51E8      	MOVF gbl_BDT, W, 1
0188  6EE9      	MOVWF FSR0L
018A  51F4      	MOVF gbl_ACTIVE_BUF, W, 1
018C  0101      	MOVLB 0x01
018E  6F22      	MOVWF CompTempVar597, 1
0190  3722      	RLCF CompTempVar597, F, 1
0192  3722      	RLCF CompTempVar597, F, 1
0194  0EFC      	MOVLW 0xFC
0196  1522      	ANDWF CompTempVar597, W, 1
0198  26E9      	ADDWF FSR0L, F
019A  50EF      	MOVF INDF0, W
019C  0100      	MOVLB 0x00
019E  6FC9      	MOVWF gbl_BDTCopy, 1

	BDTCopy.bytes = BDT[ACTIVE_BUF].bytes;
01A0  51E8      	MOVF gbl_BDT, W, 1
01A2  6EE9      	MOVWF FSR0L
01A4  51F4      	MOVF gbl_ACTIVE_BUF, W, 1
01A6  0101      	MOVLB 0x01
01A8  6F22      	MOVWF CompTempVar598, 1
01AA  3722      	RLCF CompTempVar598, F, 1
01AC  3722      	RLCF CompTempVar598, F, 1
01AE  0EFC      	MOVLW 0xFC
01B0  1522      	ANDWF CompTempVar598, W, 1
01B2  26E9      	ADDWF FSR0L, F
01B4  50EC      	MOVF PREINC0, W
01B6  0100      	MOVLB 0x00
01B8  6FCA      	MOVWF gbl_BDTCopy+D'1', 1

	BDTCopy.address = BDT[ACTIVE_BUF].address;
01BA  51E8      	MOVF gbl_BDT, W, 1
01BC  6EE9      	MOVWF FSR0L
01BE  51F4      	MOVF gbl_ACTIVE_BUF, W, 1
01C0  0101      	MOVLB 0x01
01C2  6F22      	MOVWF CompTempVar599, 1
01C4  3722      	RLCF CompTempVar599, F, 1
01C6  3722      	RLCF CompTempVar599, F, 1
01C8  0EFC      	MOVLW 0xFC
01CA  1522      	ANDWF CompTempVar599, W, 1
01CC  26E9      	ADDWF FSR0L, F
01CE  0E02      	MOVLW 0x02
01D0  26E9      	ADDWF FSR0L, F
01D2  50EE      	MOVF POSTINC0, W
01D4  0100      	MOVLB 0x00
01D6  6FCB      	MOVWF gbl_BDTCopy+D'2', 1
01D8  50EF      	MOVF INDF0, W
01DA  6FCC      	MOVWF gbl_BDTCopy+D'3', 1

	bTOK_DONE = 0;
01DC  9668      	BCF gbl_bTOK_DONE,3

	if ((BDTCopy.EPStat & 0x3C) == TOKEN_IN) {
01DE  0E3C      	MOVLW 0x3C
01E0  15C9      	ANDWF gbl_BDTCopy, W, 1
01E2  0101      	MOVLB 0x01
01E4  6F1F      	MOVWF CompTempVar587, 1
01E6  0E24      	MOVLW 0x24
01E8  631F      	CPFSEQ CompTempVar587, 1
01EA  D00E      	BRA	label9
0208            label9

        // TOKEN IN
		if (USB_USTAT == 0x04) { 
01EC  0E04      	MOVLW 0x04
01EE  0100      	MOVLB 0x00
01F0  63F3      	CPFSEQ gbl_USB_USTAT, 1
01F2  D006      	BRA	label8
0200            label8

            /* Process EP0 In's */
			if (USB_dev_req == GET_DESCRIPTOR) {
01F4  0E06      	MOVLW 0x06
01F6  63F2      	CPFSEQ gbl_USB_dev_req, 1

				CopyDescriptorToEP0 ();
01FA  EC59F000  	CALL CopyDescri_0000B

			}
		} else if (USB_USTAT == 0x0C) {
0200  0E0C      	MOVLW 0x0C
0202  63F3      	CPFSEQ gbl_USB_USTAT, 1

            /* process EP1 In's */
        } else {
		    /* process EP2 In's */
		}
	} else if ((BDTCopy.EPStat & 0x3C) == TOKEN_OUT) {
0208  0E3C      	MOVLW 0x3C
020A  0100      	MOVLB 0x00
020C  15C9      	ANDWF gbl_BDTCopy, W, 1
020E  0101      	MOVLB 0x01
0210  6F20      	MOVWF CompTempVar588, 1
0212  0E04      	MOVLW 0x04
0214  6320      	CPFSEQ CompTempVar588, 1
0216  D008      	BRA	label10
0228            label10

        //TOKEN OUT
		if (USB_USTAT == 0x00) {
0218  0100      	MOVLB 0x00
021A  53F3      	MOVF gbl_USB_USTAT, F, 1
021C  B4D8      	BTFSC STATUS,Z

		    /* process EP1 Out's */
		} else if (USB_USTAT == 0x08) {
0220  0E08      	MOVLW 0x08
0222  63F3      	CPFSEQ gbl_USB_USTAT, 1

            /* process EP1 Out's */
		} else {
            /* process EP2 Out's */
		}
	} else if ((BDTCopy.EPStat & 0x3C) == TOKEN_SETUP) {
0228  0E3C      	MOVLW 0x3C
022A  0100      	MOVLB 0x00
022C  15C9      	ANDWF gbl_BDTCopy, W, 1
022E  0101      	MOVLB 0x01
0230  6F21      	MOVWF CompTempVar589, 1
0232  0E34      	MOVLW 0x34
0234  6321      	CPFSEQ CompTempVar589, 1

        // TOKEN SETUP
		Buffer = (struct BufferStruct*) ((unsigned int)bd0adrloe + (unsigned int)(bd0adrhoe << 8));
0238  0104      	MOVLB 0x04
023A  5102      	MOVF gbl_bd0adrloe, W, 1
023C  0100      	MOVLB 0x00
023E  6FEA      	MOVWF gbl_Buffer, 1
0240  0101      	MOVLB 0x01
0242  6B25      	CLRF CompTempVar605+D'1', 1
0244  6B26      	CLRF CompTempVar606, 1
0246  0104      	MOVLB 0x04
0248  5103      	MOVF gbl_bd0adrhoe, W, 1
024A  0100      	MOVLB 0x00
024C  6FEB      	MOVWF gbl_Buffer+D'1', 1
024E  0101      	MOVLB 0x01
0250  5126      	MOVF CompTempVar606, W, 1
0252  0100      	MOVLB 0x00
0254  27EA      	ADDWF gbl_Buffer, F, 1
0256  0101      	MOVLB 0x01
0258  5125      	MOVF CompTempVar605+D'1', W, 1
025A  0100      	MOVLB 0x00
025C  23EB      	ADDWFC gbl_Buffer+D'1', F, 1

		BufferCopy.bmRequestType = Buffer->bmRequestType;
025E  51EB      	MOVF gbl_Buffer+D'1', W, 1
0260  6EEA      	MOVWF FSR0H
0262  51EA      	MOVF gbl_Buffer, W, 1
0264  6EE9      	MOVWF FSR0L
0266  50EF      	MOVF INDF0, W
0268  6FC1      	MOVWF gbl_BufferCopy, 1

		BufferCopy.bRequest = Buffer->bRequest;
026A  50EC      	MOVF PREINC0, W
026C  6FC2      	MOVWF gbl_BufferCopy+D'1', 1

		BufferCopy.wValue = Buffer->wValue;
026E  06E9      	DECF FSR0L, F
0270  0E02      	MOVLW 0x02
0272  26E9      	ADDWF FSR0L, F
0274  50EE      	MOVF POSTINC0, W
0276  6FC3      	MOVWF gbl_BufferCopy+D'2', 1
0278  50EF      	MOVF INDF0, W
027A  6FC4      	MOVWF gbl_BufferCopy+D'3', 1

		BufferCopy.wIndex = Buffer->wIndex;
027C  51EA      	MOVF gbl_Buffer, W, 1
027E  6EE9      	MOVWF FSR0L
0280  0E04      	MOVLW 0x04
0282  26E9      	ADDWF FSR0L, F
0284  50EE      	MOVF POSTINC0, W
0286  6FC5      	MOVWF gbl_BufferCopy+D'4', 1
0288  50EF      	MOVF INDF0, W
028A  6FC6      	MOVWF gbl_BufferCopy+D'5', 1

		BufferCopy.wLength = Buffer->wLength;
028C  51EA      	MOVF gbl_Buffer, W, 1
028E  6EE9      	MOVWF FSR0L
0290  0E06      	MOVLW 0x06
0292  26E9      	ADDWF FSR0L, F
0294  50EE      	MOVF POSTINC0, W
0296  6FC7      	MOVWF gbl_BufferCopy+D'6', 1
0298  50EF      	MOVF INDF0, W
029A  6FC8      	MOVWF gbl_BufferCopy+D'7', 1

        bPID_ERR = 0;  // Clear REQUEST ERROR  
029C  906A      	BCF gbl_bPID_ERR,0

		bd0cntoe = 0x08;
029E  0E08      	MOVLW 0x08
02A0  0104      	MOVLB 0x04
02A2  6F01      	MOVWF gbl_bd0cntoe, 1

		if (BufferCopy.bmRequestType == 0x21)
02A4  0E21      	MOVLW 0x21
02A6  0100      	MOVLB 0x00
02A8  63C1      	CPFSEQ gbl_BufferCopy, 1
02AA  D004      	BRA	label11
02B4            label11

			bd0statoe = 0xC8;
02AC  0EC8      	MOVLW 0xC8
02AE  0104      	MOVLB 0x04
02B0  6F00      	MOVWF gbl_bd0statoe, 1

		else
02B2  D003      	BRA	label12
02BA            label12
02EE  D3BC      	BRA	label81
030A  D035      	BRA	label25
03C2  D017      	BRA	label34
0400  D041      	BRA	label40
069E  D074      	BRA	label62
0B5C  D03F      	BRA	label103
0B74  D009      	BRA	label93
0BA4  D011      	BRA	label98

	        bd0statoe = 0x88;/* Turn the buffer around, make it available for the SIE */
02B4  0E88      	MOVLW 0x88
02B6  0104      	MOVLB 0x04
02B8  6F00      	MOVWF gbl_bd0statoe, 1

		bd0statie = 0x08;
02BA  0E08      	MOVLW 0x08
02BC  6F04      	MOVWF gbl_bd0statie, 1

		bPKT_DIS = 0;
02BE  986D      	BCF gbl_bPKT_DIS,4

		USB_dev_req = 0;
02C0  0100      	MOVLB 0x00
02C2  6BF2      	CLRF gbl_USB_dev_req, 1

		switch (BufferCopy.bmRequestType) {
            // First bmRequestType ************************************		
		    case HOSTTODEVICE:
02C4  53C1      	MOVF gbl_BufferCopy, F, 1
02C6  E014      	BZ	label16
02F0            label16

                // 00
			    switch (BufferCopy.bRequest) {
		            case CLEAR_FEATURE:
02F0  05C2      	DECF gbl_BufferCopy+D'1', W, 1
02F2  E00C      	BZ	label19
030C            label19

                        //01
		                /* Remote wakeup is only valid device feature */
				        if (BufferCopy.wValue == 1)	{
030C  0E01      	MOVLW 0x01
030E  63C3      	CPFSEQ gbl_BufferCopy+D'2', 1
0310  D00A      	BRA	label20
0312  51C4      	MOVF gbl_BufferCopy+D'3', W, 1
0314  E108      	BNZ	label20
0326            label20

					        USB_status_device &= 0xFD;
0316  93EF      	BCF gbl_USB_status_device,1, 1

				            Send_0Len_pkt;
0318  0104      	MOVLB 0x04
031A  6B05      	CLRF gbl_bd0cntie, 1
031C  0EC8      	MOVLW 0xC8
031E  6F04      	MOVWF gbl_bd0statie, 1
0320  0100      	MOVLB 0x00
0322  6BF2      	CLRF gbl_USB_dev_req, 1

				        } else {
				            STALL_EP0;
0326  8070      	BSF gbl_uep0,0

                        }
				        break;

			        case SET_FEATURE:
02F4  0E03      	MOVLW 0x03
02F6  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
02F8  D001      	BRA	label17
02FA  D017      	BRA	label21
02FC            label17
032A            label21

                        //03
			            /* Set Device Feature.  Only valid device */
				        if ((BufferCopy.wValue & 0xff) == 1) {
032A  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
032C  0101      	MOVLB 0x01
032E  6F22      	MOVWF CompTempVar600, 1
0330  6B23      	CLRF CompTempVar601, 1
0332  0E01      	MOVLW 0x01
0334  6322      	CPFSEQ CompTempVar600, 1
0336  D00B      	BRA	label22
0338  5123      	MOVF CompTempVar601, W, 1
033A  E109      	BNZ	label22
034E            label22

				            USB_status_device |= 0x02;	/* feature is remote wakeup */
033C  0100      	MOVLB 0x00
033E  83EF      	BSF gbl_USB_status_device,1, 1

					        Send_0Len_pkt;
0340  0104      	MOVLB 0x04
0342  6B05      	CLRF gbl_bd0cntie, 1
0344  0EC8      	MOVLW 0xC8
0346  6F04      	MOVWF gbl_bd0statie, 1
0348  0100      	MOVLB 0x00
034A  6BF2      	CLRF gbl_USB_dev_req, 1

				        } else {
				            STALL_EP0;
034E  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case SET_ADDRESS:
02FC  0E05      	MOVLW 0x05
02FE  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0300  D001      	BRA	label18
0302  D027      	BRA	label23
0304            label18
0352            label23

                        //05
			            USB_address_pending = BufferCopy.wValue;
0352  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0354  6FF1      	MOVWF gbl_USB_address_pending, 1

				        if (USB_address_pending < 0x80) {
0356  0E80      	MOVLW 0x80
0358  61F1      	CPFSLT gbl_USB_address_pending, 1
035A  D00B      	BRA	label24
0372            label24

					        Send_0Len_pkt;
035C  0104      	MOVLB 0x04
035E  6B05      	CLRF gbl_bd0cntie, 1
0360  0EC8      	MOVLW 0xC8
0362  6F04      	MOVWF gbl_bd0statie, 1
0364  0100      	MOVLB 0x00
0366  6BF2      	CLRF gbl_USB_dev_req, 1

					        USB_dev_req = SET_ADDRESS;
0368  0E05      	MOVLW 0x05
036A  6FF2      	MOVWF gbl_USB_dev_req, 1

		                    uie = 00001001b; //enable transaction complete and reset interrupts
036C  0E09      	MOVLW 0x09
036E  6E69      	MOVWF gbl_uie

				        } else {
				            STALL_EP0;
0372  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case SET_CONFIGURATION:
0304  0E09      	MOVLW 0x09
0306  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0308  D051      	BRA	label29
0376            label25

                        //09
				        if (BufferCopy.wValue <= NUM_CONFIGURATIONS)
0376  0E01      	MOVLW 0x01
0378  65C3      	CPFSGT gbl_BufferCopy+D'2', 1
037A  67C4      	TSTFSZ gbl_BufferCopy+D'3', 1
037C  D002      	BRA	label26
0382            label26

					        USB_Curr_Config = BufferCopy.wValue;
037E  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0380  6FF0      	MOVWF gbl_USB_Curr_Config, 1


				        if (BufferCopy.wValue == 0) {
0382  53C3      	MOVF gbl_BufferCopy+D'2', F, 1
0384  E105      	BNZ	label27
0386  53C4      	MOVF gbl_BufferCopy+D'3', F, 1
0388  E103      	BNZ	label27
0390            label27

					        USWSTAT = ADDRESS_STATE;
038A  0E02      	MOVLW 0x02
038C  6FF6      	MOVWF gbl_USWSTAT, 1

					    } else {
038E  D002      	BRA	label28
0394            label28

					        USWSTAT = CONFIG_STATE;
0390  0E03      	MOVLW 0x03
0392  6FF6      	MOVWF gbl_USWSTAT, 1

				        }
				        Send_0Len_pkt;
0394  0104      	MOVLB 0x04
0396  6B05      	CLRF gbl_bd0cntie, 1
0398  0EC8      	MOVLW 0xC8
039A  6F04      	MOVWF gbl_bd0statie, 1
039C  0100      	MOVLB 0x00
039E  6BF2      	CLRF gbl_USB_dev_req, 1

	                    bd1statie = 0x48; //SET MCU AS OWNER OF THIS BUFFER, ENABLE DATA TOGGLE SYNC
03A0  0E48      	MOVLW 0x48
03A2  0104      	MOVLB 0x04
03A4  6F0C      	MOVWF gbl_bd1statie, 1

				        uep1 = ENDPT_NON_CONTROL;
03A6  0E1E      	MOVLW 0x1E
03A8  6E71      	MOVWF gbl_uep1

  	                    break;
			        default:
03AC            label29

			            STALL_EP0;
03AC  8070      	BSF gbl_uep0,0

				        break;
			    }
			    break;
            // Second bmRequestType ************************************	
            case HOSTTOINTERFACE:   
02C8  05C1      	DECF gbl_BufferCopy, W, 1
02CA  B4D8      	BTFSC STATUS,Z
02CC  D071      	BRA	label30
03B0            label30

                //01
                switch (BufferCopy.bRequest) {
                    case SET_INTERFACE:
03B0  0E0B      	MOVLW 0x0B
03B2  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
03B4  D001      	BRA	label31
03B6  D006      	BRA	label32
03B8            label31
03C4            label32

                        //0B
                        if (USWSTAT == CONFIG_STATE) {
03C4  0E03      	MOVLW 0x03
03C6  63F6      	CPFSEQ gbl_USWSTAT, 1
03C8  D012      	BRA	label33
03EE            label33

                            Interface = BufferCopy.wIndex;
03CA  51C5      	MOVF gbl_BufferCopy+D'4', W, 1
03CC  0101      	MOVLB 0x01
03CE  6F1C      	MOVWF Process_Re_0000D_1_Interface, 1

                            USB_Interface[Interface] = BufferCopy.wValue;
03D0  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
03D4  50E9      	MOVF FSR0L, W
03D6  511C      	MOVF Process_Re_0000D_1_Interface, W, 1
03D8  26E9      	ADDWF FSR0L, F
03DA  0100      	MOVLB 0x00
03DC  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
03DE  6EEF      	MOVWF INDF0

                            Send_0Len_pkt;
03E0  0104      	MOVLB 0x04
03E2  6B05      	CLRF gbl_bd0cntie, 1
03E4  0EC8      	MOVLW 0xC8
03E6  6F04      	MOVWF gbl_bd0statie, 1
03E8  0100      	MOVLB 0x00
03EA  6BF2      	CLRF gbl_USB_dev_req, 1

                        } else {
                            STALL_EP0;
03EE  8070      	BSF gbl_uep0,0

                        }
                        break;
                    case CLEAR_FEATURE:
03B8  05C2      	DECF gbl_BufferCopy+D'1', W, 1
03BA  E01B      	BZ	label34
03F2            label34

                        //01
                    case SET_FEATURE:
03BC  0E03      	MOVLW 0x03
03BE  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
03C0  D018      	BRA	label34

                        //03
                        /* Set Interface feature - Not Valid */
                    default:
                        STALL_EP0;
03F2  8070      	BSF gbl_uep0,0

                        break;
                }
                break;
            // Third bmRequestType ************************************				
		    case HOSTTOENDPOINT:
02CE  0E02      	MOVLW 0x02
02D0  63C1      	CPFSEQ gbl_BufferCopy, 1
02D2  D001      	BRA	label13
02D4  D090      	BRA	label35
02D6            label13
03F6            label35

			    switch (BufferCopy.bRequest) {
			        case CLEAR_FEATURE:
03F6  05C2      	DECF gbl_BufferCopy+D'1', W, 1
03F8  E004      	BZ	label36
0402            label36

                        //01
				        UEPArray = (unsigned char *) &uep0;
0402  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0404  0101      	MOVLB 0x01
0406  6F19      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1
0408  0E70      	MOVLW LOW(gbl_uep0+D'0')
040A  6F18      	MOVWF Process_Re_0000D_1_UEPArray, 1

				        Endpoint = BufferCopy.wIndex & 0x0F;
040C  0E0F      	MOVLW 0x0F
040E  0100      	MOVLB 0x00
0410  15C5      	ANDWF gbl_BufferCopy+D'4', W, 1
0412  0101      	MOVLB 0x01
0414  6F1B      	MOVWF Process_Re_0000D_1_Endpoint, 1

	                    if (BufferCopy.wValue == 0) {
0416  0100      	MOVLB 0x00
0418  53C3      	MOVF gbl_BufferCopy+D'2', F, 1
041A  E132      	BNZ	label39
041C  53C4      	MOVF gbl_BufferCopy+D'3', F, 1
041E  E130      	BNZ	label39
0480            label39

	                        /* Only valid feature is 0 (Remote Wakeup) */
				            if (((USWSTAT & 0x03) == ADDRESS_STATE) && (Endpoint == 0)) {
0420  0E03      	MOVLW 0x03
0422  15F6      	ANDWF gbl_USWSTAT, W, 1
0424  0101      	MOVLB 0x01
0426  6F24      	MOVWF CompTempVar610, 1
0428  0E02      	MOVLW 0x02
042A  6324      	CPFSEQ CompTempVar610, 1
042C  D00F      	BRA	label37
042E  531B      	MOVF Process_Re_0000D_1_Endpoint, F, 1
0430  E10D      	BNZ	label37
044C            label37

						        UEPArray [Endpoint] &= 0xFE;
0432  5119      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0434  6EEA      	MOVWF FSR0H
0436  5118      	MOVF Process_Re_0000D_1_UEPArray, W, 1
0438  251B      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
043A  6EE9      	MOVWF FSR0L
043C  90EF      	BCF INDF0,0

						        Send_0Len_pkt;
043E  0104      	MOVLB 0x04
0440  6B05      	CLRF gbl_bd0cntie, 1
0442  0EC8      	MOVLW 0xC8
0444  6F04      	MOVWF gbl_bd0statie, 1
0446  0100      	MOVLB 0x00
0448  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else if (((USWSTAT& 0x03) == CONFIG_STATE) && (Endpoint < 3)) {
044C  0E03      	MOVLW 0x03
044E  0100      	MOVLB 0x00
0450  15F6      	ANDWF gbl_USWSTAT, W, 1
0452  0101      	MOVLB 0x01
0454  6F24      	MOVWF CompTempVar612, 1
0456  0E03      	MOVLW 0x03
0458  6324      	CPFSEQ CompTempVar612, 1
045A  D010      	BRA	label38
045C  0E03      	MOVLW 0x03
045E  611B      	CPFSLT Process_Re_0000D_1_Endpoint, 1
0460  D00D      	BRA	label38
047C            label38

						        UEPArray [Endpoint] &= 0xFE;
0462  5119      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0464  6EEA      	MOVWF FSR0H
0466  5118      	MOVF Process_Re_0000D_1_UEPArray, W, 1
0468  251B      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
046A  6EE9      	MOVWF FSR0L
046C  90EF      	BCF INDF0,0

						        Send_0Len_pkt;
046E  0104      	MOVLB 0x04
0470  6B05      	CLRF gbl_bd0cntie, 1
0472  0EC8      	MOVLW 0xC8
0474  6F04      	MOVWF gbl_bd0statie, 1
0476  0100      	MOVLB 0x00
0478  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else {
					            STALL_EP0;
047C  8070      	BSF gbl_uep0,0

                            }
				        } else {
					        STALL_EP0;
0480  8070      	BSF gbl_uep0,0

                        }
				        break;

			        case SET_FEATURE:
03FA  0E03      	MOVLW 0x03
03FC  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
03FE  D085      	BRA	label44
0484            label40

                        //03
				        UEPArray = (unsigned char *) &uep0;
0484  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0486  0101      	MOVLB 0x01
0488  6F24      	MOVWF CompTempVar614, 1
048A  0E70      	MOVLW LOW(gbl_uep0+D'0')
048C  6F18      	MOVWF Process_Re_0000D_1_UEPArray, 1
048E  5124      	MOVF CompTempVar614, W, 1
0490  6F19      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1

				        Endpoint = BufferCopy.wIndex & 0x0F;
0492  0E0F      	MOVLW 0x0F
0494  0100      	MOVLB 0x00
0496  15C5      	ANDWF gbl_BufferCopy+D'4', W, 1
0498  0101      	MOVLB 0x01
049A  6F1B      	MOVWF Process_Re_0000D_1_Endpoint, 1

	                    if (BufferCopy.wValue == 0) {
049C  0100      	MOVLB 0x00
049E  53C3      	MOVF gbl_BufferCopy+D'2', F, 1
04A0  E132      	BNZ	label43
04A2  53C4      	MOVF gbl_BufferCopy+D'3', F, 1
04A4  E130      	BNZ	label43
0506            label43

                            /* Only valid feature is 0 (Remote Wakeup) */
				            if (((USWSTAT& 0x03) == ADDRESS_STATE) && (Endpoint == 0)) {
04A6  0E03      	MOVLW 0x03
04A8  15F6      	ANDWF gbl_USWSTAT, W, 1
04AA  0101      	MOVLB 0x01
04AC  6F24      	MOVWF CompTempVar615, 1
04AE  0E02      	MOVLW 0x02
04B0  6324      	CPFSEQ CompTempVar615, 1
04B2  D00F      	BRA	label41
04B4  531B      	MOVF Process_Re_0000D_1_Endpoint, F, 1
04B6  E10D      	BNZ	label41
04D2            label41

						        UEPArray [Endpoint] |= 1;
04B8  5119      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
04BA  6EEA      	MOVWF FSR0H
04BC  5118      	MOVF Process_Re_0000D_1_UEPArray, W, 1
04BE  251B      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
04C0  6EE9      	MOVWF FSR0L
04C2  80EF      	BSF INDF0,0

						        Send_0Len_pkt;
04C4  0104      	MOVLB 0x04
04C6  6B05      	CLRF gbl_bd0cntie, 1
04C8  0EC8      	MOVLW 0xC8
04CA  6F04      	MOVWF gbl_bd0statie, 1
04CC  0100      	MOVLB 0x00
04CE  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else if (((USWSTAT& 0x03) == CONFIG_STATE) && (Endpoint < 3)) {
04D2  0E03      	MOVLW 0x03
04D4  0100      	MOVLB 0x00
04D6  15F6      	ANDWF gbl_USWSTAT, W, 1
04D8  0101      	MOVLB 0x01
04DA  6F24      	MOVWF CompTempVar617, 1
04DC  0E03      	MOVLW 0x03
04DE  6324      	CPFSEQ CompTempVar617, 1
04E0  D010      	BRA	label42
04E2  0E03      	MOVLW 0x03
04E4  611B      	CPFSLT Process_Re_0000D_1_Endpoint, 1
04E6  D00D      	BRA	label42
0502            label42

						        UEPArray [Endpoint] |= 1;
04E8  5119      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
04EA  6EEA      	MOVWF FSR0H
04EC  5118      	MOVF Process_Re_0000D_1_UEPArray, W, 1
04EE  251B      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
04F0  6EE9      	MOVWF FSR0L
04F2  80EF      	BSF INDF0,0

						        Send_0Len_pkt;
04F4  0104      	MOVLB 0x04
04F6  6B05      	CLRF gbl_bd0cntie, 1
04F8  0EC8      	MOVLW 0xC8
04FA  6F04      	MOVWF gbl_bd0statie, 1
04FC  0100      	MOVLB 0x00
04FE  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else {
					            STALL_EP0;
0502  8070      	BSF gbl_uep0,0

                            }
				        } else {
				  	        STALL_EP0;
0506  8070      	BSF gbl_uep0,0

                        }
				        break;
			        default:
050A            label44

                        STALL_EP0;
050A  8070      	BSF gbl_uep0,0

			    }
			    break;

            // Fourth bmRequestType ************************************	
		    case DEVICETOHOST:  
02D6  0E80      	MOVLW 0x80
02D8  63C1      	CPFSEQ gbl_BufferCopy, 1
02DA  D001      	BRA	label14
02DC  D118      	BRA	label45
02DE            label14
050E            label45

                //80
			    switch (BufferCopy.bRequest) {
			        case GET_CONFIGURATION:
050E  0E08      	MOVLW 0x08
0510  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0512  D001      	BRA	label46
0514  D008      	BRA	label48
0516            label46
0526            label48

                        OutBuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));
0526  0104      	MOVLB 0x04
0528  5106      	MOVF gbl_bd0adrlie, W, 1
052A  0100      	MOVLB 0x00
052C  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
052E  0101      	MOVLB 0x01
0530  6B25      	CLRF CompTempVar621+D'1', 1
0532  6B26      	CLRF CompTempVar622, 1
0534  0104      	MOVLB 0x04
0536  5107      	MOVF gbl_bd0adrhie, W, 1
0538  0100      	MOVLB 0x00
053A  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1
053C  0101      	MOVLB 0x01
053E  5126      	MOVF CompTempVar622, W, 1
0540  0100      	MOVLB 0x00
0542  27FE      	ADDWF Process_Re_0000D_1_OutBuffer, F, 1
0544  0101      	MOVLB 0x01
0546  5125      	MOVF CompTempVar621+D'1', W, 1
0548  0100      	MOVLB 0x00
054A  23FF      	ADDWFC Process_Re_0000D_1_OutBuffer+D'1', F, 1

			            OutBuffer [0] = USB_Curr_Config;
054C  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
054E  6EEA      	MOVWF FSR0H
0550  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0552  6EE9      	MOVWF FSR0L
0554  0101      	MOVLB 0x01
0556  6B24      	CLRF CompTempVar625, 1
0558  5124      	MOVF CompTempVar625, W, 1
055A  26E9      	ADDWF FSR0L, F
055C  0100      	MOVLB 0x00
055E  51F0      	MOVF gbl_USB_Curr_Config, W, 1
0560  6EEF      	MOVWF INDF0

				        bd0cntie = 1;
0562  0E01      	MOVLW 0x01
0564  0104      	MOVLB 0x04
0566  6F05      	MOVWF gbl_bd0cntie, 1

				        bd0statie = 0xc8;
0568  0EC8      	MOVLW 0xC8
056A  6F04      	MOVWF gbl_bd0statie, 1

				        break;
			        case GET_DESCRIPTOR:
0516  0E06      	MOVLW 0x06
0518  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
051A  D001      	BRA	label47
051C  D028      	BRA	label49
051E            label47
056E            label49

				        DescriptorID = (unsigned char) (BufferCopy.wValue >> 8);
056E  51C4      	MOVF gbl_BufferCopy+D'3', W, 1
0570  0101      	MOVLB 0x01
0572  6F1D      	MOVWF Process_Re_0000D_1_DescriptorID, 1

				        if (DescriptorID == DEVICE) {
0574  051D      	DECF Process_Re_0000D_1_DescriptorID, W, 1
0576  E13E      	BNZ	label52
05F4            label52

							USB_dev_req = GET_DESCRIPTOR;
0578  0E06      	MOVLW 0x06
057A  0100      	MOVLB 0x00
057C  6FF2      	MOVWF gbl_USB_dev_req, 1

					        EP0_start = DeviceDescriptor;
057E  0E00      	MOVLW HIGH(gbl_DeviceDescriptor+D'0')
0580  6FE5      	MOVWF gbl_EP0_start+D'1', 1
0582  0EA6      	MOVLW LOW(gbl_DeviceDescriptor+D'0')
0584  6FE4      	MOVWF gbl_EP0_start, 1

				            EP0_end = DeviceDescriptor + sizeof(DeviceDescriptor);
0586  0E00      	MOVLW HIGH(gbl_DeviceDescriptor+D'0')
0588  0101      	MOVLB 0x01
058A  6F26      	MOVWF CompTempVar631, 1
058C  0EA6      	MOVLW LOW(gbl_DeviceDescriptor+D'0')
058E  0100      	MOVLB 0x00
0590  6FE6      	MOVWF gbl_EP0_end, 1
0592  6BE7      	CLRF gbl_EP0_end+D'1', 1
0594  0E12      	MOVLW 0x12
0596  27E6      	ADDWF gbl_EP0_end, F, 1
0598  0101      	MOVLB 0x01
059A  5126      	MOVF CompTempVar631, W, 1
059C  0100      	MOVLB 0x00
059E  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                            if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
05A0  51E4      	MOVF gbl_EP0_start, W, 1
05A2  5DE6      	SUBWF gbl_EP0_end, W, 1
05A4  0101      	MOVLB 0x01
05A6  6F24      	MOVWF CompTempVar627, 1
05A8  0100      	MOVLB 0x00
05AA  51E5      	MOVF gbl_EP0_start+D'1', W, 1
05AC  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
05AE  0101      	MOVLB 0x01
05B0  6F25      	MOVWF CompTempVar628, 1
05B2  5125      	MOVF CompTempVar628, W, 1
05B4  0100      	MOVLB 0x00
05B6  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
05B8  E104      	BNZ	label50
05BA  0101      	MOVLB 0x01
05BC  5124      	MOVF CompTempVar627, W, 1
05BE  0100      	MOVLB 0x00
05C0  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
05C2            label50
05C2  E213      	BC	label51
05EA            label51

						        EP0_end = EP0_start + BufferCopy.wLength;
05C4  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
05C6  25E4      	ADDWF gbl_EP0_start, W, 1
05C8  0101      	MOVLB 0x01
05CA  6F26      	MOVWF CompTempVar634, 1
05CC  0100      	MOVLB 0x00
05CE  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
05D0  0101      	MOVLB 0x01
05D2  6F27      	MOVWF CompTempVar635, 1
05D4  0100      	MOVLB 0x00
05D6  51E5      	MOVF gbl_EP0_start+D'1', W, 1
05D8  0101      	MOVLB 0x01
05DA  2327      	ADDWFC CompTempVar635, F, 1
05DC  5126      	MOVF CompTempVar634, W, 1
05DE  0100      	MOVLB 0x00
05E0  6FE6      	MOVWF gbl_EP0_end, 1
05E2  0101      	MOVLB 0x01
05E4  5127      	MOVF CompTempVar635, W, 1
05E6  0100      	MOVLB 0x00
05E8  6FE7      	MOVWF gbl_EP0_end+D'1', 1

					        EP0_maxLength = 8;
05EA  0E08      	MOVLW 0x08
05EC  6FF7      	MOVWF gbl_EP0_maxLength, 1

					        CopyDescriptorToEP0();
05EE  EC59F000  	CALL CopyDescri_0000B

				        } else if (DescriptorID == CONFIGURATION) {
05F4  0E02      	MOVLW 0x02
05F6  631D      	CPFSEQ Process_Re_0000D_1_DescriptorID, 1
05F8  D03E      	BRA	label55
0676            label55

					        USB_dev_req = GET_DESCRIPTOR;
05FA  0E06      	MOVLW 0x06
05FC  0100      	MOVLB 0x00
05FE  6FF2      	MOVWF gbl_USB_dev_req, 1

					        EP0_start = ConfigDescriptor;
0600  0E00      	MOVLW HIGH(gbl_ConfigDescriptor+D'0')
0602  6FE5      	MOVWF gbl_EP0_start+D'1', 1
0604  0E3D      	MOVLW LOW(gbl_ConfigDescriptor+D'0')
0606  6FE4      	MOVWF gbl_EP0_start, 1

				            EP0_end = ConfigDescriptor + sizeof(ConfigDescriptor);
0608  0E00      	MOVLW HIGH(gbl_ConfigDescriptor+D'0')
060A  0101      	MOVLB 0x01
060C  6F26      	MOVWF CompTempVar640, 1
060E  0E3D      	MOVLW LOW(gbl_ConfigDescriptor+D'0')
0610  0100      	MOVLB 0x00
0612  6FE6      	MOVWF gbl_EP0_end, 1
0614  6BE7      	CLRF gbl_EP0_end+D'1', 1
0616  0E22      	MOVLW 0x22
0618  27E6      	ADDWF gbl_EP0_end, F, 1
061A  0101      	MOVLB 0x01
061C  5126      	MOVF CompTempVar640, W, 1
061E  0100      	MOVLB 0x00
0620  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                            if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
0622  51E4      	MOVF gbl_EP0_start, W, 1
0624  5DE6      	SUBWF gbl_EP0_end, W, 1
0626  0101      	MOVLB 0x01
0628  6F24      	MOVWF CompTempVar636, 1
062A  0100      	MOVLB 0x00
062C  51E5      	MOVF gbl_EP0_start+D'1', W, 1
062E  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
0630  0101      	MOVLB 0x01
0632  6F25      	MOVWF CompTempVar637, 1
0634  5125      	MOVF CompTempVar637, W, 1
0636  0100      	MOVLB 0x00
0638  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
063A  E104      	BNZ	label53
063C  0101      	MOVLB 0x01
063E  5124      	MOVF CompTempVar636, W, 1
0640  0100      	MOVLB 0x00
0642  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
0644            label53
0644  E213      	BC	label54
066C            label54

						        EP0_end = EP0_start + BufferCopy.wLength;
0646  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
0648  25E4      	ADDWF gbl_EP0_start, W, 1
064A  0101      	MOVLB 0x01
064C  6F26      	MOVWF CompTempVar643, 1
064E  0100      	MOVLB 0x00
0650  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
0652  0101      	MOVLB 0x01
0654  6F27      	MOVWF CompTempVar644, 1
0656  0100      	MOVLB 0x00
0658  51E5      	MOVF gbl_EP0_start+D'1', W, 1
065A  0101      	MOVLB 0x01
065C  2327      	ADDWFC CompTempVar644, F, 1
065E  5126      	MOVF CompTempVar643, W, 1
0660  0100      	MOVLB 0x00
0662  6FE6      	MOVWF gbl_EP0_end, 1
0664  0101      	MOVLB 0x01
0666  5127      	MOVF CompTempVar644, W, 1
0668  0100      	MOVLB 0x00
066A  6FE7      	MOVWF gbl_EP0_end+D'1', 1

					        EP0_maxLength = 8;
066C  0E08      	MOVLW 0x08
066E  6FF7      	MOVWF gbl_EP0_maxLength, 1

					        CopyDescriptorToEP0();
0670  EC59F000  	CALL CopyDescri_0000B

				        } else if (DescriptorID == STRING) {
0676  0E03      	MOVLW 0x03
0678  631D      	CPFSEQ Process_Re_0000D_1_DescriptorID, 1
067A  D0C4      	BRA	label66
0804            label66

					        StringID = (unsigned char) BufferCopy.wValue;
067C  0100      	MOVLB 0x00
067E  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0680  0101      	MOVLB 0x01
0682  6F1E      	MOVWF Process_Re_0000D_1_StringID, 1

					        USB_dev_req = GET_DESCRIPTOR;
0684  0E06      	MOVLW 0x06
0686  0100      	MOVLB 0x00
0688  6FF2      	MOVWF gbl_USB_dev_req, 1

					        EP0_maxLength = 8;
068A  0E08      	MOVLW 0x08
068C  6FF7      	MOVWF gbl_EP0_maxLength, 1

					        switch (StringID) {
					            case 0:
068E  0101      	MOVLB 0x01
0690  531E      	MOVF Process_Re_0000D_1_StringID, F, 1
0692  E006      	BZ	label56
06A0            label56

						            EP0_start = String0;  // String0 is start of string0
06A0  0E00      	MOVLW HIGH(gbl_String0+D'0')
06A2  0100      	MOVLB 0x00
06A4  6FE5      	MOVWF gbl_EP0_start+D'1', 1
06A6  0ECD      	MOVLW LOW(gbl_String0+D'0')
06A8  6FE4      	MOVWF gbl_EP0_start, 1

						            EP0_end = String0 + String0[0]; // String[0] is length of String0
06AA  0E00      	MOVLW HIGH(gbl_String0+D'0')
06AC  0101      	MOVLB 0x01
06AE  6F2A      	MOVWF CompTempVar654, 1
06B0  0ECD      	MOVLW LOW(gbl_String0+D'0')
06B2  0100      	MOVLB 0x00
06B4  6FE6      	MOVWF gbl_EP0_end, 1
06B6  6BE7      	CLRF gbl_EP0_end+D'1', 1
06B8  51CD      	MOVF gbl_String0, W, 1
06BA  27E6      	ADDWF gbl_EP0_end, F, 1
06BC  0101      	MOVLB 0x01
06BE  512A      	MOVF CompTempVar654, W, 1
06C0  0100      	MOVLB 0x00
06C2  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
06C4  51E4      	MOVF gbl_EP0_start, W, 1
06C6  5DE6      	SUBWF gbl_EP0_end, W, 1
06C8  0101      	MOVLB 0x01
06CA  6F24      	MOVWF CompTempVar645, 1
06CC  0100      	MOVLB 0x00
06CE  51E5      	MOVF gbl_EP0_start+D'1', W, 1
06D0  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
06D2  0101      	MOVLB 0x01
06D4  6F25      	MOVWF CompTempVar646, 1
06D6  5125      	MOVF CompTempVar646, W, 1
06D8  0100      	MOVLB 0x00
06DA  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
06DC  E104      	BNZ	label57
06DE  0101      	MOVLB 0x01
06E0  5124      	MOVF CompTempVar645, W, 1
06E2  0100      	MOVLB 0x00
06E4  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
06E6            label57
06E6  E213      	BC	label58
070E            label58

							            EP0_end = EP0_start + BufferCopy.wLength;
06E8  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
06EA  25E4      	ADDWF gbl_EP0_start, W, 1
06EC  0101      	MOVLB 0x01
06EE  6F2A      	MOVWF CompTempVar657, 1
06F0  0100      	MOVLB 0x00
06F2  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
06F4  0101      	MOVLB 0x01
06F6  6F2B      	MOVWF CompTempVar658, 1
06F8  0100      	MOVLB 0x00
06FA  51E5      	MOVF gbl_EP0_start+D'1', W, 1
06FC  0101      	MOVLB 0x01
06FE  232B      	ADDWFC CompTempVar658, F, 1
0700  512A      	MOVF CompTempVar657, W, 1
0702  0100      	MOVLB 0x00
0704  6FE6      	MOVWF gbl_EP0_end, 1
0706  0101      	MOVLB 0x01
0708  512B      	MOVF CompTempVar658, W, 1
070A  0100      	MOVLB 0x00
070C  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0(); // this copies the whole string in 8 byte pieces
070E  EC59F000  	CALL CopyDescri_0000B

						            break;
					            case 1:
0694  051E      	DECF Process_Re_0000D_1_StringID, W, 1
0696  E03E      	BZ	label59
0714            label59

						            EP0_start = String1;
0714  0E00      	MOVLW HIGH(gbl_String1+D'0')
0716  0100      	MOVLB 0x00
0718  6FE5      	MOVWF gbl_EP0_start+D'1', 1
071A  0E92      	MOVLW LOW(gbl_String1+D'0')
071C  6FE4      	MOVWF gbl_EP0_start, 1

						            EP0_end = String1 + String1[0];
071E  0E00      	MOVLW HIGH(gbl_String1+D'0')
0720  0101      	MOVLB 0x01
0722  6F2A      	MOVWF CompTempVar662, 1
0724  0E92      	MOVLW LOW(gbl_String1+D'0')
0726  0100      	MOVLB 0x00
0728  6FE6      	MOVWF gbl_EP0_end, 1
072A  6BE7      	CLRF gbl_EP0_end+D'1', 1
072C  5192      	MOVF gbl_String1, W, 1
072E  27E6      	ADDWF gbl_EP0_end, F, 1
0730  0101      	MOVLB 0x01
0732  512A      	MOVF CompTempVar662, W, 1
0734  0100      	MOVLB 0x00
0736  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
0738  51E4      	MOVF gbl_EP0_start, W, 1
073A  5DE6      	SUBWF gbl_EP0_end, W, 1
073C  0101      	MOVLB 0x01
073E  6F26      	MOVWF CompTempVar647, 1
0740  0100      	MOVLB 0x00
0742  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0744  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
0746  0101      	MOVLB 0x01
0748  6F27      	MOVWF CompTempVar648, 1
074A  5127      	MOVF CompTempVar648, W, 1
074C  0100      	MOVLB 0x00
074E  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
0750  E104      	BNZ	label60
0752  0101      	MOVLB 0x01
0754  5126      	MOVF CompTempVar647, W, 1
0756  0100      	MOVLB 0x00
0758  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
075A            label60
075A  E213      	BC	label61
0782            label61

							            EP0_end = EP0_start + BufferCopy.wLength;
075C  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
075E  25E4      	ADDWF gbl_EP0_start, W, 1
0760  0101      	MOVLB 0x01
0762  6F2A      	MOVWF CompTempVar665, 1
0764  0100      	MOVLB 0x00
0766  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
0768  0101      	MOVLB 0x01
076A  6F2B      	MOVWF CompTempVar666, 1
076C  0100      	MOVLB 0x00
076E  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0770  0101      	MOVLB 0x01
0772  232B      	ADDWFC CompTempVar666, F, 1
0774  512A      	MOVF CompTempVar665, W, 1
0776  0100      	MOVLB 0x00
0778  6FE6      	MOVWF gbl_EP0_end, 1
077A  0101      	MOVLB 0x01
077C  512B      	MOVF CompTempVar666, W, 1
077E  0100      	MOVLB 0x00
0780  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0 ();
0782  EC59F000  	CALL CopyDescri_0000B

						            break;
					            case 2:
0698  0E02      	MOVLW 0x02
069A  631E      	CPFSEQ Process_Re_0000D_1_StringID, 1
069C  D0AF      	BRA	label65
0788            label62

						            EP0_start = String2;
0788  0E00      	MOVLW HIGH(gbl_String2+D'0')
078A  0100      	MOVLB 0x00
078C  6FE5      	MOVWF gbl_EP0_start+D'1', 1
078E  0E05      	MOVLW LOW(gbl_String2+D'0')
0790  6FE4      	MOVWF gbl_EP0_start, 1

						            EP0_end = String2 + String2[0];
0792  0E00      	MOVLW HIGH(gbl_String2+D'0')
0794  0101      	MOVLB 0x01
0796  6F2A      	MOVWF CompTempVar670, 1
0798  0E05      	MOVLW LOW(gbl_String2+D'0')
079A  0100      	MOVLB 0x00
079C  6FE6      	MOVWF gbl_EP0_end, 1
079E  6BE7      	CLRF gbl_EP0_end+D'1', 1
07A0  5005      	MOVF gbl_String2, W
07A2  27E6      	ADDWF gbl_EP0_end, F, 1
07A4  0101      	MOVLB 0x01
07A6  512A      	MOVF CompTempVar670, W, 1
07A8  0100      	MOVLB 0x00
07AA  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
07AC  51E4      	MOVF gbl_EP0_start, W, 1
07AE  5DE6      	SUBWF gbl_EP0_end, W, 1
07B0  0101      	MOVLB 0x01
07B2  6F28      	MOVWF CompTempVar649, 1
07B4  0100      	MOVLB 0x00
07B6  51E5      	MOVF gbl_EP0_start+D'1', W, 1
07B8  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
07BA  0101      	MOVLB 0x01
07BC  6F29      	MOVWF CompTempVar650, 1
07BE  5129      	MOVF CompTempVar650, W, 1
07C0  0100      	MOVLB 0x00
07C2  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
07C4  E104      	BNZ	label63
07C6  0101      	MOVLB 0x01
07C8  5128      	MOVF CompTempVar649, W, 1
07CA  0100      	MOVLB 0x00
07CC  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
07CE            label63
07CE  E213      	BC	label64
07F6            label64

							            EP0_end = EP0_start + BufferCopy.wLength;
07D0  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
07D2  25E4      	ADDWF gbl_EP0_start, W, 1
07D4  0101      	MOVLB 0x01
07D6  6F2A      	MOVWF CompTempVar673, 1
07D8  0100      	MOVLB 0x00
07DA  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
07DC  0101      	MOVLB 0x01
07DE  6F2B      	MOVWF CompTempVar674, 1
07E0  0100      	MOVLB 0x00
07E2  51E5      	MOVF gbl_EP0_start+D'1', W, 1
07E4  0101      	MOVLB 0x01
07E6  232B      	ADDWFC CompTempVar674, F, 1
07E8  512A      	MOVF CompTempVar673, W, 1
07EA  0100      	MOVLB 0x00
07EC  6FE6      	MOVWF gbl_EP0_end, 1
07EE  0101      	MOVLB 0x01
07F0  512B      	MOVF CompTempVar674, W, 1
07F2  0100      	MOVLB 0x00
07F4  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0();
07F6  EC59F000  	CALL CopyDescri_0000B

						            break;
                                // Additional string processing can be added here						
						        default:
07FC            label65

                                    /* REQUEST ERROR */
						            STALL_PID_EP0IN;
07FC  0ECC      	MOVLW 0xCC
07FE  0104      	MOVLB 0x04
0800  6F04      	MOVWF gbl_bd0statie, 1

					        }
				        } else  {
					        /* REQUEST ERROR */
                            STALL_PID_EP0IN;
0804  0ECC      	MOVLW 0xCC
0806  0104      	MOVLB 0x04
0808  6F04      	MOVWF gbl_bd0statie, 1

                        }
				        break;
			        case GET_STATUS:
051E  53C2      	MOVF gbl_BufferCopy+D'1', F, 1
0520  B4D8      	BTFSC STATUS,Z
0522  D174      	BRA	label67
080C            label67

				        OutBuffer = (unsigned char *)BDT[EP0IN].address;
080C  51E9      	MOVF gbl_BDT+D'1', W, 1
080E  6EEA      	MOVWF FSR0H
0810  51E8      	MOVF gbl_BDT, W, 1
0812  6EE9      	MOVWF FSR0L
0814  0E04      	MOVLW 0x04
0816  26E9      	ADDWF FSR0L, F
0818  0E02      	MOVLW 0x02
081A  26E9      	ADDWF FSR0L, F
081C  50EE      	MOVF POSTINC0, W
081E  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0820  50EF      	MOVF INDF0, W
0822  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				        OutBuffer[0] = USB_status_device;
0824  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0826  6EEA      	MOVWF FSR0H
0828  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
082A  6EE9      	MOVWF FSR0L
082C  0101      	MOVLB 0x01
082E  6B24      	CLRF CompTempVar677, 1
0830  5124      	MOVF CompTempVar677, W, 1
0832  26E9      	ADDWF FSR0L, F
0834  0100      	MOVLB 0x00
0836  51EF      	MOVF gbl_USB_status_device, W, 1
0838  6EEF      	MOVWF INDF0

				        OutBuffer[1] = 0;
083A  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
083C  6EE9      	MOVWF FSR0L
083E  0E01      	MOVLW 0x01
0840  26E9      	ADDWF FSR0L, F
0842  0E00      	MOVLW 0x00
0844  6EEF      	MOVWF INDF0

				        bd0cntie = 2;
0846  0E02      	MOVLW 0x02
0848  0104      	MOVLB 0x04
084A  6F05      	MOVWF gbl_bd0cntie, 1

				        bd0statie = 0xc8;
084C  0EC8      	MOVLW 0xC8
084E  6F04      	MOVWF gbl_bd0statie, 1

				        break;
			        default:
				        break;
			    }
			    break;
            // Fifth bmRequestType ************************************	
		    case INTERFACETOHOST:
02DE  0E81      	MOVLW 0x81
02E0  63C1      	CPFSEQ gbl_BufferCopy, 1
02E2  D001      	BRA	label15
02E4  D2B6      	BRA	label68
02E6            label15
0852            label68

			    switch (BufferCopy.bRequest) {
			        case GET_INTERFACE:
0852  0E0A      	MOVLW 0x0A
0854  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0856  D001      	BRA	label69
0858  D006      	BRA	label70
085A            label69
0866            label70

				        Interface = BufferCopy.wIndex;
0866  51C5      	MOVF gbl_BufferCopy+D'4', W, 1
0868  0101      	MOVLB 0x01
086A  6F1C      	MOVWF Process_Re_0000D_1_Interface, 1

				        if ((USWSTAT== CONFIG_STATE) && (Interface < NUM_INTERFACES)) {
086C  0E03      	MOVLW 0x03
086E  0100      	MOVLB 0x00
0870  63F6      	CPFSEQ gbl_USWSTAT, 1
0872  D02C      	BRA	label71
0874  0E01      	MOVLW 0x01
0876  0101      	MOVLB 0x01
0878  611C      	CPFSLT Process_Re_0000D_1_Interface, 1
087A  D028      	BRA	label71
08CC            label71

					        OutBuffer = (unsigned char *) BDT [EP0IN].address;
087C  0100      	MOVLB 0x00
087E  51E9      	MOVF gbl_BDT+D'1', W, 1
0880  6EEA      	MOVWF FSR0H
0882  51E8      	MOVF gbl_BDT, W, 1
0884  6EE9      	MOVWF FSR0L
0886  0E04      	MOVLW 0x04
0888  26E9      	ADDWF FSR0L, F
088A  0E02      	MOVLW 0x02
088C  26E9      	ADDWF FSR0L, F
088E  50EE      	MOVF POSTINC0, W
0890  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0892  50EF      	MOVF INDF0, W
0894  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

					        OutBuffer[0] = USB_Interface[Interface];
0896  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
089A  50E9      	MOVF FSR0L, W
089C  0101      	MOVLB 0x01
089E  511C      	MOVF Process_Re_0000D_1_Interface, W, 1
08A0  6F25      	MOVWF CompTempVar683, 1
08A2  5125      	MOVF CompTempVar683, W, 1
08A4  26E9      	ADDWF FSR0L, F
08A6  50EF      	MOVF INDF0, W
08A8  6F26      	MOVWF CompTempVar684, 1
08AA  0100      	MOVLB 0x00
08AC  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
08AE  6EEA      	MOVWF FSR0H
08B0  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
08B2  6EE9      	MOVWF FSR0L
08B4  0101      	MOVLB 0x01
08B6  6B24      	CLRF CompTempVar681, 1
08B8  5124      	MOVF CompTempVar681, W, 1
08BA  26E9      	ADDWF FSR0L, F
08BC  5126      	MOVF CompTempVar684, W, 1
08BE  6EEF      	MOVWF INDF0

					        bd0cntie = 1;
08C0  0E01      	MOVLW 0x01
08C2  0104      	MOVLB 0x04
08C4  6F05      	MOVWF gbl_bd0cntie, 1

					        bd0statie = 0xc8;
08C6  0EC8      	MOVLW 0xC8
08C8  6F04      	MOVWF gbl_bd0statie, 1

				        } else {
					        STALL_EP0;
08CC  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case GET_STATUS:
085A  53C2      	MOVF gbl_BufferCopy+D'1', F, 1
085C  E039      	BZ	label72
08D0            label72

				        OutBuffer = (unsigned char *) BDT [EP0IN].address;
08D0  51E9      	MOVF gbl_BDT+D'1', W, 1
08D2  6EEA      	MOVWF FSR0H
08D4  51E8      	MOVF gbl_BDT, W, 1
08D6  6EE9      	MOVWF FSR0L
08D8  0E04      	MOVLW 0x04
08DA  26E9      	ADDWF FSR0L, F
08DC  0E02      	MOVLW 0x02
08DE  26E9      	ADDWF FSR0L, F
08E0  50EE      	MOVF POSTINC0, W
08E2  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
08E4  50EF      	MOVF INDF0, W
08E6  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				        OutBuffer[1] = 0;
08E8  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
08EA  6EEA      	MOVWF FSR0H
08EC  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
08EE  6EE9      	MOVWF FSR0L
08F0  0E01      	MOVLW 0x01
08F2  26E9      	ADDWF FSR0L, F
08F4  0E00      	MOVLW 0x00
08F6  6EEF      	MOVWF INDF0

				        bd0cntie = 2;
08F8  0E02      	MOVLW 0x02
08FA  0104      	MOVLB 0x04
08FC  6F05      	MOVWF gbl_bd0cntie, 1

				        Interface = BufferCopy.wIndex;
08FE  0100      	MOVLB 0x00
0900  51C5      	MOVF gbl_BufferCopy+D'4', W, 1
0902  0101      	MOVLB 0x01
0904  6F1C      	MOVWF Process_Re_0000D_1_Interface, 1

				        if ((USWSTAT == ADDRESS_STATE) && (Interface == 0))	{
0906  0E02      	MOVLW 0x02
0908  0100      	MOVLB 0x00
090A  63F6      	CPFSEQ gbl_USWSTAT, 1
090C  D01B      	BRA	label73
090E  0101      	MOVLB 0x01
0910  531C      	MOVF Process_Re_0000D_1_Interface, F, 1
0912  E118      	BNZ	label73
0944            label73

					        OutBuffer[0] = USB_Interface[Interface];
0914  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
0918  50E9      	MOVF FSR0L, W
091A  511C      	MOVF Process_Re_0000D_1_Interface, W, 1
091C  6F25      	MOVWF CompTempVar690, 1
091E  5125      	MOVF CompTempVar690, W, 1
0920  26E9      	ADDWF FSR0L, F
0922  50EF      	MOVF INDF0, W
0924  6F26      	MOVWF CompTempVar691, 1
0926  0100      	MOVLB 0x00
0928  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
092A  6EEA      	MOVWF FSR0H
092C  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
092E  6EE9      	MOVWF FSR0L
0930  0101      	MOVLB 0x01
0932  6B24      	CLRF CompTempVar688, 1
0934  5124      	MOVF CompTempVar688, W, 1
0936  26E9      	ADDWF FSR0L, F
0938  5126      	MOVF CompTempVar691, W, 1
093A  6EEF      	MOVWF INDF0

					        bd0statie = 0xc8;
093C  0EC8      	MOVLW 0xC8
093E  0104      	MOVLB 0x04
0940  6F04      	MOVWF gbl_bd0statie, 1

                        } else if ((USWSTAT == CONFIG_STATE) && (Interface < NUM_INTERFACES)) {
0944  0E03      	MOVLW 0x03
0946  0100      	MOVLB 0x00
0948  63F6      	CPFSEQ gbl_USWSTAT, 1
094A  D01C      	BRA	label74
094C  0E01      	MOVLW 0x01
094E  0101      	MOVLB 0x01
0950  611C      	CPFSLT Process_Re_0000D_1_Interface, 1
0952  D018      	BRA	label74
0984            label74

					        OutBuffer[0] = USB_Interface[Interface];
0954  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
0958  50E9      	MOVF FSR0L, W
095A  511C      	MOVF Process_Re_0000D_1_Interface, W, 1
095C  6F25      	MOVWF CompTempVar695, 1
095E  5125      	MOVF CompTempVar695, W, 1
0960  26E9      	ADDWF FSR0L, F
0962  50EF      	MOVF INDF0, W
0964  6F26      	MOVWF CompTempVar696, 1
0966  0100      	MOVLB 0x00
0968  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
096A  6EEA      	MOVWF FSR0H
096C  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
096E  6EE9      	MOVWF FSR0L
0970  0101      	MOVLB 0x01
0972  6B24      	CLRF CompTempVar693, 1
0974  5124      	MOVF CompTempVar693, W, 1
0976  26E9      	ADDWF FSR0L, F
0978  5126      	MOVF CompTempVar696, W, 1
097A  6EEF      	MOVWF INDF0

					        bd0statie = 0xc8;
097C  0EC8      	MOVLW 0xC8
097E  0104      	MOVLB 0x04
0980  6F04      	MOVWF gbl_bd0statie, 1

				        } else {
					        STALL_EP0;
0984  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case GET_DESCRIPTOR:
085E  0E06      	MOVLW 0x06
0860  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0864  D091      	BRA	label75
0988            label75

				        DescriptorType = BufferCopy.wValue >> 8;
0988  51C4      	MOVF gbl_BufferCopy+D'3', W, 1
098A  0101      	MOVLB 0x01
098C  6F1A      	MOVWF Process_Re_0000D_1_Descrip_0000E, 1

                        if (DescriptorType == HID_REPORT_DESCRIPTOR) {
098E  0E22      	MOVLW 0x22
0990  631A      	CPFSEQ Process_Re_0000D_1_Descrip_0000E, 1
0992  D032      	BRA	label77
09F8            label77

                            /* 22 special HID request to return report descriptor */
					        USB_dev_req = GET_DESCRIPTOR;
0994  0E06      	MOVLW 0x06
0996  0100      	MOVLB 0x00
0998  6FF2      	MOVWF gbl_USB_dev_req, 1

					        if (BufferCopy.wIndex == 0);
099A  53C5      	MOVF gbl_BufferCopy+D'4', F, 1
099C  B4D8      	BTFSC STATUS,Z
099E  53C6      	MOVF gbl_BufferCopy+D'5', F, 1

					        {
						        EP0_start = ReportDescriptor1;
09A0  0E00      	MOVLW HIGH(gbl_ReportDescriptor1+D'0')
09A2  6FE5      	MOVWF gbl_EP0_start+D'1', 1
09A4  0E60      	MOVLW LOW(gbl_ReportDescriptor1+D'0')
09A6  6FE4      	MOVWF gbl_EP0_start, 1

				                EP0_end = EP0_start + sizeof(ReportDescriptor1);
09A8  6BE7      	CLRF gbl_EP0_end+D'1', 1
09AA  0E32      	MOVLW 0x32
09AC  25E4      	ADDWF gbl_EP0_start, W, 1
09AE  6FE6      	MOVWF gbl_EP0_end, 1
09B0  51E5      	MOVF gbl_EP0_start+D'1', W, 1
09B2  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

						        EP0_maxLength = 8;
09B4  0E08      	MOVLW 0x08
09B6  6FF7      	MOVWF gbl_EP0_maxLength, 1

				                if (BufferCopy.wLength < sizeof (ReportDescriptor1))
09B8  0E32      	MOVLW 0x32
09BA  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
09BC  E215      	BC	label76
09BE  67C8      	TSTFSZ gbl_BufferCopy+D'7', 1
09C0  D013      	BRA	label76
09E8            label76

							        EP0_end = EP0_start + BufferCopy.wLength;
09C2  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
09C4  25E4      	ADDWF gbl_EP0_start, W, 1
09C6  0101      	MOVLB 0x01
09C8  6F24      	MOVWF CompTempVar700, 1
09CA  0100      	MOVLB 0x00
09CC  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
09CE  0101      	MOVLB 0x01
09D0  6F25      	MOVWF CompTempVar701, 1
09D2  0100      	MOVLB 0x00
09D4  51E5      	MOVF gbl_EP0_start+D'1', W, 1
09D6  0101      	MOVLB 0x01
09D8  2325      	ADDWFC CompTempVar701, F, 1
09DA  5124      	MOVF CompTempVar700, W, 1
09DC  0100      	MOVLB 0x00
09DE  6FE6      	MOVWF gbl_EP0_end, 1
09E0  0101      	MOVLB 0x01
09E2  5125      	MOVF CompTempVar701, W, 1
09E4  0100      	MOVLB 0x00
09E6  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						        CopyDescriptorToEP0();
09E8  EC59F000  	CALL CopyDescri_0000B

					        }
					        if (BufferCopy.wIndex == 1);
09EC  0E01      	MOVLW 0x01
09EE  0100      	MOVLB 0x00
09F0  63C5      	CPFSEQ gbl_BufferCopy+D'4', 1
09F4  51C6      	MOVF gbl_BufferCopy+D'5', W, 1

					        {
					            /* Repeat above code for another Report Descriptor. */
					        }
				        } else if (DescriptorType == HID_DESCRIPTOR) {
09F8  0E21      	MOVLW 0x21
09FA  631A      	CPFSEQ Process_Re_0000D_1_Descrip_0000E, 1
09FC  D033      	BRA	label80
0A64            label80

				            /* 21 HID descriptor */
					        USB_dev_req = GET_DESCRIPTOR;
09FE  0E06      	MOVLW 0x06
0A00  0100      	MOVLB 0x00
0A02  6FF2      	MOVWF gbl_USB_dev_req, 1

					        if (BufferCopy.wIndex == 0) {
0A04  53C5      	MOVF gbl_BufferCopy+D'4', F, 1
0A06  E128      	BNZ	label79
0A08  53C6      	MOVF gbl_BufferCopy+D'5', F, 1
0A0A  E126      	BNZ	label79
0A58            label79

						        EP0_start = HIDDescriptor;
0A0C  0E00      	MOVLW HIGH(gbl_HIDDescriptor+D'0')
0A0E  6FE5      	MOVWF gbl_EP0_start+D'1', 1
0A10  0EB8      	MOVLW LOW(gbl_HIDDescriptor+D'0')
0A12  6FE4      	MOVWF gbl_EP0_start, 1

						        EP0_end   = EP0_start + sizeof (HIDDescriptor);
0A14  6BE7      	CLRF gbl_EP0_end+D'1', 1
0A16  0E09      	MOVLW 0x09
0A18  25E4      	ADDWF gbl_EP0_start, W, 1
0A1A  6FE6      	MOVWF gbl_EP0_end, 1
0A1C  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0A1E  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

						        EP0_maxLength = 8;
0A20  0E08      	MOVLW 0x08
0A22  6FF7      	MOVWF gbl_EP0_maxLength, 1

						        if (BufferCopy.wLength < sizeof (HIDDescriptor))
0A24  0E09      	MOVLW 0x09
0A26  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
0A28  E215      	BC	label78
0A2A  67C8      	TSTFSZ gbl_BufferCopy+D'7', 1
0A2C  D013      	BRA	label78
0A54            label78

							        EP0_end = EP0_start + BufferCopy.wLength;
0A2E  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
0A30  25E4      	ADDWF gbl_EP0_start, W, 1
0A32  0101      	MOVLB 0x01
0A34  6F24      	MOVWF CompTempVar705, 1
0A36  0100      	MOVLB 0x00
0A38  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
0A3A  0101      	MOVLB 0x01
0A3C  6F25      	MOVWF CompTempVar706, 1
0A3E  0100      	MOVLB 0x00
0A40  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0A42  0101      	MOVLB 0x01
0A44  2325      	ADDWFC CompTempVar706, F, 1
0A46  5124      	MOVF CompTempVar705, W, 1
0A48  0100      	MOVLB 0x00
0A4A  6FE6      	MOVWF gbl_EP0_end, 1
0A4C  0101      	MOVLB 0x01
0A4E  5125      	MOVF CompTempVar706, W, 1
0A50  0100      	MOVLB 0x00
0A52  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						        CopyDescriptorToEP0();
0A54  EC59F000  	CALL CopyDescri_0000B

					        }
					        if (BufferCopy.wIndex == 1) {
0A58  0E01      	MOVLW 0x01
0A5A  0100      	MOVLB 0x00
0A5C  63C5      	CPFSEQ gbl_BufferCopy+D'4', 1
0A60  51C6      	MOVF gbl_BufferCopy+D'5', W, 1

						        /* Repeat above code for another HID Descriptor. */
					        }
				        } else {
                            /* unrecognised request */
					        STALL_EP0;
0A64  8070      	BSF gbl_uep0,0

                        }
				        break;
			        default:
				        break;
			    }
			    break;
            // Sixth bmRequestType ************************************	
		    case ENDPOINTTOHOST:
02E6  0E82      	MOVLW 0x82
02E8  63C1      	CPFSEQ gbl_BufferCopy, 1
02EA  EF80F005  	GOTO	label83
0A68            label81

			    if (BufferCopy.bRequest == GET_STATUS) {   
0A68  53C2      	MOVF gbl_BufferCopy+D'1', F, 1
0A6A  A4D8      	BTFSS STATUS,Z

				    UEPArray = (unsigned char *) &uep0;
0A6E  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0A70  0101      	MOVLB 0x01
0A72  6F24      	MOVWF CompTempVar707, 1
0A74  0E70      	MOVLW LOW(gbl_uep0+D'0')
0A76  6F18      	MOVWF Process_Re_0000D_1_UEPArray, 1
0A78  5124      	MOVF CompTempVar707, W, 1
0A7A  6F19      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1

				    Endpoint = BufferCopy.wIndex & 0x0F;
0A7C  0E0F      	MOVLW 0x0F
0A7E  0100      	MOVLB 0x00
0A80  15C5      	ANDWF gbl_BufferCopy+D'4', W, 1
0A82  0101      	MOVLB 0x01
0A84  6F1B      	MOVWF Process_Re_0000D_1_Endpoint, 1

                    OutBuffer = (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie << 8));
0A86  0104      	MOVLB 0x04
0A88  5106      	MOVF gbl_bd0adrlie, W, 1
0A8A  0101      	MOVLB 0x01
0A8C  6F24      	MOVWF CompTempVar708, 1
0A8E  6B27      	CLRF CompTempVar710+D'1', 1
0A90  6B28      	CLRF CompTempVar711, 1
0A92  0104      	MOVLB 0x04
0A94  5107      	MOVF gbl_bd0adrhie, W, 1
0A96  0101      	MOVLB 0x01
0A98  6F25      	MOVWF CompTempVar709, 1
0A9A  5128      	MOVF CompTempVar711, W, 1
0A9C  2724      	ADDWF CompTempVar708, F, 1
0A9E  5127      	MOVF CompTempVar710+D'1', W, 1
0AA0  2325      	ADDWFC CompTempVar709, F, 1
0AA2  5124      	MOVF CompTempVar708, W, 1
0AA4  0100      	MOVLB 0x00
0AA6  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0AA8  0101      	MOVLB 0x01
0AAA  5125      	MOVF CompTempVar709, W, 1
0AAC  0100      	MOVLB 0x00
0AAE  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

		            //		OutBuffer = (unsigned char * ) bd0adrlie;
				    OutBuffer[1] = 0;
0AB0  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0AB2  6EEA      	MOVWF FSR0H
0AB4  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0AB6  6EE9      	MOVWF FSR0L
0AB8  0E01      	MOVLW 0x01
0ABA  26E9      	ADDWF FSR0L, F
0ABC  0E00      	MOVLW 0x00
0ABE  6EEF      	MOVWF INDF0

				    bd0cntie = 2;
0AC0  0E02      	MOVLW 0x02
0AC2  0104      	MOVLB 0x04
0AC4  6F05      	MOVWF gbl_bd0cntie, 1


				    if (Endpoint < 3) {
0AC6  0E03      	MOVLW 0x03
0AC8  0101      	MOVLB 0x01
0ACA  611B      	CPFSLT Process_Re_0000D_1_Endpoint, 1
0ACC  D017      	BRA	label82
0AFC            label82

					    OutBuffer[0] = UEPArray [Endpoint] & 0x01;
0ACE  5119      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0AD0  6EEA      	MOVWF FSR0H
0AD2  5118      	MOVF Process_Re_0000D_1_UEPArray, W, 1
0AD4  251B      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
0AD6  6EE9      	MOVWF FSR0L
0AD8  0E01      	MOVLW 0x01
0ADA  14EF      	ANDWF INDF0, W
0ADC  6F25      	MOVWF CompTempVar719, 1
0ADE  0100      	MOVLB 0x00
0AE0  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0AE2  6EEA      	MOVWF FSR0H
0AE4  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0AE6  6EE9      	MOVWF FSR0L
0AE8  0101      	MOVLB 0x01
0AEA  6B24      	CLRF CompTempVar715, 1
0AEC  5124      	MOVF CompTempVar715, W, 1
0AEE  26E9      	ADDWF FSR0L, F
0AF0  5125      	MOVF CompTempVar719, W, 1
0AF2  6EEF      	MOVWF INDF0

					    bd0statie = 0xc8;
0AF4  0EC8      	MOVLW 0xC8
0AF6  0104      	MOVLB 0x04
0AF8  6F04      	MOVWF gbl_bd0statie, 1

				    } else {
					    STALL_EP0;
0AFC  8070      	BSF gbl_uep0,0

                    }
			    }
			    break;
            // Seventh bmRequestType (others) ************************************	
		    default:
0B00            label83

		        if (BufferCopy.bmRequestType & 0x20) {
0B00  ABC1      	BTFSS gbl_BufferCopy,5, 1

	                OutBuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));						
0B04  0104      	MOVLB 0x04
0B06  5106      	MOVF gbl_bd0adrlie, W, 1
0B08  0101      	MOVLB 0x01
0B0A  6F24      	MOVWF CompTempVar720, 1
0B0C  6B27      	CLRF CompTempVar722+D'1', 1
0B0E  6B28      	CLRF CompTempVar723, 1
0B10  0104      	MOVLB 0x04
0B12  5107      	MOVF gbl_bd0adrhie, W, 1
0B14  0101      	MOVLB 0x01
0B16  6F25      	MOVWF CompTempVar721, 1
0B18  5128      	MOVF CompTempVar723, W, 1
0B1A  2724      	ADDWF CompTempVar720, F, 1
0B1C  5127      	MOVF CompTempVar722+D'1', W, 1
0B1E  2325      	ADDWFC CompTempVar721, F, 1
0B20  5124      	MOVF CompTempVar720, W, 1
0B22  0100      	MOVLB 0x00
0B24  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0B26  0101      	MOVLB 0x01
0B28  5125      	MOVF CompTempVar721, W, 1
0B2A  0100      	MOVLB 0x00
0B2C  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				    switch (BufferCopy.bmRequestType) {
				        case 0x21:	
0B2E  0E21      	MOVLW 0x21
0B30  63C1      	CPFSEQ gbl_BufferCopy, 1
0B32  D001      	BRA	label84
0B34  D014      	BRA	label89
0B36            label84
0B5E            label89

                            /* Host to Device HID request */
					        switch (BufferCopy.bRequest) {
					            case HID_SET_PROTOCOL:	
0B5E  0E0B      	MOVLW 0x0B
0B60  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B62  D001      	BRA	label90
0B64  D008      	BRA	label92
0B66            label90
0B76            label92

                                    /* Set Protocol */
						            USB_protocol = BufferCopy.wValue;
0B76  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0B78  6FF5      	MOVWF gbl_USB_protocol, 1

						            Send_0Len_pkt;	
0B7A  0104      	MOVLB 0x04
0B7C  6B05      	CLRF gbl_bd0cntie, 1
0B7E  0EC8      	MOVLW 0xC8
0B80  6F04      	MOVWF gbl_bd0statie, 1
0B82  0100      	MOVLB 0x00
0B84  6BF2      	CLRF gbl_USB_dev_req, 1

						            break;
					            case HID_SET_REPORT:
0B66  0E09      	MOVLW 0x09
0B68  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B6A  D001      	BRA	label91
0B6E            label91

                                    /* Set HID Report */
	                                // Add Set_Report Function above for OUT TOKEN and uncomment following two lines
					                //	USB_dev_req = HID_SET_REPORT;
						            break;
					            case HID_SET_IDLE:
0B6E  0E0A      	MOVLW 0x0A
0B70  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B72  D00C      	BRA	label94
0B88            label93

                                    /* Set Idle */
					                STALL_EP0;
0B88  8070      	BSF gbl_uep0,0

					                break;
					            default:
0B8C            label94

					                STALL_EP0;
0B8C  8070      	BSF gbl_uep0,0

					        }
					        break;
				    case 0xA1:
0B36  0EA1      	MOVLW 0xA1
0B38  63C1      	CPFSEQ gbl_BufferCopy, 1
0B3A  D001      	BRA	label85
0B3C  D029      	BRA	label95
0B3E            label85
0B90            label95

                        /* Dev2HostHIDRequest */
						switch (BufferCopy.bRequest) {
					        case HID_GET_PROTOCOL:	/* Get Protocol */
0B90  0E03      	MOVLW 0x03
0B92  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B94  D001      	BRA	label96
0B96  D007      	BRA	label97
0B98            label96
0BA6            label97

						        OutBuffer[0] = USB_protocol;
0BA6  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0BA8  6EEA      	MOVWF FSR0H
0BAA  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0BAC  6EE9      	MOVWF FSR0L
0BAE  0101      	MOVLB 0x01
0BB0  6B24      	CLRF CompTempVar726, 1
0BB2  5124      	MOVF CompTempVar726, W, 1
0BB4  26E9      	ADDWF FSR0L, F
0BB6  0100      	MOVLB 0x00
0BB8  51F5      	MOVF gbl_USB_protocol, W, 1
0BBA  6EEF      	MOVWF INDF0

						        bd0cntie = 1;
0BBC  0E01      	MOVLW 0x01
0BBE  0104      	MOVLB 0x04
0BC0  6F05      	MOVWF gbl_bd0cntie, 1

						        bd0statie = 0xC8;
0BC2  0EC8      	MOVLW 0xC8
0BC4  6F04      	MOVWF gbl_bd0statie, 1

						        break;
					        case HID_GET_REPORT: /* Get HID Report */
0B98  05C2      	DECF gbl_BufferCopy+D'1', W, 1
0B9A  B4D8      	BTFSC STATUS,Z

	                            // Add Get_Report Function here and uncomment following two lines
			    		        //	BD0IST = 0xc8;	// Turn over BDT to SIE
						        break;
					        case HID_GET_IDLE:
0B9E  0E02      	MOVLW 0x02
0BA0  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0BA2  D014      	BRA	label99
0BC8            label98

                                /* Get Idle */
					            STALL_EP0;
0BC8  8070      	BSF gbl_uep0,0

					            break;
					        default:
0BCC            label99

                                // device does not support get idle, just stall
					            STALL_EP0;
0BCC  8070      	BSF gbl_uep0,0

					    }
					    break;
				    case 0x22:
0B3E  0E22      	MOVLW 0x22
0B40  63C1      	CPFSEQ gbl_BufferCopy, 1
0B42  D001      	BRA	label86
0B44  D045      	BRA	label100
0B46            label86
0BD0            label100

                        /* Host2DevReportRequest */
					    STALL_EP0;
0BD0  8070      	BSF gbl_uep0,0

					    break;				
				    case 0x23:
0B46  0E23      	MOVLW 0x23
0B48  63C1      	CPFSEQ gbl_BufferCopy, 1
0B4A  D001      	BRA	label87
0B4C  D043      	BRA	label101
0B4E            label87
0BD4            label101

                        /* Host2DevPhysicalRequest */
					    STALL_EP0;
0BD4  8070      	BSF gbl_uep0,0

					    break;				
				    case 0xA2:
0B4E  0EA2      	MOVLW 0xA2
0B50  63C1      	CPFSEQ gbl_BufferCopy, 1
0B52  D001      	BRA	label88
0B54  D041      	BRA	label102
0B56            label88
0BD8            label102

                        /* Dev2HostReportRequest */
					    STALL_EP0;
0BD8  8070      	BSF gbl_uep0,0

					    break;				
				    case 0xA3:
0B56  0EA3      	MOVLW 0xA3
0B58  63C1      	CPFSEQ gbl_BufferCopy, 1
0B5A  D042      	BRA	label104
0BDC            label103

                        /* Dev2HostPhysicalRequest */
					    STALL_EP0;
0BDC  8070      	BSF gbl_uep0,0

					    break;				
				    default:
0BE0            label104

    				    STALL_EP0;
0BE0  8070      	BSF gbl_uep0,0

				}
			}
    	}
    }
}
01F8  0012      	RETURN
01FE  0012      	RETURN
0204  0012      	RETURN
0206  0012      	RETURN
021E  0012      	RETURN
0224  0012      	RETURN
0226  0012      	RETURN
0236  0012      	RETURN
0324  0012      	RETURN
0328  0012      	RETURN
034C  0012      	RETURN
0350  0012      	RETURN
0370  0012      	RETURN
0374  0012      	RETURN
03AA  0012      	RETURN
03AE  0012      	RETURN
03EC  0012      	RETURN
03F0  0012      	RETURN
03F4  0012      	RETURN
044A  0012      	RETURN
047A  0012      	RETURN
047E  0012      	RETURN
0482  0012      	RETURN
04D0  0012      	RETURN
0500  0012      	RETURN
0504  0012      	RETURN
0508  0012      	RETURN
050C  0012      	RETURN
0524  0012      	RETURN
056C  0012      	RETURN
05F2  0012      	RETURN
0674  0012      	RETURN
0712  0012      	RETURN
0786  0012      	RETURN
07FA  0012      	RETURN
0802  0012      	RETURN
080A  0012      	RETURN
0850  0012      	RETURN
0862  0012      	RETURN
08CA  0012      	RETURN
08CE  0012      	RETURN
0942  0012      	RETURN
0982  0012      	RETURN
0986  0012      	RETURN
09F2  0012      	RETURN
09F6  0012      	RETURN
0A5E  0012      	RETURN
0A62  0012      	RETURN
0A66  0012      	RETURN
0A6C  0012      	RETURN
0AFA  0012      	RETURN
0AFE  0012      	RETURN
0B02  0012      	RETURN
0B6C  0012      	RETURN
0B86  0012      	RETURN
0B8A  0012      	RETURN
0B8E  0012      	RETURN
0B9C  0012      	RETURN
0BC6  0012      	RETURN
0BCA  0012      	RETURN
0BCE  0012      	RETURN
0BD2  0012      	RETURN
0BD6  0012      	RETURN
0BDA  0012      	RETURN
0BDE  0012      	RETURN
0BE2  0012      	RETURN


/* ********************************************************************* */
/* Branch off and service the USB interrupt flags			 */
/* ********************************************************************* */
void ServiceUSB() {

	if (bTOK_DONE)
0C3E  B668      	BTFSC gbl_bTOK_DONE,3

		Process_Req();
0C40  ECA3F000  	CALL Process_Re_0000D

	
    if (bSTALL)
0C44  BA68      	BTFSC gbl_bSTALL,5

		USBStall();
0C46  EC9AF000  	CALL USBStall_00000

	
    if (bUERR)
0C4A  B268      	BTFSC gbl_bUERR,1

	    Count_Error();
0C4C  ECF2F005  	CALL Count_Erro_0000C

	
    if (bUIDLE)	
0C50  B869      	BTFSC gbl_bUIDLE,4

		USBSleep();
0C52  EC9CF000  	CALL USBSleep_00000

}
0C56  0012      	RETURN


////////////////////////////////////////////////////////////////
// Interrupt service routine. Branch off to different interrupts
////////////////////////////////////////////////////////////////	
void interrupt(void) {

    if (pie2.USBIE && pir2.USBIF) {
1140  CFEAF001  	MOVFF FSR0H,  Int1Context
1144  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1148  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
114C  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
1150  AAA0      	BTFSS gbl_pie2,5
1152  D026      	BRA	label131
1154  AAA1      	BTFSS gbl_pir2,5
1156  D024      	BRA	label131
11A0            label131

		if (uir.ACTVIF && uie.ACTVIE) // WAS IT AN ACTIVITY WAKEUP?
1158  A468      	BTFSS gbl_uir,2
115A  D004      	BRA	label126
115C  A469      	BTFSS gbl_uie,2
115E  D002      	BRA	label126
1164            label126

			USBActivity();
1160  EC53F000  	CALL USBActivit_0000A

		
        if (uir.URSTIF && uie.URSTIE) // USB reset must be serviced immediately
1164  A068      	BTFSS gbl_uir,0
1166  D004      	BRA	label127
1168  A069      	BTFSS gbl_uie,0
116A  D002      	BRA	label127
1170            label127

			USBReset();
116C  EC3AF000  	CALL USBReset_00000

		
        if (uir.TRNIF && uie.TRNIE) { // WAS IT A TOKEN DONE 
1170  A668      	BTFSS gbl_uir,3
1172  D015      	BRA	label130
1174  A669      	BTFSS gbl_uie,3
1176  D013      	BRA	label130
119E            label130

			if (USB_dev_req == SET_ADDRESS)	{
1178  0E05      	MOVLW 0x05
117A  0100      	MOVLB 0x00
117C  63F2      	CPFSEQ gbl_USB_dev_req, 1
117E  D00E      	BRA	label129

                // Finish Set Address
				USB_dev_req = NULL;
1180  6BF2      	CLRF gbl_USB_dev_req, 1

				USB_Curr_Config = 0;
1182  6BF0      	CLRF gbl_USB_Curr_Config, 1

				uaddr = USB_address_pending;
1184  51F1      	MOVF gbl_USB_address_pending, W, 1
1186  6E6E      	MOVWF gbl_uaddr

				uie = 00000001b;		// enable just the reset interrupt
1188  0E01      	MOVLW 0x01
118A  6E69      	MOVWF gbl_uie

 				if (USB_address_pending > 0)
118C  0E00      	MOVLW 0x00
118E  65F1      	CPFSGT gbl_USB_address_pending, 1
1190  D003      	BRA	label128
1198            label128

					USWSTAT= ADDRESS_STATE;
1192  0E02      	MOVLW 0x02
1194  6FF6      	MOVWF gbl_USWSTAT, 1

				else
1196  D002      	BRA	label129
119C            label129

					USWSTAT= DEFAULT_STATE;
1198  0E01      	MOVLW 0x01
119A  6FF6      	MOVWF gbl_USWSTAT, 1

			}
			bTOK_DONE = 0; // clear Token Done flag
119C  9668      	BCF gbl_bTOK_DONE,3

		}
		bUSBIF = 0;	 // Clear USB interrupt flag
119E  9AA1      	BCF gbl_bUSBIF,5

	}
}
11A0  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
11A4  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
11A8  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
11AC  C001FFEA  	MOVFF Int1Context,  FSR0H
11B0  0011      	RETFIE 1


//*****************************************************
//  AT LAST THE MAIN PROGRAM
//*****************************************************
void main() {

	unsigned char i;
	unsigned short j;
	signed char buffer[3];
    const signed char tablex [] = {-1, -1, -1, 1, 1, 1,  1,  1, 1, -1,  -1, -1};
0D22  0101      	MOVLB 0x01
0D24  6900      	SETF main_1_tablex, 1
0D26  6901      	SETF main_1_tablex+D'1', 1
0D28  6902      	SETF main_1_tablex+D'2', 1
0D2A  0E01      	MOVLW 0x01
0D2C  6F03      	MOVWF main_1_tablex+D'3', 1
0D2E  6F04      	MOVWF main_1_tablex+D'4', 1
0D30  6F05      	MOVWF main_1_tablex+D'5', 1
0D32  6F06      	MOVWF main_1_tablex+D'6', 1
0D34  6F07      	MOVWF main_1_tablex+D'7', 1
0D36  6F08      	MOVWF main_1_tablex+D'8', 1
0D38  6909      	SETF main_1_tablex+D'9', 1
0D3A  690A      	SETF main_1_tablex+D'10', 1
0D3C  690B      	SETF main_1_tablex+D'11', 1

    const signed char tabley [] = {-1, 0, 1,  1,  0, -1, -1, 0,  1, 1, 0, -1 };
0D3E  690C      	SETF main_1_tabley, 1
0D40  6B0D      	CLRF main_1_tabley+D'1', 1
0D42  0E01      	MOVLW 0x01
0D44  6F0E      	MOVWF main_1_tabley+D'2', 1
0D46  6F0F      	MOVWF main_1_tabley+D'3', 1
0D48  6B10      	CLRF main_1_tabley+D'4', 1
0D4A  6911      	SETF main_1_tabley+D'5', 1
0D4C  6912      	SETF main_1_tabley+D'6', 1
0D4E  6B13      	CLRF main_1_tabley+D'7', 1
0D50  0E01      	MOVLW 0x01
0D52  6F14      	MOVWF main_1_tabley+D'8', 1
0D54  6F15      	MOVWF main_1_tabley+D'9', 1
0D56  6B16      	CLRF main_1_tabley+D'10', 1
0D58  6917      	SETF main_1_tabley+D'11', 1

	// The table array contains the directional data for simulated mouse 
    // movement to form the infinity symbol (i.e. figure 8).   Movements are relative
    // to the previous position. 
	ddrb = 0;
0D5A  6A93      	CLRF gbl_ddrb

	for (i = 0; i < 5; i++) {
0D5C  0100      	MOVLB 0x00
0D5E  6BF8      	CLRF main_1_i, 1
0D60            label114
0D60  0E05      	MOVLW 0x05
0D62  61F8      	CPFSLT main_1_i, 1
0D64  D00D      	BRA	label118
0D7C  2BF8      	INCF main_1_i, F, 1
0D7E  D7F0      	BRA	label114
0D80            label118

	    for (j=0; j<64000; j++); // Small delay (greater than 16us) in order to
0D66  6BF9      	CLRF main_1_j, 1
0D68  6BFA      	CLRF main_1_j+D'1', 1
0D6A            label115
0D6A  0EFA      	MOVLW 0xFA
0D6C  5DFA      	SUBWF main_1_j+D'1', W, 1
0D6E  E102      	BNZ	label116
0D70  0E00      	MOVLW 0x00
0D72  5DF9      	SUBWF main_1_j, W, 1
0D74            label116
0D74  E203      	BC	label117
0D76  4BF9      	INFSNZ main_1_j, F, 1
0D78  2BFA      	INCF main_1_j+D'1', F, 1
0D7A  D7F7      	BRA	label115
0D7C            label117

	};

	InitUSB(); // allow SIE to come online before beginning USB initialization
0D80  EC70F006  	CALL InitUSB_00000

	buffer[0] = 0;	//we won't be simulating mouse buttons		
0D84  6BFB      	CLRF main_1_buffer, 1

	i = 10;
0D86  0E0A      	MOVLW 0x0A
0D88  6FF8      	MOVWF main_1_i, 1

	j = 0;
0D8A  6BF9      	CLRF main_1_j, 1
0D8C  6BFA      	CLRF main_1_j+D'1', 1

    t0con = 11000111b; //set up timer0 as 8 bit timer with prescaler of 256 and enable
0D8E  0EC7      	MOVLW 0xC7
0D90  6ED5      	MOVWF gbl_t0con

    // 4/24* 10^6 * 256 * 256 = 10.9 msec timer overflow

	while (1) {
0D92            label119
0E34  D7AE      	BRA	label119

		if (bTMR0IF) {	// Poll all functions every 10.9ms
0D92  A4F2      	BTFSS gbl_bTMR0IF,2
0D94  D021      	BRA	label121

			bTMR0IF = 0;   // clear the timer flag
0D96  94F2      	BCF gbl_bTMR0IF,2

			ServiceUSB();	// Service USB functions
0D98  EC1FF006  	CALL ServiceUSB_00000

			if (isJiggling) {
0D9C  A05F      	BTFSS gbl_isJiggling,0
0D9E  D01C      	BRA	label121
0DD8            label121

                // send same data 10 times (100 msec)
                if (i > 9) {
0DA0  0E09      	MOVLW 0x09
0DA2  0100      	MOVLB 0x00
0DA4  65F8      	CPFSGT main_1_i, 1
0DA6  D00A      	BRA	label120

                    i = 0;
0DA8  6BF8      	CLRF main_1_i, 1

                    j++;
0DAA  4BF9      	INFSNZ main_1_j, F, 1
0DAC  2BFA      	INCF main_1_j+D'1', F, 1

                    // (limit to length of table array)
                    if (j == 12)
0DAE  0E0C      	MOVLW 0x0C
0DB0  63F9      	CPFSEQ main_1_j, 1
0DB2  D004      	BRA	label120
0DB4  51FA      	MOVF main_1_j+D'1', W, 1
0DB6  E102      	BNZ	label120
0DBC            label120

                        j = 0;
0DB8  6BF9      	CLRF main_1_j, 1
0DBA  6BFA      	CLRF main_1_j+D'1', 1

                }
                // Increment infinity vectors
                buffer[1] = tablex[j];	// X vector 
0DBC  EE01F000  	LFSR 0x00,  main_1_tablex
0DC0  50E9      	MOVF FSR0L, W
0DC2  51F9      	MOVF main_1_j, W, 1
0DC4  26E9      	ADDWF FSR0L, F
0DC6  50EF      	MOVF INDF0, W
0DC8  6FFC      	MOVWF main_1_buffer+D'1', 1

                buffer[2] = tabley[j];	// Y vector
0DCA  EE01F00C  	LFSR 0x00,  main_1_tabley
0DCE  50E9      	MOVF FSR0L, W
0DD0  51F9      	MOVF main_1_j, W, 1
0DD2  26E9      	ADDWF FSR0L, F
0DD4  50EF      	MOVF INDF0, W
0DD6  6FFD      	MOVWF main_1_buffer+D'2', 1

            }
        }
        if (ConfiguredUSB()) {
0DD8  0E03      	MOVLW 0x03
0DDA  0100      	MOVLB 0x00
0DDC  15F6      	ANDWF gbl_USWSTAT, W, 1
0DDE  6FFE      	MOVWF CompTempVar732, 1
0DE0  0E03      	MOVLW 0x03
0DE2  63FE      	CPFSEQ CompTempVar732, 1
0DE4  D00D      	BRA	label122

            // Wait until device is configured before using EP1.  If Endpoints 1 or 2 are used before
			//   the device is configured, errors will occur.
		    if (PutEP1(3, buffer)) {
0DE6  0E03      	MOVLW 0x03
0DE8  6FFE      	MOVWF PutEP1_00000_arg_bytes, 1
0DEA  0E00      	MOVLW HIGH(main_1_buffer+D'0')
0DEC  0101      	MOVLB 0x01
0DEE  6F19      	MOVWF PutEP1_00000_arg_buffer+D'1', 1
0DF0  0EFB      	MOVLW LOW(main_1_buffer+D'0')
0DF2  6F18      	MOVWF PutEP1_00000_arg_buffer, 1
0DF4  EC2CF006  	CALL PutEP1_00000
0DF8  531D      	MOVF CompTempVarRet569, F, 1
0DFA  E002      	BZ	label122

                // Increment i if EP1 IN buffer is accessible
                i++;
0DFC  0100      	MOVLB 0x00
0DFE  2BF8      	INCF main_1_i, F, 1

                //   to the PIC.  If not accessible, try again next time.
            }
		}
        
        // Check for button press
        if (buttonOld != BUTTON) {
0E00  0E00      	MOVLW 0x00
0E02  B481      	BTFSC gbl_portb,2
0E04  0A01      	XORLW 0x01
0E06  B25F      	BTFSC gbl_buttonOld,1
0E08  0A01      	XORLW 0x01
0E0A  0BFF      	ANDLW 0xFF
0E0C  E010      	BZ	label124

            if(!BUTTON) {
0E0E  B481      	BTFSC gbl_portb,2
0E10  D00E      	BRA	label124

                delay_ms(100);
0E12  0E64      	MOVLW 0x64
0E14  0100      	MOVLB 0x00
0E16  6FFE      	MOVWF delay_ms_00000_arg_del, 1
0E18  EC06F000  	CALL delay_ms_00000

                if(!BUTTON) {
0E1C  B481      	BTFSC gbl_portb,2
0E1E  D007      	BRA	label124

                    if (!isJiggling) {
0E20  B05F      	BTFSC gbl_isJiggling,0
0E22  D003      	BRA	label123
0E2A            label123

                        isJiggling = 1;
0E24  805F      	BSF gbl_isJiggling,0

                        LED = 1;
0E26  8281      	BSF gbl_portb,1

                    } else {
0E28  D002      	BRA	label124
0E2E            label124

                        isJiggling = 0;
0E2A  905F      	BCF gbl_isJiggling,0

                        LED = 0;
0E2C  9281      	BCF gbl_portb,1

                    }
                }
            }
        }
        buttonOld = BUTTON;
0E2E  925F      	BCF gbl_buttonOld,1
0E30  B481      	BTFSC gbl_portb,2
0E32  825F      	BSF gbl_buttonOld,1

	}
}

}
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF1BF007  	GOTO	_startup

0008  EFA0F008  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53FE      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF9      	MOVLW 0xF9
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0FFF      	ADDLW 0xFF
0040  A4D8      	BTFSS STATUS,Z
0042  D7E9      	BRA	label2
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  0000      	NOP
0062  0000      	NOP
0064  0000      	NOP
0066  0000      	NOP
0068  0000      	NOP
006A  0000      	NOP
006C  0000      	NOP
006E  2FFE      	DECFSZ delay_ms_00000_arg_del, F, 1
0070  D7D1      	BRA	label1
0072  0012      	RETURN
0074            ; } delay_ms function end



































0E36            _startup

113C  EF91F006  	GOTO	main

300000  0E30      	DW 0x0E30
300002  1E3E      	DW 0x1E3E
300004  00FF      	DW 0x00FF
300006  FF80      	DW 0xFF80
300008  C00F      	DW 0xC00F
30000A  E00F      	DW 0xE00F
30000C  400F      	DW 0x400F
