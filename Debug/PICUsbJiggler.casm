;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PICUSBJIGGLER_H_
#define _PICUSBJIGGLER_H_

#define LED (portb.1) // LED pin
#define BUTTON (portb.2) // Button (switch) pin

bit isJiggling = 0; // When 0, device does nothing
0E64  905F      	BCF gbl_isJiggling,0

bit buttonOld = 1;
0E66  825F      	BSF gbl_buttonOld,1


#define TRUE   1
#define FALSE  0
#define NULL   0

#define DEBUG_SERIAL 	1
#define NUM_CONFIGURATIONS      1
#define NUM_INTERFACES          1

#define ConfiguredUSB() ((USWSTAT&0x3) == CONFIG_STATE)
#define STALL_EP0    	set_bit(uep0,EPSTALL)
#define STALL_PID_EP0IN 	bd0statie = 0xCC  /* REQUEST ERROR */
#define Send_0Len_pkt	bd0cntie = 0;	bd0statie = 0xc8;	USB_dev_req = NULL

#define POWERED_STATE	        0x00
#define DEFAULT_STATE	        0x01
#define ADDRESS_STATE	        0x02
#define CONFIG_STATE	        0x03
#define ENDPT_DISABLED	        0x10  // For 18F2455 with handshaking
#define ENDPT_IN_ONLY	        0x12
#define ENDPT_OUT_ONLY	        0x14
#define ENDPT_CONTROL	        0x16	/* enable for in, out and setup */
#define ENDPT_NON_CONTROL		0x1E	/* enable for in, and out */
#define TOKEN_OUT	(0x01<<2)
#define TOKEN_ACK	(0x02<<2)
#define TOKEN_IN	(0x09<<2)
#define TOKEN_SETUP	(0x0D<<2)
#define CLEAR_FEATURE	        0x01
#define GET_CONFIGURATION	0x08
#define GET_DESCRIPTOR	        0x06
#define GET_INTERFACE	        0x0A
#define GET_STATUS	        0x00
#define SET_ADDRESS	        0x05
#define SET_CONFIGURATION	0x09
#define SET_FEATURE	        0x03
#define SET_INTERFACE	        0x0B
#define HID_GET_REPORT		0x01
#define	HID_GET_IDLE		0x02
#define	HID_GET_PROTOCOL	0x03
#define HID_SET_REPORT		0x09
#define HID_SET_IDLE		0x0A
#define HID_SET_PROTOCOL	0x0B
#define HID_REPORT_DESCRIPTOR 	0x22
#define HID_DESCRIPTOR 			0x21
#define VEND_SET_MEMORY	        0x80
#define HOSTTODEVICE            0x00
#define HOSTTOINTERFACE         0x01
#define HOSTTOENDPOINT          0x02
#define DEVICETOHOST            0x80
#define INTERFACETOHOST         0x81
#define ENDPOINTTOHOST          0x82
#define EP0OUT                  0
#define EP0IN                   1
#define EP1OUT                  2
#define EP1IN                   3
#define EP2OUT                  4
#define EP2IN                   5

// Descriptor Types
#define DEVICE                  1
#define CONFIGURATION           2
#define STRING                  3
#define INTERFACE               4
#define ENDPOINT                5
#define CS_INTERFACE            0x24
#define CS_ENDPOINT             0x25

//define some useful bit variables
volatile  bit  bDEV_ATT@UCON.USBEN;
volatile bit   bSUSPND@UCON.SUSPND;
volatile bit   bPKT_DIS@UCON.PKTDIS;
volatile  bit  bUIDLE@UIE.IDLEIE;
//ENABLE BITS
volatile  bit  bACTIVITY_E@UIE.ACTVIE;
volatile bit   bTOK_DONE_E@UIE.TRNIE; 
volatile bit  bPID_ERR_E@UEIE.PIDEE;
volatile bit  bCRC5_E@UEIE.CRC5EE;
volatile bit  bCRC16_E@UEIE.CRC16EE;
volatile bit  bDFN8_E@UEIE.DFN8EE;
volatile bit  bBTO_ERR_E@UEIE.BTOEE;
volatile bit  bBTS_ERR_E@UEIE.BTSEE;
volatile bit  bUSBRST_E@UIE.URSTIE;
volatile bit  bUSBIE@PIE2.USBIE;
//FLAG BITS
volatile bit   bSTALL@UIR.STALLIF;
volatile  bit  bUERR@UIR.UERRIF;
volatile bit  bPID_ERR@UEIR.PIDEF;
volatile bit  bCRC5@UEIR.CRC5EF; 
volatile  bit bCRC16@UEIR.CRC16EF;  
volatile bit  bDFN8@UEIR.DFN8EF;
volatile bit  bBTO_ERR@UEIR.BTOEF; 
volatile bit  bBTS_ERR@UEIR.BTSEF;
volatile bit bUSBIF@PIR2.USBIF;
volatile bit bUSBRST@UIR.URSTIF;
volatile bit bTMR0IF@INTCON.TMR0IF;
volatile bit   bACTIVITY@UIR.ACTVIF;
volatile bit   bTOK_DONE@UIR.TRNIF;

//BUFFER REGISTERS
//NAMING CONVENTION bdNXXXXDP  where 
//N is endpoint# = 0,1,2,3
//XXXX is the type: stat, cnt, adrl or adrh
//D is direction=i,o (in,out) 
//P is pingpong=e,o  (even,odd)
/* non-pingpong buffering, 8 byte buffers*/
char bd0statoe@0x400;
char bd0cntoe@0x401=8;
0E68  0E08      	MOVLW 0x08
0E6A  0104      	MOVLB 0x04
0E6C  6F01      	MOVWF gbl_bd0cntoe, 1

char bd0adrloe@0x402 =0x00;
0E6E  6B02      	CLRF gbl_bd0adrloe, 1

char bd0adrhoe@0x403 =0x05;
0E70  0E05      	MOVLW 0x05
0E72  6F03      	MOVWF gbl_bd0adrhoe, 1


char bd0statie@0x404;
char bd0cntie@0x405=8;
0E74  0E08      	MOVLW 0x08
0E76  6F05      	MOVWF gbl_bd0cntie, 1

char bd0adrlie@0x406= 0x80;
0E78  0E80      	MOVLW 0x80
0E7A  6F06      	MOVWF gbl_bd0adrlie, 1

char bd0adrhie@0x407=0x05;
0E7C  0E05      	MOVLW 0x05
0E7E  6F07      	MOVWF gbl_bd0adrhie, 1


char bd1statoe@0x408;
char bd1cntoe@0x409=8;
0E80  0E08      	MOVLW 0x08
0E82  6F09      	MOVWF gbl_bd1cntoe, 1

char bd1adrloe@0x40A =0x00;
0E84  6B0A      	CLRF gbl_bd1adrloe, 1

char bd1adrhoe@0x40B=0x06;
0E86  0E06      	MOVLW 0x06
0E88  6F0B      	MOVWF gbl_bd1adrhoe, 1


char bd1statie@0x40C;
char bd1cntie@0x40D=8;
0E8A  0E08      	MOVLW 0x08
0E8C  6F0D      	MOVWF gbl_bd1cntie, 1

char bd1adrlie@0x40E=0x80;
0E8E  0E80      	MOVLW 0x80
0E90  6F0E      	MOVWF gbl_bd1adrlie, 1

char bd1adrhie@0x40F=0x06;
0E92  0E06      	MOVLW 0x06
0E94  6F0F      	MOVWF gbl_bd1adrhie, 1


char bd2statoe@0x410;
char bd2cntoe@0x411=8;
0E96  0E08      	MOVLW 0x08
0E98  6F11      	MOVWF gbl_bd2cntoe, 1

char bd2adrloe@0x412 =0x00;
0E9A  6B12      	CLRF gbl_bd2adrloe, 1

char bd2adrhoe@0x413 =0x07;
0E9C  0E07      	MOVLW 0x07
0E9E  6F13      	MOVWF gbl_bd2adrhoe, 1


char bd2statie@0x414;
char bd2cntie@0x415=8;
0EA0  0E08      	MOVLW 0x08
0EA2  6F15      	MOVWF gbl_bd2cntie, 1

char bd2adrlie@0x416= 0x80;
0EA4  0E80      	MOVLW 0x80
0EA6  6F16      	MOVWF gbl_bd2adrlie, 1

char bd2adrhie@0x417=0x07;
0EA8  0E07      	MOVLW 0x07
0EAA  6F17      	MOVWF gbl_bd2adrhie, 1



#endif //_PICUSBJIGGLER_H_

//###########################################################################
// filename:		usbtestCC.c
//##########################################################################
// The Irritating Mouse - This program causes the mouse pointer to move in a 
//                        figure 8 (infinity) shape
//   CC indicates changes from original Circuit Cellar source
//
// Author:	                Copyright 2005 by Robert Lang		
// Building on the work of: Reston Condit
//                          Dan Butler
//                          Andrew Smallridge
//
// Revision:		1.1 
// Date:		January 2005
// Compiled using:	BOOSTC 1.93
//
// Revision History:
//   1.0 Initial development and conversion to BOOSTC and PIC18F2455 based on 
//       program "Mouse in a circle" example
//   1.1 Added serial port for debugging messages
//
// Comments:
// bXXX indicate specific bits in registers defined in usb_defs.h
// usb buffers are defined in usbdefs.h

//################################################################################
//
// include files:
#include "system.h" //pic definition files required by boostc
#include "PICUsbJiggler.h" 

// Configuration registers
// FOSC3:FOSC0 = HSPLL PLLDIV2:PLLDIV0 = 0, CPUDIV1:CPUDIV0 = 10 (/4)
#pragma DATA    _CONFIG1L, 00110000b // USBDIV on, CPU divide by 4, PLL direct
#pragma DATA    _CONFIG1H, 00001110b // disable oscillator switchover, disable failsafe clock monitor, HSPLL
#pragma DATA    _CONFIG2L, 00111110b // USB voltage regulator enabled, brownout set for 2.1 volts, hardware brownout only, PWRT enabled
#pragma DATA    _CONFIG2H, 00011110b // Watchdog timer disabled
#pragma DATA    _CONFIG3H, 00000000b // MCLR disabled, RB4:RB0 digital on POR
#pragma DATA    _CONFIG4L, 10000000b // Debug off, extended instructions disabled, LVP disabled, disable stack full/underflow reset
#pragma DATA    _CONFIG5L, 00001111b // Read code protection off
#pragma DATA    _CONFIG5H, 11000000b // Read EEPROM and boot block protection off
#pragma DATA    _CONFIG6L, 00001111b // Write code protection off
#pragma DATA    _CONFIG6H, 11100000b // Write EEPROM, boot block and config register protection off
#pragma DATA    _CONFIG7L, 00001111b // Table read protection off
#pragma DATA    _CONFIG7H, 01000000b // Boot block table read protection off

// 4 MHz crystal but the system clock is 24MHz due to CPUDIV configuration
#pragma CLOCK_FREQ 24000000

unsigned char USB_IsIdle;
unsigned char USB_status_device;
unsigned char USB_Curr_Config; 
unsigned char USB_address_pending;
unsigned char USB_dev_req;
unsigned char USB_Interface [3];
unsigned char USB_USTAT;
unsigned char ACTIVE_BUF;
unsigned char USB_protocol;
unsigned char USWSTAT;
unsigned int USB_PID_ERR   = 0; //error counters
0EAC  0100      	MOVLB 0x00
0EAE  6BD4      	CLRF gbl_USB_PID_ERR, 1
0EB0  6BD5      	CLRF gbl_USB_PID_ERR+D'1', 1

unsigned int USB_CRC5_ERR  = 0;
0EB2  6BD6      	CLRF gbl_USB_CRC5_ERR, 1
0EB4  6BD7      	CLRF gbl_USB_CRC5_ERR+D'1', 1

unsigned int USB_CRC16_ERR = 0;
0EB6  6BD8      	CLRF gbl_USB_CRC16_ERR, 1
0EB8  6BD9      	CLRF gbl_USB_CRC16_ERR+D'1', 1

unsigned int USB_DFN8_ERR  = 0;
0EBA  6BDA      	CLRF gbl_USB_DFN8_ERR, 1
0EBC  6BDB      	CLRF gbl_USB_DFN8_ERR+D'1', 1

unsigned int USB_BTO_ERR   = 0;
0EBE  6BDC      	CLRF gbl_USB_BTO_ERR, 1
0EC0  6BDD      	CLRF gbl_USB_BTO_ERR+D'1', 1

unsigned int USB_WRT_ERR   = 0;
0EC2  6BDE      	CLRF gbl_USB_WRT_ERR, 1
0EC4  6BDF      	CLRF gbl_USB_WRT_ERR+D'1', 1

unsigned int USB_OWN_ERR   = 0;
0EC6  6BE0      	CLRF gbl_USB_OWN_ERR, 1
0EC8  6BE1      	CLRF gbl_USB_OWN_ERR+D'1', 1

unsigned int USB_BTS_ERR   = 0;
0ECA  6BE2      	CLRF gbl_USB_BTS_ERR, 1
0ECC  6BE3      	CLRF gbl_USB_BTS_ERR+D'1', 1


unsigned char * EP0_start;  //ep0 pointers modified from CC
unsigned char * EP0_end;    // modified from CC
unsigned char EP0_maxLength;

struct BufferDescriptorEntry { // buffer descriptor
	unsigned char EPStat;
	unsigned char bytes;
	unsigned int address;
};

struct BufferStruct { // buffer structure
	unsigned char bmRequestType;
	unsigned char bRequest;
	unsigned int   wValue;
	unsigned int   wIndex;
	unsigned int   wLength;
};

struct BufferDescriptorEntry * BDT= (struct BufferDescriptorEntry *)0x400; 
0ECE  6BE8      	CLRF gbl_BDT, 1
0ED0  0E04      	MOVLW 0x04
0ED2  6FE9      	MOVWF gbl_BDT+D'1', 1

struct BufferStruct *  Buffer;  //define Buffer as pointer to a BufferStruct
struct BufferStruct  BufferCopy;
struct BufferDescriptorEntry BDTCopy; 

//string descriptors in unicode format
const char String0 []  = {4, STRING, 9, 4};
0ED4  0E04      	MOVLW 0x04
0ED6  6FCD      	MOVWF gbl_String0, 1
0ED8  0E03      	MOVLW 0x03
0EDA  6FCE      	MOVWF gbl_String0+D'1', 1
0EDC  0E09      	MOVLW 0x09
0EDE  6FCF      	MOVWF gbl_String0+D'2', 1
0EE0  0E04      	MOVLW 0x04
0EE2  6FD0      	MOVWF gbl_String0+D'3', 1

const char String1 [] = {20, STRING,
0EE4  0E14      	MOVLW 0x14
0EE6  6F92      	MOVWF gbl_String1, 1
0EE8  0E03      	MOVLW 0x03
0EEA  6F93      	MOVWF gbl_String1+D'1', 1

'M',0,
0EEC  0E4D      	MOVLW 0x4D
0EEE  6F94      	MOVWF gbl_String1+D'2', 1
0EF0  6B95      	CLRF gbl_String1+D'3', 1

'i',0,
0EF2  0E69      	MOVLW 0x69
0EF4  6F96      	MOVWF gbl_String1+D'4', 1
0EF6  6B97      	CLRF gbl_String1+D'5', 1

'c',0,
0EF8  0E63      	MOVLW 0x63
0EFA  6F98      	MOVWF gbl_String1+D'6', 1
0EFC  6B99      	CLRF gbl_String1+D'7', 1

'r',0,
0EFE  0E72      	MOVLW 0x72
0F00  6F9A      	MOVWF gbl_String1+D'8', 1
0F02  6B9B      	CLRF gbl_String1+D'9', 1

'o',0,
0F04  0E6F      	MOVLW 0x6F
0F06  6F9C      	MOVWF gbl_String1+D'10', 1
0F08  6B9D      	CLRF gbl_String1+D'11', 1

'c',0,
0F0A  0E63      	MOVLW 0x63
0F0C  6F9E      	MOVWF gbl_String1+D'12', 1
0F0E  6B9F      	CLRF gbl_String1+D'13', 1

'h',0,
0F10  0E68      	MOVLW 0x68
0F12  6FA0      	MOVWF gbl_String1+D'14', 1
0F14  6BA1      	CLRF gbl_String1+D'15', 1

'i',0,
0F16  0E69      	MOVLW 0x69
0F18  6FA2      	MOVWF gbl_String1+D'16', 1
0F1A  6BA3      	CLRF gbl_String1+D'17', 1

'p',0};
0F1C  0E70      	MOVLW 0x70
0F1E  6FA4      	MOVWF gbl_String1+D'18', 1
0F20  6BA5      	CLRF gbl_String1+D'19', 1

const char String2[] = {56,STRING,
0F22  0E38      	MOVLW 0x38
0F24  6E05      	MOVWF gbl_String2
0F26  0E03      	MOVLW 0x03
0F28  6E06      	MOVWF gbl_String2+D'1'

'P',0,
0F2A  0E50      	MOVLW 0x50
0F2C  6E07      	MOVWF gbl_String2+D'2'
0F2E  6A08      	CLRF gbl_String2+D'3'

'i',0,
0F30  0E69      	MOVLW 0x69
0F32  6E09      	MOVWF gbl_String2+D'4'
0F34  6A0A      	CLRF gbl_String2+D'5'

'c',0,
0F36  0E63      	MOVLW 0x63
0F38  6E0B      	MOVWF gbl_String2+D'6'
0F3A  6A0C      	CLRF gbl_String2+D'7'

'1',0,
0F3C  0E31      	MOVLW 0x31
0F3E  6E0D      	MOVWF gbl_String2+D'8'
0F40  6A0E      	CLRF gbl_String2+D'9'

'8',0,
0F42  0E38      	MOVLW 0x38
0F44  6E0F      	MOVWF gbl_String2+D'10'
0F46  6A10      	CLRF gbl_String2+D'11'

'F',0,
0F48  0E46      	MOVLW 0x46
0F4A  6E11      	MOVWF gbl_String2+D'12'
0F4C  6A12      	CLRF gbl_String2+D'13'

'2',0,
0F4E  0E32      	MOVLW 0x32
0F50  6E13      	MOVWF gbl_String2+D'14'
0F52  6A14      	CLRF gbl_String2+D'15'

'5',0,
0F54  0E35      	MOVLW 0x35
0F56  6E15      	MOVWF gbl_String2+D'16'
0F58  6A16      	CLRF gbl_String2+D'17'

'5',0,
0F5A  0E35      	MOVLW 0x35
0F5C  6E17      	MOVWF gbl_String2+D'18'
0F5E  6A18      	CLRF gbl_String2+D'19'

'0',0,
0F60  0E30      	MOVLW 0x30
0F62  6E19      	MOVWF gbl_String2+D'20'
0F64  6A1A      	CLRF gbl_String2+D'21'

' ',0,
0F66  0E20      	MOVLW 0x20
0F68  6E1B      	MOVWF gbl_String2+D'22'
0F6A  6A1C      	CLRF gbl_String2+D'23'

'I',0,
0F6C  0E49      	MOVLW 0x49
0F6E  6E1D      	MOVWF gbl_String2+D'24'
0F70  6A1E      	CLRF gbl_String2+D'25'

'r',0,
0F72  0E72      	MOVLW 0x72
0F74  6E1F      	MOVWF gbl_String2+D'26'
0F76  6A20      	CLRF gbl_String2+D'27'

'r',0,
0F78  0E72      	MOVLW 0x72
0F7A  6E21      	MOVWF gbl_String2+D'28'
0F7C  6A22      	CLRF gbl_String2+D'29'

'i',0,
0F7E  0E69      	MOVLW 0x69
0F80  6E23      	MOVWF gbl_String2+D'30'
0F82  6A24      	CLRF gbl_String2+D'31'

't',0,
0F84  0E74      	MOVLW 0x74
0F86  6E25      	MOVWF gbl_String2+D'32'
0F88  6A26      	CLRF gbl_String2+D'33'

'a',0,
0F8A  0E61      	MOVLW 0x61
0F8C  6E27      	MOVWF gbl_String2+D'34'
0F8E  6A28      	CLRF gbl_String2+D'35'

't',0,
0F90  0E74      	MOVLW 0x74
0F92  6E29      	MOVWF gbl_String2+D'36'
0F94  6A2A      	CLRF gbl_String2+D'37'

'i',0,
0F96  0E69      	MOVLW 0x69
0F98  6E2B      	MOVWF gbl_String2+D'38'
0F9A  6A2C      	CLRF gbl_String2+D'39'

'n',0,
0F9C  0E6E      	MOVLW 0x6E
0F9E  6E2D      	MOVWF gbl_String2+D'40'
0FA0  6A2E      	CLRF gbl_String2+D'41'

'g',0,
0FA2  0E67      	MOVLW 0x67
0FA4  6E2F      	MOVWF gbl_String2+D'42'
0FA6  6A30      	CLRF gbl_String2+D'43'

' ',0, 
0FA8  0E20      	MOVLW 0x20
0FAA  6E31      	MOVWF gbl_String2+D'44'
0FAC  6A32      	CLRF gbl_String2+D'45'

'M',0,
0FAE  0E4D      	MOVLW 0x4D
0FB0  6E33      	MOVWF gbl_String2+D'46'
0FB2  6A34      	CLRF gbl_String2+D'47'

'o',0,
0FB4  0E6F      	MOVLW 0x6F
0FB6  6E35      	MOVWF gbl_String2+D'48'
0FB8  6A36      	CLRF gbl_String2+D'49'

'u',0,
0FBA  0E75      	MOVLW 0x75
0FBC  6E37      	MOVWF gbl_String2+D'50'
0FBE  6A38      	CLRF gbl_String2+D'51'

's',0,
0FC0  0E73      	MOVLW 0x73
0FC2  6E39      	MOVWF gbl_String2+D'52'
0FC4  6A3A      	CLRF gbl_String2+D'53'

'e',0};
0FC6  0E65      	MOVLW 0x65
0FC8  6E3B      	MOVWF gbl_String2+D'54'
0FCA  6A3C      	CLRF gbl_String2+D'55'


// Report descriptor prepared by USB DESCRIPTOR TOOL
// http://www.usb.org/developers/hidpage/#Descriptor_Tool
const char ReportDescriptor1[] = {
   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
0FCC  0E05      	MOVLW 0x05
0FCE  6F60      	MOVWF gbl_ReportDescriptor1, 1
0FD0  0E01      	MOVLW 0x01
0FD2  6F61      	MOVWF gbl_ReportDescriptor1+D'1', 1

   0x09, 0x02,                    //  USAGE (Mouse)
0FD4  0E09      	MOVLW 0x09
0FD6  6F62      	MOVWF gbl_ReportDescriptor1+D'2', 1
0FD8  0E02      	MOVLW 0x02
0FDA  6F63      	MOVWF gbl_ReportDescriptor1+D'3', 1

   0xa1, 0x01,                    //  COLLECTION (Application)
0FDC  0EA1      	MOVLW 0xA1
0FDE  6F64      	MOVWF gbl_ReportDescriptor1+D'4', 1
0FE0  0E01      	MOVLW 0x01
0FE2  6F65      	MOVWF gbl_ReportDescriptor1+D'5', 1

   0x09, 0x01,                    //  USAGE (Pointer)
0FE4  0E09      	MOVLW 0x09
0FE6  6F66      	MOVWF gbl_ReportDescriptor1+D'6', 1
0FE8  0E01      	MOVLW 0x01
0FEA  6F67      	MOVWF gbl_ReportDescriptor1+D'7', 1

   0xa1, 0x00,                    //  COLLECTION (Physical)
0FEC  0EA1      	MOVLW 0xA1
0FEE  6F68      	MOVWF gbl_ReportDescriptor1+D'8', 1
0FF0  6B69      	CLRF gbl_ReportDescriptor1+D'9', 1

   0x05, 0x09,                    //  USAGE_PAGE (Button)
0FF2  0E05      	MOVLW 0x05
0FF4  6F6A      	MOVWF gbl_ReportDescriptor1+D'10', 1
0FF6  0E09      	MOVLW 0x09
0FF8  6F6B      	MOVWF gbl_ReportDescriptor1+D'11', 1

   0x19, 0x01,                    //  USAGE_MINIMUM (Button 1)
0FFA  0E19      	MOVLW 0x19
0FFC  6F6C      	MOVWF gbl_ReportDescriptor1+D'12', 1
0FFE  0E01      	MOVLW 0x01
1000  6F6D      	MOVWF gbl_ReportDescriptor1+D'13', 1

   0x29, 0x03,                    //  USAGE_MAXIMUM (Button 3)
1002  0E29      	MOVLW 0x29
1004  6F6E      	MOVWF gbl_ReportDescriptor1+D'14', 1
1006  0E03      	MOVLW 0x03
1008  6F6F      	MOVWF gbl_ReportDescriptor1+D'15', 1

   0x15, 0x00,                    //  LOGICAL_MINIMUM (0)
100A  0E15      	MOVLW 0x15
100C  6F70      	MOVWF gbl_ReportDescriptor1+D'16', 1
100E  6B71      	CLRF gbl_ReportDescriptor1+D'17', 1

   0x25, 0x01,                    //  LOGICAL_MAXIMUM (1)
1010  0E25      	MOVLW 0x25
1012  6F72      	MOVWF gbl_ReportDescriptor1+D'18', 1
1014  0E01      	MOVLW 0x01
1016  6F73      	MOVWF gbl_ReportDescriptor1+D'19', 1

   0x95, 0x03,                    //  REPORT_COUNT (3)
1018  0E95      	MOVLW 0x95
101A  6F74      	MOVWF gbl_ReportDescriptor1+D'20', 1
101C  0E03      	MOVLW 0x03
101E  6F75      	MOVWF gbl_ReportDescriptor1+D'21', 1

   0x75, 0x01,                    //  REPORT_SIZE (1)
1020  0E75      	MOVLW 0x75
1022  6F76      	MOVWF gbl_ReportDescriptor1+D'22', 1
1024  0E01      	MOVLW 0x01
1026  6F77      	MOVWF gbl_ReportDescriptor1+D'23', 1

   0x81, 0x02,                    //  INPUT (Data,Var,Abs)
1028  0E81      	MOVLW 0x81
102A  6F78      	MOVWF gbl_ReportDescriptor1+D'24', 1
102C  0E02      	MOVLW 0x02
102E  6F79      	MOVWF gbl_ReportDescriptor1+D'25', 1

   0x95, 0x01,                    //  REPORT_COUNT (1)
1030  0E95      	MOVLW 0x95
1032  6F7A      	MOVWF gbl_ReportDescriptor1+D'26', 1
1034  0E01      	MOVLW 0x01
1036  6F7B      	MOVWF gbl_ReportDescriptor1+D'27', 1

   0x75, 0x05,                    //  REPORT_SIZE (5)
1038  0E75      	MOVLW 0x75
103A  6F7C      	MOVWF gbl_ReportDescriptor1+D'28', 1
103C  0E05      	MOVLW 0x05
103E  6F7D      	MOVWF gbl_ReportDescriptor1+D'29', 1

   0x81, 0x01,                    //  INPUT (Cnst,Ary,Abs)
1040  0E81      	MOVLW 0x81
1042  6F7E      	MOVWF gbl_ReportDescriptor1+D'30', 1
1044  0E01      	MOVLW 0x01
1046  6F7F      	MOVWF gbl_ReportDescriptor1+D'31', 1

   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
1048  0E05      	MOVLW 0x05
104A  6F80      	MOVWF gbl_ReportDescriptor1+D'32', 1
104C  0E01      	MOVLW 0x01
104E  6F81      	MOVWF gbl_ReportDescriptor1+D'33', 1

   0x09, 0x30,                    //  USAGE (X)
1050  0E09      	MOVLW 0x09
1052  6F82      	MOVWF gbl_ReportDescriptor1+D'34', 1
1054  0E30      	MOVLW 0x30
1056  6F83      	MOVWF gbl_ReportDescriptor1+D'35', 1

   0x09, 0x31,                    //  USAGE (Y)
1058  0E09      	MOVLW 0x09
105A  6F84      	MOVWF gbl_ReportDescriptor1+D'36', 1
105C  0E31      	MOVLW 0x31
105E  6F85      	MOVWF gbl_ReportDescriptor1+D'37', 1

   0x15, 0x81,                    //  LOGICAL_MINIMUM (-127)
1060  0E15      	MOVLW 0x15
1062  6F86      	MOVWF gbl_ReportDescriptor1+D'38', 1
1064  0E81      	MOVLW 0x81
1066  6F87      	MOVWF gbl_ReportDescriptor1+D'39', 1

   0x25, 0x7f,                    //  LOGICAL_MAXIMUM (127)
1068  0E25      	MOVLW 0x25
106A  6F88      	MOVWF gbl_ReportDescriptor1+D'40', 1
106C  0E7F      	MOVLW 0x7F
106E  6F89      	MOVWF gbl_ReportDescriptor1+D'41', 1

   0x75, 0x08,                    //  REPORT_SIZE (8)
1070  0E75      	MOVLW 0x75
1072  6F8A      	MOVWF gbl_ReportDescriptor1+D'42', 1
1074  0E08      	MOVLW 0x08
1076  6F8B      	MOVWF gbl_ReportDescriptor1+D'43', 1

   0x95, 0x02,                    //  REPORT_COUNT (2)
1078  0E95      	MOVLW 0x95
107A  6F8C      	MOVWF gbl_ReportDescriptor1+D'44', 1
107C  0E02      	MOVLW 0x02
107E  6F8D      	MOVWF gbl_ReportDescriptor1+D'45', 1

   0x81, 0x06,                    //  INPUT (Data,Var,Rel)
1080  0E81      	MOVLW 0x81
1082  6F8E      	MOVWF gbl_ReportDescriptor1+D'46', 1
1084  0E06      	MOVLW 0x06
1086  6F8F      	MOVWF gbl_ReportDescriptor1+D'47', 1

   0xc0,                          //  END_COLLECTION
1088  0EC0      	MOVLW 0xC0
108A  6F90      	MOVWF gbl_ReportDescriptor1+D'48', 1

   0xc0                           //  END_COLLECTION
108C  0EC0      	MOVLW 0xC0
108E  6F91      	MOVWF gbl_ReportDescriptor1+D'49', 1

};

const char DeviceDescriptor [] = {
    0x12, // 18 bytes long 
1090  0E12      	MOVLW 0x12
1092  6FA6      	MOVWF gbl_DeviceDescriptor, 1

    DEVICE, // descriptor type
1094  0E01      	MOVLW 0x01
1096  6FA7      	MOVWF gbl_DeviceDescriptor+D'1', 1

    0x10, 0x01, // USB specification release (1.10)
1098  0E10      	MOVLW 0x10
109A  6FA8      	MOVWF gbl_DeviceDescriptor+D'2', 1
109C  0E01      	MOVLW 0x01
109E  6FA9      	MOVWF gbl_DeviceDescriptor+D'3', 1

    0x00, // class code
10A0  6BAA      	CLRF gbl_DeviceDescriptor+D'4', 1

    0x00, // subclass code
10A2  6BAB      	CLRF gbl_DeviceDescriptor+D'5', 1

    0x00, // protocol code
10A4  6BAC      	CLRF gbl_DeviceDescriptor+D'6', 1

    0x08, // maximum packet size
10A6  0E08      	MOVLW 0x08
10A8  6FAD      	MOVWF gbl_DeviceDescriptor+D'7', 1

    0xD8,0x04, // vendor id (04d8) microchip
10AA  0ED8      	MOVLW 0xD8
10AC  6FAE      	MOVWF gbl_DeviceDescriptor+D'8', 1
10AE  0E04      	MOVLW 0x04
10B0  6FAF      	MOVWF gbl_DeviceDescriptor+D'9', 1

    0x09,0x00, //product id (0009)
10B2  0E09      	MOVLW 0x09
10B4  6FB0      	MOVWF gbl_DeviceDescriptor+D'10', 1
10B6  6BB1      	CLRF gbl_DeviceDescriptor+D'11', 1

    0x00,0x02, // device release number 2.00
10B8  6BB2      	CLRF gbl_DeviceDescriptor+D'12', 1
10BA  0E02      	MOVLW 0x02
10BC  6FB3      	MOVWF gbl_DeviceDescriptor+D'13', 1

    0x01, // index to string that describes vendor
10BE  0E01      	MOVLW 0x01
10C0  6FB4      	MOVWF gbl_DeviceDescriptor+D'14', 1

    0x02, // index to string that describes product
10C2  0E02      	MOVLW 0x02
10C4  6FB5      	MOVWF gbl_DeviceDescriptor+D'15', 1

    0x00, // index to string that describes serial number (none)
10C6  6BB6      	CLRF gbl_DeviceDescriptor+D'16', 1

    0x01  // number of possible configurations
10C8  0E01      	MOVLW 0x01
10CA  6FB7      	MOVWF gbl_DeviceDescriptor+D'17', 1

};

//CONFIG DESCRIPTOR ORDER CORRESPONDS TO HID 1.0 OR LATER
const char ConfigDescriptor [] = {
    0x09, // 9 bytes long
10CC  0E09      	MOVLW 0x09
10CE  6E3D      	MOVWF gbl_ConfigDescriptor

    CONFIGURATION, // descriptor type
10D0  0E02      	MOVLW 0x02
10D2  6E3E      	MOVWF gbl_ConfigDescriptor+D'1'

    0x22, 0x00, // total length of config, interface, HID and endpoint descriptors
10D4  0E22      	MOVLW 0x22
10D6  6E3F      	MOVWF gbl_ConfigDescriptor+D'2'
10D8  6A40      	CLRF gbl_ConfigDescriptor+D'3'

    0x01, // number of interfaces
10DA  0E01      	MOVLW 0x01
10DC  6E41      	MOVWF gbl_ConfigDescriptor+D'4'

    0x01, // configuration number
10DE  0E01      	MOVLW 0x01
10E0  6E42      	MOVWF gbl_ConfigDescriptor+D'5'

    0x00, // index to string that describes configuration (none)
10E2  6A43      	CLRF gbl_ConfigDescriptor+D'6'

    0xA0, // configuration attributes , remote wakeup
10E4  0EA0      	MOVLW 0xA0
10E6  6E44      	MOVWF gbl_ConfigDescriptor+D'7'

    0x32, // current consumption in 2mA units (100 mA) 
10E8  0E32      	MOVLW 0x32
10EA  6E45      	MOVWF gbl_ConfigDescriptor+D'8'

    /* Interface Descriptor  */      0x09,// 9 bytes long
10EC  0E09      	MOVLW 0x09
10EE  6E46      	MOVWF gbl_ConfigDescriptor+D'9'

    INTERFACE, // descriptor type
10F0  0E04      	MOVLW 0x04
10F2  6E47      	MOVWF gbl_ConfigDescriptor+D'10'

    0x00, // number of this interface (zerp based)
10F4  6A48      	CLRF gbl_ConfigDescriptor+D'11'

    0x00, // alternate setting (none)
10F6  6A49      	CLRF gbl_ConfigDescriptor+D'12'

    0x01, // number of endpoints used by interface
10F8  0E01      	MOVLW 0x01
10FA  6E4A      	MOVWF gbl_ConfigDescriptor+D'13'

    0x03, // class code
10FC  0E03      	MOVLW 0x03
10FE  6E4B      	MOVWF gbl_ConfigDescriptor+D'14'

    0x01, // subclass code
1100  0E01      	MOVLW 0x01
1102  6E4C      	MOVWF gbl_ConfigDescriptor+D'15'

    0x02, // protocol 
1104  0E02      	MOVLW 0x02
1106  6E4D      	MOVWF gbl_ConfigDescriptor+D'16'

    0x00, // index to string that describes endpoint (none)
1108  6A4E      	CLRF gbl_ConfigDescriptor+D'17'

    /* HID descriptor described above */     
    0x09, 0x21, 0x10, 0x01, 0x00, 0x01, 0x22, sizeof(ReportDescriptor1), sizeof(ReportDescriptor1)>>8,
110A  0E09      	MOVLW 0x09
110C  6E4F      	MOVWF gbl_ConfigDescriptor+D'18'
110E  0E21      	MOVLW 0x21
1110  6E50      	MOVWF gbl_ConfigDescriptor+D'19'
1112  0E10      	MOVLW 0x10
1114  6E51      	MOVWF gbl_ConfigDescriptor+D'20'
1116  0E01      	MOVLW 0x01
1118  6E52      	MOVWF gbl_ConfigDescriptor+D'21'
111A  6A53      	CLRF gbl_ConfigDescriptor+D'22'
111C  0E01      	MOVLW 0x01
111E  6E54      	MOVWF gbl_ConfigDescriptor+D'23'
1120  0E22      	MOVLW 0x22
1122  6E55      	MOVWF gbl_ConfigDescriptor+D'24'
1124  0E32      	MOVLW 0x32
1126  6E56      	MOVWF gbl_ConfigDescriptor+D'25'
1128  6A57      	CLRF gbl_ConfigDescriptor+D'26'

    /* Endpoint 1 descriptor */       0x07, // 7 bytes long
112A  0E07      	MOVLW 0x07
112C  6E58      	MOVWF gbl_ConfigDescriptor+D'27'

    ENDPOINT, // descriptor type
112E  0E05      	MOVLW 0x05
1130  6E59      	MOVWF gbl_ConfigDescriptor+D'28'

    0x81, // endpoint characteristics (IN endpoint)
1132  0E81      	MOVLW 0x81
1134  6E5A      	MOVWF gbl_ConfigDescriptor+D'29'

    0x03, // endpoint attributes  (interrupt)
1136  0E03      	MOVLW 0x03
1138  6E5B      	MOVWF gbl_ConfigDescriptor+D'30'

    0x03, 0x00, // max packet size (HID 3 byte report)
113A  0E03      	MOVLW 0x03
113C  6E5C      	MOVWF gbl_ConfigDescriptor+D'31'
113E  6A5D      	CLRF gbl_ConfigDescriptor+D'32'

    0x0A //polling interval in 1 msec increments (10)
1140  0E0A      	MOVLW 0x0A
1142  6E5E      	MOVWF gbl_ConfigDescriptor+D'33'

};

const unsigned int ReportDescrSize = sizeof(ReportDescriptor1);
1144  0E32      	MOVLW 0x32
1146  6FEC      	MOVWF gbl_ReportDescrSize, 1
1148  6BED      	CLRF gbl_ReportDescrSize+D'1', 1

const char  HIDDescriptor [] =    {
    0x09, // 9 bytes long
114A  0E09      	MOVLW 0x09
114C  6FB8      	MOVWF gbl_HIDDescriptor, 1

    0x21, // descriptor type, HID=21
114E  0E21      	MOVLW 0x21
1150  6FB9      	MOVWF gbl_HIDDescriptor+D'1', 1

    0x10, 0x01,  // HUD class version 1.10
1152  0E10      	MOVLW 0x10
1154  6FBA      	MOVWF gbl_HIDDescriptor+D'2', 1
1156  0E01      	MOVLW 0x01
1158  6FBB      	MOVWF gbl_HIDDescriptor+D'3', 1

    0x00, // country code (none)
115A  6BBC      	CLRF gbl_HIDDescriptor+D'4', 1

    0x01, // Number of HID class descriptors
115C  0E01      	MOVLW 0x01
115E  6FBD      	MOVWF gbl_HIDDescriptor+D'5', 1

    0x22, // Type of class descriptor (report)
1160  0E22      	MOVLW 0x22
1162  6FBE      	MOVWF gbl_HIDDescriptor+D'6', 1

    sizeof(ReportDescriptor1), sizeof(ReportDescriptor1)>>8  // Size of report descriptor
1164  0E32      	MOVLW 0x32
1166  6FBF      	MOVWF gbl_HIDDescriptor+D'7', 1
1168  6BC0      	CLRF gbl_HIDDescriptor+D'8', 1

};

/* PutEP1 **************************************************************** */
/* Tests the EP1 IN OWNS bit.  If there is a buffer available to us, your  */
/* buffer is copied and turned over to the SIE for transmission on the     */
/* next IN transfer and returns TRUE (1).  If the buffer is not available, */
/* FALSE is returned (0).                                                  */
/* *********************************************************************** */
unsigned char PutEP1(unsigned char bytes, signed char *buffer) {

	signed char * tobuffer;
	unsigned char i;

	ddrb = 0; //setup b for output
0C5C  6A93      	CLRF gbl_ddrb


	if ((bd1statie & 0x80) == 0) { /* do we own the buffer? UOWN=0*/
0C5E  0E80      	MOVLW 0x80
0C60  0104      	MOVLB 0x04
0C62  150C      	ANDWF gbl_bd1statie, W, 1
0C64  0101      	MOVLB 0x01
0C66  6F21      	MOVWF CompTempVar570, 1
0C68  5321      	MOVF CompTempVar570, F, 1
0C6A  E13A      	BNZ	label113
0CE0            label113

		bd1cntie = bytes;
0C6C  0100      	MOVLB 0x00
0C6E  51FE      	MOVF PutEP1_00000_arg_bytes, W, 1
0C70  0104      	MOVLB 0x04
0C72  6F0D      	MOVWF gbl_bd1cntie, 1

        tobuffer = (signed char *) ((unsigned int)bd1adrlie + (unsigned int)(bd1adrhie <<8));
0C74  510E      	MOVF gbl_bd1adrlie, W, 1
0C76  0101      	MOVLB 0x01
0C78  6F1F      	MOVWF PutEP1_00000_1_tobuffer, 1
0C7A  6B23      	CLRF CompTempVar573+D'1', 1
0C7C  6B24      	CLRF CompTempVar574, 1
0C7E  0104      	MOVLB 0x04
0C80  510F      	MOVF gbl_bd1adrhie, W, 1
0C82  0101      	MOVLB 0x01
0C84  6F20      	MOVWF PutEP1_00000_1_tobuffer+D'1', 1
0C86  5124      	MOVF CompTempVar574, W, 1
0C88  271F      	ADDWF PutEP1_00000_1_tobuffer, F, 1
0C8A  5123      	MOVF CompTempVar573+D'1', W, 1
0C8C  2320      	ADDWFC PutEP1_00000_1_tobuffer+D'1', F, 1


		for (i = 0; i < bytes; i++) {
0C8E  0100      	MOVLB 0x00
0C90  6BFF      	CLRF PutEP1_00000_1_i, 1
0C92            label111
0C92  51FE      	MOVF PutEP1_00000_arg_bytes, W, 1
0C94  61FF      	CPFSLT PutEP1_00000_1_i, 1
0C96  D019      	BRA	label112
0CC4  0100      	MOVLB 0x00
0CC6  2BFF      	INCF PutEP1_00000_1_i, F, 1
0CC8  D7E4      	BRA	label111
0CCA            label112

	        tobuffer[i] = buffer[i];
0C98  0101      	MOVLB 0x01
0C9A  511E      	MOVF PutEP1_00000_arg_buffer+D'1', W, 1
0C9C  6EEA      	MOVWF FSR0H
0C9E  511D      	MOVF PutEP1_00000_arg_buffer, W, 1
0CA0  6EE9      	MOVWF FSR0L
0CA2  0100      	MOVLB 0x00
0CA4  51FF      	MOVF PutEP1_00000_1_i, W, 1
0CA6  0101      	MOVLB 0x01
0CA8  6F22      	MOVWF CompTempVar578, 1
0CAA  5122      	MOVF CompTempVar578, W, 1
0CAC  26E9      	ADDWF FSR0L, F
0CAE  50EF      	MOVF INDF0, W
0CB0  6F23      	MOVWF CompTempVar579, 1
0CB2  5120      	MOVF PutEP1_00000_1_tobuffer+D'1', W, 1
0CB4  6EEA      	MOVWF FSR0H
0CB6  511F      	MOVF PutEP1_00000_1_tobuffer, W, 1
0CB8  0100      	MOVLB 0x00
0CBA  25FF      	ADDWF PutEP1_00000_1_i, W, 1
0CBC  6EE9      	MOVWF FSR0L
0CBE  0101      	MOVLB 0x01
0CC0  5123      	MOVF CompTempVar579, W, 1
0CC2  6EEF      	MOVWF INDF0

		}

	    bd1statie &= 0x40; /* save only the Data 1/0 bit */
0CCA  0E40      	MOVLW 0x40
0CCC  0104      	MOVLB 0x04
0CCE  170C      	ANDWF gbl_bd1statie, F, 1

	    bd1statie ^= 0x40; /* toggle Data 0/1 bit */
0CD0  0E40      	MOVLW 0x40
0CD2  1B0C      	XORWF gbl_bd1statie, F, 1

	    bd1statie ^= 0x88; /* release buffer */ 
0CD4  0E88      	MOVLW 0x88
0CD6  1B0C      	XORWF gbl_bd1statie, F, 1

		return TRUE;
0CD8  0E01      	MOVLW 0x01
0CDA  0101      	MOVLB 0x01
0CDC  6F22      	MOVWF CompTempVarRet569, 1

	}
	return FALSE;	/* Buffer not available, return false */
0CE0  6B22      	CLRF CompTempVarRet569, 1

}
0CDE  0012      	RETURN
0CE2  0012      	RETURN


/* ********************************************************************* */
/* Enable Wakeup on interupt and Activity interrupt then put the         */
/* device to sleep to save power.  Activity on the D+/D- lines will      */
/* set the ACTIVITY interrupt, waking up the part.                       */
/* ********************************************************************* */
void USBSleep() {

	bACTIVITY_E = 1; // enable activity interrupt
013C  8469      	BSF gbl_bACTIVITY_E,2

	bUIDLE = 0; //disable idle interrupt
013E  9869      	BCF gbl_bUIDLE,4

	bSUSPND	= 1;  // put in suspend mode
0140  826D      	BSF gbl_bSUSPND,1

	USB_IsIdle = 1; // mark device as idle
0142  0E01      	MOVLW 0x01
0144  0100      	MOVLB 0x00
0146  6FEE      	MOVWF gbl_USB_IsIdle, 1

}
0148  0012      	RETURN


/* ********************************************************************* */
/* Service the Activity Interrupt.  This is only enabled when the        */
/* device is put to sleep as a result of inactivity on the bus.  This    */
/* code wakes up the part, disables the activity interrupt and reenables */
/* the idle interrupt.                                                   */
/* ********************************************************************* */
void USBActivity() {

	bACTIVITY = 0;
00AA  9468      	BCF gbl_bACTIVITY,2

	bACTIVITY_E = 0;
00AC  9469      	BCF gbl_bACTIVITY_E,2

	bSUSPND = 0; //normal operation
00AE  926D      	BCF gbl_bSUSPND,1

	USB_IsIdle = 0;
00B0  0100      	MOVLB 0x00
00B2  6BEE      	CLRF gbl_USB_IsIdle, 1

}
00B4  0012      	RETURN


/* ****************************************************************** */
/* USB Reset interrupt triggered (SE0)                                */
/* initialize the Buffer Descriptor Table,                            */
/* Transition to the DEFAULT state,                                   */
/* Set address to 0                                                   */
/* enable the USB                                                     */
/* ****************************************************************** */
void USBReset() {

	portb = 1;		// Lite led 0 to indicate Reset status
0074  0E01      	MOVLW 0x01
0076  6E81      	MOVWF gbl_portb

	USB_Curr_Config = 0;
0078  0100      	MOVLB 0x00
007A  6BF0      	CLRF gbl_USB_Curr_Config, 1

	USB_IsIdle = 0;
007C  6BEE      	CLRF gbl_USB_IsIdle, 1

	bTOK_DONE = 0; // clear TOK_DNE bit in uir 4 times to 
007E  9668      	BCF gbl_bTOK_DONE,3

	bTOK_DONE = 0; // clear out the USTAT FIFO.  See Microchip 	
0080  9668      	BCF gbl_bTOK_DONE,3

	bTOK_DONE = 0; // 18F2455 data sheet.
0082  9668      	BCF gbl_bTOK_DONE,3

	bTOK_DONE = 0;
0084  9668      	BCF gbl_bTOK_DONE,3

	bd0cntoe = 8; //set up for 8 byte buffer
0086  0E08      	MOVLW 0x08
0088  0104      	MOVLB 0x04
008A  6F01      	MOVWF gbl_bd0cntoe, 1

	bd0statoe = 0x88;	// EP0 Out buffer (USB OWNS)
008C  0E88      	MOVLW 0x88
008E  6F00      	MOVWF gbl_bd0statoe, 1

	bd0statie = 0x08;    // EP0 In buffer (MCU OWNS)
0090  0E08      	MOVLW 0x08
0092  6F04      	MOVWF gbl_bd0statie, 1

	uaddr = 0; // clear address
0094  6A6E      	CLRF gbl_uaddr

	uir = 0; // clear USB interrupt flag
0096  6A68      	CLRF gbl_uir

	uie	= 00000101b; // enable reset and activity interrupt
0098  0E05      	MOVLW 0x05
009A  6E69      	MOVWF gbl_uie

	uep0 = ENDPT_CONTROL;
009C  0E16      	MOVLW 0x16
009E  6E70      	MOVWF gbl_uep0

	USWSTAT = DEFAULT_STATE;
00A0  0E01      	MOVLW 0x01
00A2  0100      	MOVLB 0x00
00A4  6FF6      	MOVWF gbl_USWSTAT, 1

	USB_status_device = 1;
00A6  6FEF      	MOVWF gbl_USB_status_device, 1

}
00A8  0012      	RETURN


/* ******************* */
/* CopyDescriptorToEP0 ************************************************** */
/* copies the next chunk of buffer descriptor over to the EP0 In buffer.  */
/* Inputs:                                                                */
/*    EP0_start - points to first byte of configuration table to transfer */
/*    EP0_end - total number of bytes to transfer                         */
/*    EP0_maxLength - maximum number of bytes that can be sent during     */
/*    a single transfer                                                   */
/*                                                                        */
/* toggles the data0/1 bit before setting the UOWN bit over to SIE.       */
/* ********************************************************************** */
void CopyDescriptorToEP0() {

	unsigned char *  USBbuffer;  /* pointer to the USB Buffers */
	unsigned char bufindex;
	USBbuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));
00B6  0104      	MOVLB 0x04
00B8  5106      	MOVF gbl_bd0adrlie, W, 1
00BA  0101      	MOVLB 0x01
00BC  6F2F      	MOVWF CopyDescri_0000B_1_USBbuffer, 1
00BE  6B33      	CLRF CompTempVar582+D'1', 1
00C0  6B34      	CLRF CompTempVar583, 1
00C2  0104      	MOVLB 0x04
00C4  5107      	MOVF gbl_bd0adrhie, W, 1
00C6  0101      	MOVLB 0x01
00C8  6F30      	MOVWF CopyDescri_0000B_1_USBbuffer+D'1', 1
00CA  5134      	MOVF CompTempVar583, W, 1
00CC  272F      	ADDWF CopyDescri_0000B_1_USBbuffer, F, 1
00CE  5133      	MOVF CompTempVar582+D'1', W, 1
00D0  2330      	ADDWFC CopyDescri_0000B_1_USBbuffer+D'1', F, 1

	bufindex  = 0;
00D2  6B31      	CLRF CopyDescri_0000B_1_bufindex, 1

    while ((bufindex < EP0_maxLength) && ((unsigned short)EP0_start <(unsigned short) EP0_end)) {
00D4            label3
00D4  0100      	MOVLB 0x00
00D6  51F7      	MOVF gbl_EP0_maxLength, W, 1
00D8  0101      	MOVLB 0x01
00DA  6131      	CPFSLT CopyDescri_0000B_1_bufindex, 1
00DC  D01B      	BRA	label5
00DE  0100      	MOVLB 0x00
00E0  51E7      	MOVF gbl_EP0_end+D'1', W, 1
00E2  5DE5      	SUBWF gbl_EP0_start+D'1', W, 1
00E4  E102      	BNZ	label4
00E6  51E6      	MOVF gbl_EP0_end, W, 1
00E8  5DE4      	SUBWF gbl_EP0_start, W, 1
00EA            label4
00EA  E214      	BC	label5
0112  D7E0      	BRA	label3
0114            label5

		USBbuffer [bufindex] = *EP0_start;
00EC  51E5      	MOVF gbl_EP0_start+D'1', W, 1
00EE  6EEA      	MOVWF FSR0H
00F0  51E4      	MOVF gbl_EP0_start, W, 1
00F2  6EE9      	MOVWF FSR0L
00F4  50EF      	MOVF INDF0, W
00F6  0101      	MOVLB 0x01
00F8  6F32      	MOVWF CompTempVar586, 1
00FA  5130      	MOVF CopyDescri_0000B_1_USBbuffer+D'1', W, 1
00FC  6EEA      	MOVWF FSR0H
00FE  512F      	MOVF CopyDescri_0000B_1_USBbuffer, W, 1
0100  2531      	ADDWF CopyDescri_0000B_1_bufindex, W, 1
0102  6EE9      	MOVWF FSR0L
0104  5132      	MOVF CompTempVar586, W, 1
0106  6EEF      	MOVWF INDF0

		++ EP0_start;
0108  0100      	MOVLB 0x00
010A  4BE4      	INFSNZ gbl_EP0_start, F, 1
010C  2BE5      	INCF gbl_EP0_start+D'1', F, 1

		++ bufindex;
010E  0101      	MOVLB 0x01
0110  2B31      	INCF CopyDescri_0000B_1_bufindex, F, 1

	}
	if (bufindex < EP0_maxLength)	/* are we sending a short packet? */
0114  0100      	MOVLB 0x00
0116  51F7      	MOVF gbl_EP0_maxLength, W, 1
0118  0101      	MOVLB 0x01
011A  6131      	CPFSLT CopyDescri_0000B_1_bufindex, 1
011C  D002      	BRA	label6
0122            label6

		USB_dev_req = 0;	/* Yes, clear the device reqest */
011E  0100      	MOVLB 0x00
0120  6BF2      	CLRF gbl_USB_dev_req, 1


	bd0cntie  = bufindex;
0122  0101      	MOVLB 0x01
0124  5131      	MOVF CopyDescri_0000B_1_bufindex, W, 1
0126  0104      	MOVLB 0x04
0128  6F05      	MOVWF gbl_bd0cntie, 1

	bd0statie &= 0x40;		/* save only the DTS bit */
012A  0E40      	MOVLW 0x40
012C  1704      	ANDWF gbl_bd0statie, F, 1

	bd0statie ^= 0x40;		/* toggle data DTS bit */
012E  0E40      	MOVLW 0x40
0130  1B04      	XORWF gbl_bd0statie, F, 1

	bd0statie |= 0x88;		/* set OWN and DTSEN bits */
0132  0E88      	MOVLW 0x88
0134  1304      	IORWF gbl_bd0statie, F, 1

}
0136  0012      	RETURN


/* ******** */
/* Init USB ********************************************************* */
/* Initializes the USB peripheral, sets up the interrupts             */
/* ****************************************************************** */
void InitUSB() {

	ucfg = 00010000b; //use onchip receiver, internal pullup resistors, low speed and no pingpong buffers
0CE4  0E10      	MOVLW 0x10
0CE6  6E6F      	MOVWF gbl_ucfg

	uie = 00000001b;	// enable the Reset interrupt ONLY!!
0CE8  0E01      	MOVLW 0x01
0CEA  6E69      	MOVWF gbl_uie

	uir = 0;	// clear all USB interrupt flags
0CEC  6A68      	CLRF gbl_uir

	pie2 = 00100000b ; // enable usb interrupts
0CEE  0E20      	MOVLW 0x20
0CF0  6EA0      	MOVWF gbl_pie2

	ucon = 01000000b;	// reset pingpong buffers
0CF2  0E40      	MOVLW 0x40
0CF4  6E6D      	MOVWF gbl_ucon

	ucon = 00001000b;	// unlock pingpong buffers and enable usb
0CF6  0E08      	MOVLW 0x08
0CF8  6E6D      	MOVWF gbl_ucon

	USB_Curr_Config = 0;
0CFA  0100      	MOVLB 0x00
0CFC  6BF0      	CLRF gbl_USB_Curr_Config, 1

	USB_status_device = 1;
0CFE  0E01      	MOVLW 0x01
0D00  6FEF      	MOVWF gbl_USB_status_device, 1

	char USB_Interface[] = {0,0,0};
0D02  0101      	MOVLB 0x01
0D04  6B1D      	CLRF InitUSB_00000_1_USB_Interface, 1
0D06  6B1E      	CLRF InitUSB_00000_1_USB_Interface+D'1', 1
0D08  6B1F      	CLRF InitUSB_00000_1_USB_Interface+D'2', 1

	USB_dev_req = NULL;
0D0A  0100      	MOVLB 0x00
0D0C  6BF2      	CLRF gbl_USB_dev_req, 1

	// clear all error counters
	USB_PID_ERR = 0;
0D0E  6BD4      	CLRF gbl_USB_PID_ERR, 1
0D10  6BD5      	CLRF gbl_USB_PID_ERR+D'1', 1

	USB_CRC5_ERR = 0;
0D12  6BD6      	CLRF gbl_USB_CRC5_ERR, 1
0D14  6BD7      	CLRF gbl_USB_CRC5_ERR+D'1', 1

	USB_CRC16_ERR = 0;
0D16  6BD8      	CLRF gbl_USB_CRC16_ERR, 1
0D18  6BD9      	CLRF gbl_USB_CRC16_ERR+D'1', 1

	USB_DFN8_ERR = 0;
0D1A  6BDA      	CLRF gbl_USB_DFN8_ERR, 1
0D1C  6BDB      	CLRF gbl_USB_DFN8_ERR+D'1', 1

	USB_BTO_ERR = 0;
0D1E  6BDC      	CLRF gbl_USB_BTO_ERR, 1
0D20  6BDD      	CLRF gbl_USB_BTO_ERR+D'1', 1

	USB_BTS_ERR = 0;
0D22  6BE2      	CLRF gbl_USB_BTS_ERR, 1
0D24  6BE3      	CLRF gbl_USB_BTS_ERR+D'1', 1

	intcon = intcon | 11000000b; // Enable GIE & PEIE
0D26  0EC0      	MOVLW 0xC0
0D28  10F2      	IORWF gbl_intcon, W
0D2A  6EF2      	MOVWF gbl_intcon

}
0D2C  0012      	RETURN


/* ********************************************************************* */
/* This is activated by the STALL bit in the UIR register.  It really    */
/* just tells us that the SIE sent a STALL handshake.  So far, Don't     */
/* see that any action is required.  Clear the bit and move on.          */
/* ********************************************************************* */
void USBStall() {

	bSTALL = 0;
0138  9A68      	BCF gbl_bSTALL,5

}
013A  0012      	RETURN


/* ****************************************************************** */
/* The SIE detected an error.  This code increments the appropriate   */
/* error counter and clears the flag.                                 */
/* ****************************************************************** */
void Count_Error() {

	if (bPID_ERR && bPID_ERR_E) {
0BE8  A06A      	BTFSS gbl_bPID_ERR,0
0BEA  D005      	BRA	label105
0BEC  A06B      	BTFSS gbl_bPID_ERR_E,0
0BEE  D003      	BRA	label105

		++USB_PID_ERR;
0BF0  0100      	MOVLB 0x00
0BF2  4BD4      	INFSNZ gbl_USB_PID_ERR, F, 1
0BF4  2BD5      	INCF gbl_USB_PID_ERR+D'1', F, 1
0BF6            label105

	}
	if (bCRC5 && bCRC5_E) {
0BF6  A26A      	BTFSS gbl_bCRC5,1
0BF8  D005      	BRA	label106
0BFA  A26B      	BTFSS gbl_bCRC5_E,1
0BFC  D003      	BRA	label106

		++USB_CRC5_ERR;
0BFE  0100      	MOVLB 0x00
0C00  4BD6      	INFSNZ gbl_USB_CRC5_ERR, F, 1
0C02  2BD7      	INCF gbl_USB_CRC5_ERR+D'1', F, 1
0C04            label106

	}
	if (bCRC16 && bCRC16_E) {
0C04  A46A      	BTFSS gbl_bCRC16,2
0C06  D005      	BRA	label107
0C08  A46B      	BTFSS gbl_bCRC16_E,2
0C0A  D003      	BRA	label107

		++USB_CRC16_ERR;
0C0C  0100      	MOVLB 0x00
0C0E  4BD8      	INFSNZ gbl_USB_CRC16_ERR, F, 1
0C10  2BD9      	INCF gbl_USB_CRC16_ERR+D'1', F, 1
0C12            label107

	}
	if (bDFN8 && bDFN8_E) {
0C12  A66A      	BTFSS gbl_bDFN8,3
0C14  D005      	BRA	label108
0C16  A66B      	BTFSS gbl_bDFN8_E,3
0C18  D003      	BRA	label108

		++USB_DFN8_ERR;
0C1A  0100      	MOVLB 0x00
0C1C  4BDA      	INFSNZ gbl_USB_DFN8_ERR, F, 1
0C1E  2BDB      	INCF gbl_USB_DFN8_ERR+D'1', F, 1
0C20            label108

	}
	if (bBTO_ERR && bBTO_ERR_E) {
0C20  A86A      	BTFSS gbl_bBTO_ERR,4
0C22  D005      	BRA	label109
0C24  A86B      	BTFSS gbl_bBTO_ERR_E,4
0C26  D003      	BRA	label109

		++USB_BTO_ERR;
0C28  0100      	MOVLB 0x00
0C2A  4BDC      	INFSNZ gbl_USB_BTO_ERR, F, 1
0C2C  2BDD      	INCF gbl_USB_BTO_ERR+D'1', F, 1
0C2E            label109

	}
	if (bBTS_ERR && bBTS_ERR_E) {
0C2E  AE6A      	BTFSS gbl_bBTS_ERR,7
0C30  D005      	BRA	label110
0C32  AE6B      	BTFSS gbl_bBTS_ERR_E,7
0C34  D003      	BRA	label110

		++USB_BTS_ERR;
0C36  0100      	MOVLB 0x00
0C38  4BE2      	INFSNZ gbl_USB_BTS_ERR, F, 1
0C3A  2BE3      	INCF gbl_USB_BTS_ERR+D'1', F, 1
0C3C            label110

	}
	ueir = 0; //Clear all USB error flag bits
0C3C  6A6A      	CLRF gbl_ueir

	bUERR = 0; //Clear master USB error flag bit
0C3E  9268      	BCF gbl_bUERR,1

}
0C40  0012      	RETURN

/* ******************************************************************* */
/* Process token done interrupt...  Most of the work gets done through */
/* this interrupt.  Token Done is signaled in response to an In, Out,  */
/* or Setup transaction.                                               */
/* ******************************************************************* */
void Process_Req() {

	unsigned char *OutBuffer;
	unsigned char *UEPArray;
	unsigned char DescriptorType;
	unsigned char Endpoint;
	unsigned char Interface;
	unsigned char DescriptorID;
	unsigned char StringID;
	USB_USTAT = ustat;
014A  506C      	MOVF gbl_ustat, W
014C  0100      	MOVLB 0x00
014E  6FF3      	MOVWF gbl_USB_USTAT, 1

	ACTIVE_BUF = (USB_USTAT >> 3) * 2; //EP*2 (IF OUTPUT)
0150  31F3      	RRCF gbl_USB_USTAT, W, 1
0152  6FF4      	MOVWF gbl_ACTIVE_BUF, 1
0154  33F4      	RRCF gbl_ACTIVE_BUF, F, 1
0156  33F4      	RRCF gbl_ACTIVE_BUF, F, 1
0158  0E1F      	MOVLW 0x1F
015A  17F4      	ANDWF gbl_ACTIVE_BUF, F, 1
015C  90D8      	BCF STATUS,C
015E  37F4      	RLCF gbl_ACTIVE_BUF, F, 1

	ACTIVE_BUF = (ACTIVE_BUF + (USB_USTAT & 0x4) >> 2);  //=EP*2 + 1 (IF INPUT) 
0160  0E04      	MOVLW 0x04
0162  15F3      	ANDWF gbl_USB_USTAT, W, 1
0164  0101      	MOVLB 0x01
0166  6F27      	MOVWF CompTempVar593, 1
0168  6B28      	CLRF CompTempVar596, 1
016A  5127      	MOVF CompTempVar593, W, 1
016C  0100      	MOVLB 0x00
016E  27F4      	ADDWF gbl_ACTIVE_BUF, F, 1
0170  E302      	BNC	label7
0172  0101      	MOVLB 0x01
0174  2B28      	INCF CompTempVar596, F, 1
0176  0101      	MOVLB 0x01
0178  3328      	RRCF CompTempVar596, F, 1
017A  0100      	MOVLB 0x00
017C  33F4      	RRCF gbl_ACTIVE_BUF, F, 1
017E  0101      	MOVLB 0x01
0180  3328      	RRCF CompTempVar596, F, 1
0182  0100      	MOVLB 0x00
0184  33F4      	RRCF gbl_ACTIVE_BUF, F, 1

//save data in buffer descriptor table
	BDTCopy.EPStat = BDT[ACTIVE_BUF].EPStat;
0186  51E9      	MOVF gbl_BDT+D'1', W, 1
0188  6EEA      	MOVWF FSR0H
018A  51E8      	MOVF gbl_BDT, W, 1
018C  6EE9      	MOVWF FSR0L
018E  51F4      	MOVF gbl_ACTIVE_BUF, W, 1
0190  0101      	MOVLB 0x01
0192  6F27      	MOVWF CompTempVar597, 1
0194  3727      	RLCF CompTempVar597, F, 1
0196  3727      	RLCF CompTempVar597, F, 1
0198  0EFC      	MOVLW 0xFC
019A  1527      	ANDWF CompTempVar597, W, 1
019C  26E9      	ADDWF FSR0L, F
019E  50EF      	MOVF INDF0, W
01A0  0100      	MOVLB 0x00
01A2  6FC9      	MOVWF gbl_BDTCopy, 1

	BDTCopy.bytes = BDT[ACTIVE_BUF].bytes;
01A4  51E8      	MOVF gbl_BDT, W, 1
01A6  6EE9      	MOVWF FSR0L
01A8  51F4      	MOVF gbl_ACTIVE_BUF, W, 1
01AA  0101      	MOVLB 0x01
01AC  6F27      	MOVWF CompTempVar598, 1
01AE  3727      	RLCF CompTempVar598, F, 1
01B0  3727      	RLCF CompTempVar598, F, 1
01B2  0EFC      	MOVLW 0xFC
01B4  1527      	ANDWF CompTempVar598, W, 1
01B6  26E9      	ADDWF FSR0L, F
01B8  50EC      	MOVF PREINC0, W
01BA  0100      	MOVLB 0x00
01BC  6FCA      	MOVWF gbl_BDTCopy+D'1', 1

	BDTCopy.address = BDT[ACTIVE_BUF].address;
01BE  51E8      	MOVF gbl_BDT, W, 1
01C0  6EE9      	MOVWF FSR0L
01C2  51F4      	MOVF gbl_ACTIVE_BUF, W, 1
01C4  0101      	MOVLB 0x01
01C6  6F27      	MOVWF CompTempVar599, 1
01C8  3727      	RLCF CompTempVar599, F, 1
01CA  3727      	RLCF CompTempVar599, F, 1
01CC  0EFC      	MOVLW 0xFC
01CE  1527      	ANDWF CompTempVar599, W, 1
01D0  26E9      	ADDWF FSR0L, F
01D2  0E02      	MOVLW 0x02
01D4  26E9      	ADDWF FSR0L, F
01D6  50EE      	MOVF POSTINC0, W
01D8  0100      	MOVLB 0x00
01DA  6FCB      	MOVWF gbl_BDTCopy+D'2', 1
01DC  50EF      	MOVF INDF0, W
01DE  6FCC      	MOVWF gbl_BDTCopy+D'3', 1

	bTOK_DONE = 0;
01E0  9668      	BCF gbl_bTOK_DONE,3

	if ((BDTCopy.EPStat & 0x3C) == TOKEN_IN) {
01E2  0E3C      	MOVLW 0x3C
01E4  15C9      	ANDWF gbl_BDTCopy, W, 1
01E6  0101      	MOVLB 0x01
01E8  6F24      	MOVWF CompTempVar587, 1
01EA  0E24      	MOVLW 0x24
01EC  6324      	CPFSEQ CompTempVar587, 1
01EE  D00E      	BRA	label9
020C            label9

        // TOKEN IN
		if (USB_USTAT == 0x04) { 
01F0  0E04      	MOVLW 0x04
01F2  0100      	MOVLB 0x00
01F4  63F3      	CPFSEQ gbl_USB_USTAT, 1
01F6  D006      	BRA	label8
0204            label8

            /* Process EP0 In's */
			if (USB_dev_req == GET_DESCRIPTOR) {
01F8  0E06      	MOVLW 0x06
01FA  63F2      	CPFSEQ gbl_USB_dev_req, 1

				CopyDescriptorToEP0 ();
01FE  EC5BF000  	CALL CopyDescri_0000B

			}
		} else if (USB_USTAT == 0x0C) {
0204  0E0C      	MOVLW 0x0C
0206  63F3      	CPFSEQ gbl_USB_USTAT, 1

            /* process EP1 In's */
        } else {
		    /* process EP2 In's */
		}
	} else if ((BDTCopy.EPStat & 0x3C) == TOKEN_OUT) {
020C  0E3C      	MOVLW 0x3C
020E  0100      	MOVLB 0x00
0210  15C9      	ANDWF gbl_BDTCopy, W, 1
0212  0101      	MOVLB 0x01
0214  6F25      	MOVWF CompTempVar588, 1
0216  0E04      	MOVLW 0x04
0218  6325      	CPFSEQ CompTempVar588, 1
021A  D008      	BRA	label10
022C            label10

        //TOKEN OUT
		if (USB_USTAT == 0x00) {
021C  0100      	MOVLB 0x00
021E  53F3      	MOVF gbl_USB_USTAT, F, 1
0220  B4D8      	BTFSC STATUS,Z

		    /* process EP1 Out's */
		} else if (USB_USTAT == 0x08) {
0224  0E08      	MOVLW 0x08
0226  63F3      	CPFSEQ gbl_USB_USTAT, 1

            /* process EP1 Out's */
		} else {
            /* process EP2 Out's */
		}
	} else if ((BDTCopy.EPStat & 0x3C) == TOKEN_SETUP) {
022C  0E3C      	MOVLW 0x3C
022E  0100      	MOVLB 0x00
0230  15C9      	ANDWF gbl_BDTCopy, W, 1
0232  0101      	MOVLB 0x01
0234  6F26      	MOVWF CompTempVar589, 1
0236  0E34      	MOVLW 0x34
0238  6326      	CPFSEQ CompTempVar589, 1

        // TOKEN SETUP
		Buffer = (struct BufferStruct*) ((unsigned int)bd0adrloe + (unsigned int)(bd0adrhoe << 8));
023C  0104      	MOVLB 0x04
023E  5102      	MOVF gbl_bd0adrloe, W, 1
0240  0100      	MOVLB 0x00
0242  6FEA      	MOVWF gbl_Buffer, 1
0244  0101      	MOVLB 0x01
0246  6B2A      	CLRF CompTempVar605+D'1', 1
0248  6B2B      	CLRF CompTempVar606, 1
024A  0104      	MOVLB 0x04
024C  5103      	MOVF gbl_bd0adrhoe, W, 1
024E  0100      	MOVLB 0x00
0250  6FEB      	MOVWF gbl_Buffer+D'1', 1
0252  0101      	MOVLB 0x01
0254  512B      	MOVF CompTempVar606, W, 1
0256  0100      	MOVLB 0x00
0258  27EA      	ADDWF gbl_Buffer, F, 1
025A  0101      	MOVLB 0x01
025C  512A      	MOVF CompTempVar605+D'1', W, 1
025E  0100      	MOVLB 0x00
0260  23EB      	ADDWFC gbl_Buffer+D'1', F, 1

		BufferCopy.bmRequestType = Buffer->bmRequestType;
0262  51EB      	MOVF gbl_Buffer+D'1', W, 1
0264  6EEA      	MOVWF FSR0H
0266  51EA      	MOVF gbl_Buffer, W, 1
0268  6EE9      	MOVWF FSR0L
026A  50EF      	MOVF INDF0, W
026C  6FC1      	MOVWF gbl_BufferCopy, 1

		BufferCopy.bRequest = Buffer->bRequest;
026E  50EC      	MOVF PREINC0, W
0270  6FC2      	MOVWF gbl_BufferCopy+D'1', 1

		BufferCopy.wValue = Buffer->wValue;
0272  06E9      	DECF FSR0L, F
0274  0E02      	MOVLW 0x02
0276  26E9      	ADDWF FSR0L, F
0278  50EE      	MOVF POSTINC0, W
027A  6FC3      	MOVWF gbl_BufferCopy+D'2', 1
027C  50EF      	MOVF INDF0, W
027E  6FC4      	MOVWF gbl_BufferCopy+D'3', 1

		BufferCopy.wIndex = Buffer->wIndex;
0280  51EA      	MOVF gbl_Buffer, W, 1
0282  6EE9      	MOVWF FSR0L
0284  0E04      	MOVLW 0x04
0286  26E9      	ADDWF FSR0L, F
0288  50EE      	MOVF POSTINC0, W
028A  6FC5      	MOVWF gbl_BufferCopy+D'4', 1
028C  50EF      	MOVF INDF0, W
028E  6FC6      	MOVWF gbl_BufferCopy+D'5', 1

		BufferCopy.wLength = Buffer->wLength;
0290  51EA      	MOVF gbl_Buffer, W, 1
0292  6EE9      	MOVWF FSR0L
0294  0E06      	MOVLW 0x06
0296  26E9      	ADDWF FSR0L, F
0298  50EE      	MOVF POSTINC0, W
029A  6FC7      	MOVWF gbl_BufferCopy+D'6', 1
029C  50EF      	MOVF INDF0, W
029E  6FC8      	MOVWF gbl_BufferCopy+D'7', 1

        bPID_ERR = 0;  // Clear REQUEST ERROR  
02A0  906A      	BCF gbl_bPID_ERR,0

		bd0cntoe = 0x08;
02A2  0E08      	MOVLW 0x08
02A4  0104      	MOVLB 0x04
02A6  6F01      	MOVWF gbl_bd0cntoe, 1

		if (BufferCopy.bmRequestType == 0x21)
02A8  0E21      	MOVLW 0x21
02AA  0100      	MOVLB 0x00
02AC  63C1      	CPFSEQ gbl_BufferCopy, 1
02AE  D004      	BRA	label11
02B8            label11

			bd0statoe = 0xC8;
02B0  0EC8      	MOVLW 0xC8
02B2  0104      	MOVLB 0x04
02B4  6F00      	MOVWF gbl_bd0statoe, 1

		else
02B6  D003      	BRA	label12
02BE            label12
02F2  D3BC      	BRA	label81
030E  D035      	BRA	label25
03C6  D017      	BRA	label34
0404  D041      	BRA	label40
06A2  D074      	BRA	label62
0B60  D03F      	BRA	label103
0B78  D009      	BRA	label93
0BA8  D011      	BRA	label98

	        bd0statoe = 0x88;/* Turn the buffer around, make it available for the SIE */
02B8  0E88      	MOVLW 0x88
02BA  0104      	MOVLB 0x04
02BC  6F00      	MOVWF gbl_bd0statoe, 1

		bd0statie = 0x08;
02BE  0E08      	MOVLW 0x08
02C0  6F04      	MOVWF gbl_bd0statie, 1

		bPKT_DIS = 0;
02C2  986D      	BCF gbl_bPKT_DIS,4

		USB_dev_req = 0;
02C4  0100      	MOVLB 0x00
02C6  6BF2      	CLRF gbl_USB_dev_req, 1

		switch (BufferCopy.bmRequestType) {
            // First bmRequestType ************************************		
		    case HOSTTODEVICE:
02C8  53C1      	MOVF gbl_BufferCopy, F, 1
02CA  E014      	BZ	label16
02F4            label16

                // 00
			    switch (BufferCopy.bRequest) {
		            case CLEAR_FEATURE:
02F4  05C2      	DECF gbl_BufferCopy+D'1', W, 1
02F6  E00C      	BZ	label19
0310            label19

                        //01
		                /* Remote wakeup is only valid device feature */
				        if (BufferCopy.wValue == 1)	{
0310  0E01      	MOVLW 0x01
0312  63C3      	CPFSEQ gbl_BufferCopy+D'2', 1
0314  D00A      	BRA	label20
0316  51C4      	MOVF gbl_BufferCopy+D'3', W, 1
0318  E108      	BNZ	label20
032A            label20

					        USB_status_device &= 0xFD;
031A  93EF      	BCF gbl_USB_status_device,1, 1

				            Send_0Len_pkt;
031C  0104      	MOVLB 0x04
031E  6B05      	CLRF gbl_bd0cntie, 1
0320  0EC8      	MOVLW 0xC8
0322  6F04      	MOVWF gbl_bd0statie, 1
0324  0100      	MOVLB 0x00
0326  6BF2      	CLRF gbl_USB_dev_req, 1

				        } else {
				            STALL_EP0;
032A  8070      	BSF gbl_uep0,0

                        }
				        break;

			        case SET_FEATURE:
02F8  0E03      	MOVLW 0x03
02FA  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
02FC  D001      	BRA	label17
02FE  D017      	BRA	label21
0300            label17
032E            label21

                        //03
			            /* Set Device Feature.  Only valid device */
				        if ((BufferCopy.wValue & 0xff) == 1) {
032E  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0330  0101      	MOVLB 0x01
0332  6F27      	MOVWF CompTempVar600, 1
0334  6B28      	CLRF CompTempVar601, 1
0336  0E01      	MOVLW 0x01
0338  6327      	CPFSEQ CompTempVar600, 1
033A  D00B      	BRA	label22
033C  5128      	MOVF CompTempVar601, W, 1
033E  E109      	BNZ	label22
0352            label22

				            USB_status_device |= 0x02;	/* feature is remote wakeup */
0340  0100      	MOVLB 0x00
0342  83EF      	BSF gbl_USB_status_device,1, 1

					        Send_0Len_pkt;
0344  0104      	MOVLB 0x04
0346  6B05      	CLRF gbl_bd0cntie, 1
0348  0EC8      	MOVLW 0xC8
034A  6F04      	MOVWF gbl_bd0statie, 1
034C  0100      	MOVLB 0x00
034E  6BF2      	CLRF gbl_USB_dev_req, 1

				        } else {
				            STALL_EP0;
0352  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case SET_ADDRESS:
0300  0E05      	MOVLW 0x05
0302  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0304  D001      	BRA	label18
0306  D027      	BRA	label23
0308            label18
0356            label23

                        //05
			            USB_address_pending = BufferCopy.wValue;
0356  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0358  6FF1      	MOVWF gbl_USB_address_pending, 1

				        if (USB_address_pending < 0x80) {
035A  0E80      	MOVLW 0x80
035C  61F1      	CPFSLT gbl_USB_address_pending, 1
035E  D00B      	BRA	label24
0376            label24

					        Send_0Len_pkt;
0360  0104      	MOVLB 0x04
0362  6B05      	CLRF gbl_bd0cntie, 1
0364  0EC8      	MOVLW 0xC8
0366  6F04      	MOVWF gbl_bd0statie, 1
0368  0100      	MOVLB 0x00
036A  6BF2      	CLRF gbl_USB_dev_req, 1

					        USB_dev_req = SET_ADDRESS;
036C  0E05      	MOVLW 0x05
036E  6FF2      	MOVWF gbl_USB_dev_req, 1

		                    uie = 00001001b; //enable transaction complete and reset interrupts
0370  0E09      	MOVLW 0x09
0372  6E69      	MOVWF gbl_uie

				        } else {
				            STALL_EP0;
0376  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case SET_CONFIGURATION:
0308  0E09      	MOVLW 0x09
030A  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
030C  D051      	BRA	label29
037A            label25

                        //09
				        if (BufferCopy.wValue <= NUM_CONFIGURATIONS)
037A  0E01      	MOVLW 0x01
037C  65C3      	CPFSGT gbl_BufferCopy+D'2', 1
037E  67C4      	TSTFSZ gbl_BufferCopy+D'3', 1
0380  D002      	BRA	label26
0386            label26

					        USB_Curr_Config = BufferCopy.wValue;
0382  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0384  6FF0      	MOVWF gbl_USB_Curr_Config, 1


				        if (BufferCopy.wValue == 0) {
0386  53C3      	MOVF gbl_BufferCopy+D'2', F, 1
0388  E105      	BNZ	label27
038A  53C4      	MOVF gbl_BufferCopy+D'3', F, 1
038C  E103      	BNZ	label27
0394            label27

					        USWSTAT = ADDRESS_STATE;
038E  0E02      	MOVLW 0x02
0390  6FF6      	MOVWF gbl_USWSTAT, 1

					    } else {
0392  D002      	BRA	label28
0398            label28

					        USWSTAT = CONFIG_STATE;
0394  0E03      	MOVLW 0x03
0396  6FF6      	MOVWF gbl_USWSTAT, 1

				        }
				        Send_0Len_pkt;
0398  0104      	MOVLB 0x04
039A  6B05      	CLRF gbl_bd0cntie, 1
039C  0EC8      	MOVLW 0xC8
039E  6F04      	MOVWF gbl_bd0statie, 1
03A0  0100      	MOVLB 0x00
03A2  6BF2      	CLRF gbl_USB_dev_req, 1

	                    bd1statie = 0x48; //SET MCU AS OWNER OF THIS BUFFER, ENABLE DATA TOGGLE SYNC
03A4  0E48      	MOVLW 0x48
03A6  0104      	MOVLB 0x04
03A8  6F0C      	MOVWF gbl_bd1statie, 1

				        uep1 = ENDPT_NON_CONTROL;
03AA  0E1E      	MOVLW 0x1E
03AC  6E71      	MOVWF gbl_uep1

  	                    break;
			        default:
03B0            label29

			            STALL_EP0;
03B0  8070      	BSF gbl_uep0,0

				        break;
			    }
			    break;
            // Second bmRequestType ************************************	
            case HOSTTOINTERFACE:   
02CC  05C1      	DECF gbl_BufferCopy, W, 1
02CE  B4D8      	BTFSC STATUS,Z
02D0  D071      	BRA	label30
03B4            label30

                //01
                switch (BufferCopy.bRequest) {
                    case SET_INTERFACE:
03B4  0E0B      	MOVLW 0x0B
03B6  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
03B8  D001      	BRA	label31
03BA  D006      	BRA	label32
03BC            label31
03C8            label32

                        //0B
                        if (USWSTAT == CONFIG_STATE) {
03C8  0E03      	MOVLW 0x03
03CA  63F6      	CPFSEQ gbl_USWSTAT, 1
03CC  D012      	BRA	label33
03F2            label33

                            Interface = BufferCopy.wIndex;
03CE  51C5      	MOVF gbl_BufferCopy+D'4', W, 1
03D0  0101      	MOVLB 0x01
03D2  6F21      	MOVWF Process_Re_0000D_1_Interface, 1

                            USB_Interface[Interface] = BufferCopy.wValue;
03D4  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
03D8  50E9      	MOVF FSR0L, W
03DA  5121      	MOVF Process_Re_0000D_1_Interface, W, 1
03DC  26E9      	ADDWF FSR0L, F
03DE  0100      	MOVLB 0x00
03E0  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
03E2  6EEF      	MOVWF INDF0

                            Send_0Len_pkt;
03E4  0104      	MOVLB 0x04
03E6  6B05      	CLRF gbl_bd0cntie, 1
03E8  0EC8      	MOVLW 0xC8
03EA  6F04      	MOVWF gbl_bd0statie, 1
03EC  0100      	MOVLB 0x00
03EE  6BF2      	CLRF gbl_USB_dev_req, 1

                        } else {
                            STALL_EP0;
03F2  8070      	BSF gbl_uep0,0

                        }
                        break;
                    case CLEAR_FEATURE:
03BC  05C2      	DECF gbl_BufferCopy+D'1', W, 1
03BE  E01B      	BZ	label34
03F6            label34

                        //01
                    case SET_FEATURE:
03C0  0E03      	MOVLW 0x03
03C2  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
03C4  D018      	BRA	label34

                        //03
                        /* Set Interface feature - Not Valid */
                    default:
                        STALL_EP0;
03F6  8070      	BSF gbl_uep0,0

                        break;
                }
                break;
            // Third bmRequestType ************************************				
		    case HOSTTOENDPOINT:
02D2  0E02      	MOVLW 0x02
02D4  63C1      	CPFSEQ gbl_BufferCopy, 1
02D6  D001      	BRA	label13
02D8  D090      	BRA	label35
02DA            label13
03FA            label35

			    switch (BufferCopy.bRequest) {
			        case CLEAR_FEATURE:
03FA  05C2      	DECF gbl_BufferCopy+D'1', W, 1
03FC  E004      	BZ	label36
0406            label36

                        //01
				        UEPArray = (unsigned char *) &uep0;
0406  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0408  0101      	MOVLB 0x01
040A  6F1E      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1
040C  0E70      	MOVLW LOW(gbl_uep0+D'0')
040E  6F1D      	MOVWF Process_Re_0000D_1_UEPArray, 1

				        Endpoint = BufferCopy.wIndex & 0x0F;
0410  0E0F      	MOVLW 0x0F
0412  0100      	MOVLB 0x00
0414  15C5      	ANDWF gbl_BufferCopy+D'4', W, 1
0416  0101      	MOVLB 0x01
0418  6F20      	MOVWF Process_Re_0000D_1_Endpoint, 1

	                    if (BufferCopy.wValue == 0) {
041A  0100      	MOVLB 0x00
041C  53C3      	MOVF gbl_BufferCopy+D'2', F, 1
041E  E132      	BNZ	label39
0420  53C4      	MOVF gbl_BufferCopy+D'3', F, 1
0422  E130      	BNZ	label39
0484            label39

	                        /* Only valid feature is 0 (Remote Wakeup) */
				            if (((USWSTAT & 0x03) == ADDRESS_STATE) && (Endpoint == 0)) {
0424  0E03      	MOVLW 0x03
0426  15F6      	ANDWF gbl_USWSTAT, W, 1
0428  0101      	MOVLB 0x01
042A  6F29      	MOVWF CompTempVar610, 1
042C  0E02      	MOVLW 0x02
042E  6329      	CPFSEQ CompTempVar610, 1
0430  D00F      	BRA	label37
0432  5320      	MOVF Process_Re_0000D_1_Endpoint, F, 1
0434  E10D      	BNZ	label37
0450            label37

						        UEPArray [Endpoint] &= 0xFE;
0436  511E      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0438  6EEA      	MOVWF FSR0H
043A  511D      	MOVF Process_Re_0000D_1_UEPArray, W, 1
043C  2520      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
043E  6EE9      	MOVWF FSR0L
0440  90EF      	BCF INDF0,0

						        Send_0Len_pkt;
0442  0104      	MOVLB 0x04
0444  6B05      	CLRF gbl_bd0cntie, 1
0446  0EC8      	MOVLW 0xC8
0448  6F04      	MOVWF gbl_bd0statie, 1
044A  0100      	MOVLB 0x00
044C  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else if (((USWSTAT& 0x03) == CONFIG_STATE) && (Endpoint < 3)) {
0450  0E03      	MOVLW 0x03
0452  0100      	MOVLB 0x00
0454  15F6      	ANDWF gbl_USWSTAT, W, 1
0456  0101      	MOVLB 0x01
0458  6F29      	MOVWF CompTempVar612, 1
045A  0E03      	MOVLW 0x03
045C  6329      	CPFSEQ CompTempVar612, 1
045E  D010      	BRA	label38
0460  0E03      	MOVLW 0x03
0462  6120      	CPFSLT Process_Re_0000D_1_Endpoint, 1
0464  D00D      	BRA	label38
0480            label38

						        UEPArray [Endpoint] &= 0xFE;
0466  511E      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0468  6EEA      	MOVWF FSR0H
046A  511D      	MOVF Process_Re_0000D_1_UEPArray, W, 1
046C  2520      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
046E  6EE9      	MOVWF FSR0L
0470  90EF      	BCF INDF0,0

						        Send_0Len_pkt;
0472  0104      	MOVLB 0x04
0474  6B05      	CLRF gbl_bd0cntie, 1
0476  0EC8      	MOVLW 0xC8
0478  6F04      	MOVWF gbl_bd0statie, 1
047A  0100      	MOVLB 0x00
047C  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else {
					            STALL_EP0;
0480  8070      	BSF gbl_uep0,0

                            }
				        } else {
					        STALL_EP0;
0484  8070      	BSF gbl_uep0,0

                        }
				        break;

			        case SET_FEATURE:
03FE  0E03      	MOVLW 0x03
0400  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0402  D085      	BRA	label44
0488            label40

                        //03
				        UEPArray = (unsigned char *) &uep0;
0488  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
048A  0101      	MOVLB 0x01
048C  6F29      	MOVWF CompTempVar614, 1
048E  0E70      	MOVLW LOW(gbl_uep0+D'0')
0490  6F1D      	MOVWF Process_Re_0000D_1_UEPArray, 1
0492  5129      	MOVF CompTempVar614, W, 1
0494  6F1E      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1

				        Endpoint = BufferCopy.wIndex & 0x0F;
0496  0E0F      	MOVLW 0x0F
0498  0100      	MOVLB 0x00
049A  15C5      	ANDWF gbl_BufferCopy+D'4', W, 1
049C  0101      	MOVLB 0x01
049E  6F20      	MOVWF Process_Re_0000D_1_Endpoint, 1

	                    if (BufferCopy.wValue == 0) {
04A0  0100      	MOVLB 0x00
04A2  53C3      	MOVF gbl_BufferCopy+D'2', F, 1
04A4  E132      	BNZ	label43
04A6  53C4      	MOVF gbl_BufferCopy+D'3', F, 1
04A8  E130      	BNZ	label43
050A            label43

                            /* Only valid feature is 0 (Remote Wakeup) */
				            if (((USWSTAT& 0x03) == ADDRESS_STATE) && (Endpoint == 0)) {
04AA  0E03      	MOVLW 0x03
04AC  15F6      	ANDWF gbl_USWSTAT, W, 1
04AE  0101      	MOVLB 0x01
04B0  6F29      	MOVWF CompTempVar615, 1
04B2  0E02      	MOVLW 0x02
04B4  6329      	CPFSEQ CompTempVar615, 1
04B6  D00F      	BRA	label41
04B8  5320      	MOVF Process_Re_0000D_1_Endpoint, F, 1
04BA  E10D      	BNZ	label41
04D6            label41

						        UEPArray [Endpoint] |= 1;
04BC  511E      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
04BE  6EEA      	MOVWF FSR0H
04C0  511D      	MOVF Process_Re_0000D_1_UEPArray, W, 1
04C2  2520      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
04C4  6EE9      	MOVWF FSR0L
04C6  80EF      	BSF INDF0,0

						        Send_0Len_pkt;
04C8  0104      	MOVLB 0x04
04CA  6B05      	CLRF gbl_bd0cntie, 1
04CC  0EC8      	MOVLW 0xC8
04CE  6F04      	MOVWF gbl_bd0statie, 1
04D0  0100      	MOVLB 0x00
04D2  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else if (((USWSTAT& 0x03) == CONFIG_STATE) && (Endpoint < 3)) {
04D6  0E03      	MOVLW 0x03
04D8  0100      	MOVLB 0x00
04DA  15F6      	ANDWF gbl_USWSTAT, W, 1
04DC  0101      	MOVLB 0x01
04DE  6F29      	MOVWF CompTempVar617, 1
04E0  0E03      	MOVLW 0x03
04E2  6329      	CPFSEQ CompTempVar617, 1
04E4  D010      	BRA	label42
04E6  0E03      	MOVLW 0x03
04E8  6120      	CPFSLT Process_Re_0000D_1_Endpoint, 1
04EA  D00D      	BRA	label42
0506            label42

						        UEPArray [Endpoint] |= 1;
04EC  511E      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
04EE  6EEA      	MOVWF FSR0H
04F0  511D      	MOVF Process_Re_0000D_1_UEPArray, W, 1
04F2  2520      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
04F4  6EE9      	MOVWF FSR0L
04F6  80EF      	BSF INDF0,0

						        Send_0Len_pkt;
04F8  0104      	MOVLB 0x04
04FA  6B05      	CLRF gbl_bd0cntie, 1
04FC  0EC8      	MOVLW 0xC8
04FE  6F04      	MOVWF gbl_bd0statie, 1
0500  0100      	MOVLB 0x00
0502  6BF2      	CLRF gbl_USB_dev_req, 1

					        } else {
					            STALL_EP0;
0506  8070      	BSF gbl_uep0,0

                            }
				        } else {
				  	        STALL_EP0;
050A  8070      	BSF gbl_uep0,0

                        }
				        break;
			        default:
050E            label44

                        STALL_EP0;
050E  8070      	BSF gbl_uep0,0

			    }
			    break;

            // Fourth bmRequestType ************************************	
		    case DEVICETOHOST:  
02DA  0E80      	MOVLW 0x80
02DC  63C1      	CPFSEQ gbl_BufferCopy, 1
02DE  D001      	BRA	label14
02E0  D118      	BRA	label45
02E2            label14
0512            label45

                //80
			    switch (BufferCopy.bRequest) {
			        case GET_CONFIGURATION:
0512  0E08      	MOVLW 0x08
0514  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0516  D001      	BRA	label46
0518  D008      	BRA	label48
051A            label46
052A            label48

                        OutBuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));
052A  0104      	MOVLB 0x04
052C  5106      	MOVF gbl_bd0adrlie, W, 1
052E  0100      	MOVLB 0x00
0530  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0532  0101      	MOVLB 0x01
0534  6B2A      	CLRF CompTempVar621+D'1', 1
0536  6B2B      	CLRF CompTempVar622, 1
0538  0104      	MOVLB 0x04
053A  5107      	MOVF gbl_bd0adrhie, W, 1
053C  0100      	MOVLB 0x00
053E  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1
0540  0101      	MOVLB 0x01
0542  512B      	MOVF CompTempVar622, W, 1
0544  0100      	MOVLB 0x00
0546  27FE      	ADDWF Process_Re_0000D_1_OutBuffer, F, 1
0548  0101      	MOVLB 0x01
054A  512A      	MOVF CompTempVar621+D'1', W, 1
054C  0100      	MOVLB 0x00
054E  23FF      	ADDWFC Process_Re_0000D_1_OutBuffer+D'1', F, 1

			            OutBuffer [0] = USB_Curr_Config;
0550  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0552  6EEA      	MOVWF FSR0H
0554  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0556  6EE9      	MOVWF FSR0L
0558  0101      	MOVLB 0x01
055A  6B29      	CLRF CompTempVar625, 1
055C  5129      	MOVF CompTempVar625, W, 1
055E  26E9      	ADDWF FSR0L, F
0560  0100      	MOVLB 0x00
0562  51F0      	MOVF gbl_USB_Curr_Config, W, 1
0564  6EEF      	MOVWF INDF0

				        bd0cntie = 1;
0566  0E01      	MOVLW 0x01
0568  0104      	MOVLB 0x04
056A  6F05      	MOVWF gbl_bd0cntie, 1

				        bd0statie = 0xc8;
056C  0EC8      	MOVLW 0xC8
056E  6F04      	MOVWF gbl_bd0statie, 1

				        break;
			        case GET_DESCRIPTOR:
051A  0E06      	MOVLW 0x06
051C  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
051E  D001      	BRA	label47
0520  D028      	BRA	label49
0522            label47
0572            label49

				        DescriptorID = (unsigned char) (BufferCopy.wValue >> 8);
0572  51C4      	MOVF gbl_BufferCopy+D'3', W, 1
0574  0101      	MOVLB 0x01
0576  6F22      	MOVWF Process_Re_0000D_1_DescriptorID, 1

				        if (DescriptorID == DEVICE) {
0578  0522      	DECF Process_Re_0000D_1_DescriptorID, W, 1
057A  E13E      	BNZ	label52
05F8            label52

							USB_dev_req = GET_DESCRIPTOR;
057C  0E06      	MOVLW 0x06
057E  0100      	MOVLB 0x00
0580  6FF2      	MOVWF gbl_USB_dev_req, 1

					        EP0_start = DeviceDescriptor;
0582  0E00      	MOVLW HIGH(gbl_DeviceDescriptor+D'0')
0584  6FE5      	MOVWF gbl_EP0_start+D'1', 1
0586  0EA6      	MOVLW LOW(gbl_DeviceDescriptor+D'0')
0588  6FE4      	MOVWF gbl_EP0_start, 1

				            EP0_end = DeviceDescriptor + sizeof(DeviceDescriptor);
058A  0E00      	MOVLW HIGH(gbl_DeviceDescriptor+D'0')
058C  0101      	MOVLB 0x01
058E  6F2B      	MOVWF CompTempVar631, 1
0590  0EA6      	MOVLW LOW(gbl_DeviceDescriptor+D'0')
0592  0100      	MOVLB 0x00
0594  6FE6      	MOVWF gbl_EP0_end, 1
0596  6BE7      	CLRF gbl_EP0_end+D'1', 1
0598  0E12      	MOVLW 0x12
059A  27E6      	ADDWF gbl_EP0_end, F, 1
059C  0101      	MOVLB 0x01
059E  512B      	MOVF CompTempVar631, W, 1
05A0  0100      	MOVLB 0x00
05A2  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                            if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
05A4  51E4      	MOVF gbl_EP0_start, W, 1
05A6  5DE6      	SUBWF gbl_EP0_end, W, 1
05A8  0101      	MOVLB 0x01
05AA  6F29      	MOVWF CompTempVar627, 1
05AC  0100      	MOVLB 0x00
05AE  51E5      	MOVF gbl_EP0_start+D'1', W, 1
05B0  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
05B2  0101      	MOVLB 0x01
05B4  6F2A      	MOVWF CompTempVar628, 1
05B6  512A      	MOVF CompTempVar628, W, 1
05B8  0100      	MOVLB 0x00
05BA  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
05BC  E104      	BNZ	label50
05BE  0101      	MOVLB 0x01
05C0  5129      	MOVF CompTempVar627, W, 1
05C2  0100      	MOVLB 0x00
05C4  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
05C6            label50
05C6  E213      	BC	label51
05EE            label51

						        EP0_end = EP0_start + BufferCopy.wLength;
05C8  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
05CA  25E4      	ADDWF gbl_EP0_start, W, 1
05CC  0101      	MOVLB 0x01
05CE  6F2B      	MOVWF CompTempVar634, 1
05D0  0100      	MOVLB 0x00
05D2  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
05D4  0101      	MOVLB 0x01
05D6  6F2C      	MOVWF CompTempVar635, 1
05D8  0100      	MOVLB 0x00
05DA  51E5      	MOVF gbl_EP0_start+D'1', W, 1
05DC  0101      	MOVLB 0x01
05DE  232C      	ADDWFC CompTempVar635, F, 1
05E0  512B      	MOVF CompTempVar634, W, 1
05E2  0100      	MOVLB 0x00
05E4  6FE6      	MOVWF gbl_EP0_end, 1
05E6  0101      	MOVLB 0x01
05E8  512C      	MOVF CompTempVar635, W, 1
05EA  0100      	MOVLB 0x00
05EC  6FE7      	MOVWF gbl_EP0_end+D'1', 1

					        EP0_maxLength = 8;
05EE  0E08      	MOVLW 0x08
05F0  6FF7      	MOVWF gbl_EP0_maxLength, 1

					        CopyDescriptorToEP0();
05F2  EC5BF000  	CALL CopyDescri_0000B

				        } else if (DescriptorID == CONFIGURATION) {
05F8  0E02      	MOVLW 0x02
05FA  6322      	CPFSEQ Process_Re_0000D_1_DescriptorID, 1
05FC  D03E      	BRA	label55
067A            label55

					        USB_dev_req = GET_DESCRIPTOR;
05FE  0E06      	MOVLW 0x06
0600  0100      	MOVLB 0x00
0602  6FF2      	MOVWF gbl_USB_dev_req, 1

					        EP0_start = ConfigDescriptor;
0604  0E00      	MOVLW HIGH(gbl_ConfigDescriptor+D'0')
0606  6FE5      	MOVWF gbl_EP0_start+D'1', 1
0608  0E3D      	MOVLW LOW(gbl_ConfigDescriptor+D'0')
060A  6FE4      	MOVWF gbl_EP0_start, 1

				            EP0_end = ConfigDescriptor + sizeof(ConfigDescriptor);
060C  0E00      	MOVLW HIGH(gbl_ConfigDescriptor+D'0')
060E  0101      	MOVLB 0x01
0610  6F2B      	MOVWF CompTempVar640, 1
0612  0E3D      	MOVLW LOW(gbl_ConfigDescriptor+D'0')
0614  0100      	MOVLB 0x00
0616  6FE6      	MOVWF gbl_EP0_end, 1
0618  6BE7      	CLRF gbl_EP0_end+D'1', 1
061A  0E22      	MOVLW 0x22
061C  27E6      	ADDWF gbl_EP0_end, F, 1
061E  0101      	MOVLB 0x01
0620  512B      	MOVF CompTempVar640, W, 1
0622  0100      	MOVLB 0x00
0624  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                            if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
0626  51E4      	MOVF gbl_EP0_start, W, 1
0628  5DE6      	SUBWF gbl_EP0_end, W, 1
062A  0101      	MOVLB 0x01
062C  6F29      	MOVWF CompTempVar636, 1
062E  0100      	MOVLB 0x00
0630  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0632  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
0634  0101      	MOVLB 0x01
0636  6F2A      	MOVWF CompTempVar637, 1
0638  512A      	MOVF CompTempVar637, W, 1
063A  0100      	MOVLB 0x00
063C  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
063E  E104      	BNZ	label53
0640  0101      	MOVLB 0x01
0642  5129      	MOVF CompTempVar636, W, 1
0644  0100      	MOVLB 0x00
0646  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
0648            label53
0648  E213      	BC	label54
0670            label54

						        EP0_end = EP0_start + BufferCopy.wLength;
064A  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
064C  25E4      	ADDWF gbl_EP0_start, W, 1
064E  0101      	MOVLB 0x01
0650  6F2B      	MOVWF CompTempVar643, 1
0652  0100      	MOVLB 0x00
0654  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
0656  0101      	MOVLB 0x01
0658  6F2C      	MOVWF CompTempVar644, 1
065A  0100      	MOVLB 0x00
065C  51E5      	MOVF gbl_EP0_start+D'1', W, 1
065E  0101      	MOVLB 0x01
0660  232C      	ADDWFC CompTempVar644, F, 1
0662  512B      	MOVF CompTempVar643, W, 1
0664  0100      	MOVLB 0x00
0666  6FE6      	MOVWF gbl_EP0_end, 1
0668  0101      	MOVLB 0x01
066A  512C      	MOVF CompTempVar644, W, 1
066C  0100      	MOVLB 0x00
066E  6FE7      	MOVWF gbl_EP0_end+D'1', 1

					        EP0_maxLength = 8;
0670  0E08      	MOVLW 0x08
0672  6FF7      	MOVWF gbl_EP0_maxLength, 1

					        CopyDescriptorToEP0();
0674  EC5BF000  	CALL CopyDescri_0000B

				        } else if (DescriptorID == STRING) {
067A  0E03      	MOVLW 0x03
067C  6322      	CPFSEQ Process_Re_0000D_1_DescriptorID, 1
067E  D0C4      	BRA	label66
0808            label66

					        StringID = (unsigned char) BufferCopy.wValue;
0680  0100      	MOVLB 0x00
0682  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0684  0101      	MOVLB 0x01
0686  6F23      	MOVWF Process_Re_0000D_1_StringID, 1

					        USB_dev_req = GET_DESCRIPTOR;
0688  0E06      	MOVLW 0x06
068A  0100      	MOVLB 0x00
068C  6FF2      	MOVWF gbl_USB_dev_req, 1

					        EP0_maxLength = 8;
068E  0E08      	MOVLW 0x08
0690  6FF7      	MOVWF gbl_EP0_maxLength, 1

					        switch (StringID) {
					            case 0:
0692  0101      	MOVLB 0x01
0694  5323      	MOVF Process_Re_0000D_1_StringID, F, 1
0696  E006      	BZ	label56
06A4            label56

						            EP0_start = String0;  // String0 is start of string0
06A4  0E00      	MOVLW HIGH(gbl_String0+D'0')
06A6  0100      	MOVLB 0x00
06A8  6FE5      	MOVWF gbl_EP0_start+D'1', 1
06AA  0ECD      	MOVLW LOW(gbl_String0+D'0')
06AC  6FE4      	MOVWF gbl_EP0_start, 1

						            EP0_end = String0 + String0[0]; // String[0] is length of String0
06AE  0E00      	MOVLW HIGH(gbl_String0+D'0')
06B0  0101      	MOVLB 0x01
06B2  6F2F      	MOVWF CompTempVar654, 1
06B4  0ECD      	MOVLW LOW(gbl_String0+D'0')
06B6  0100      	MOVLB 0x00
06B8  6FE6      	MOVWF gbl_EP0_end, 1
06BA  6BE7      	CLRF gbl_EP0_end+D'1', 1
06BC  51CD      	MOVF gbl_String0, W, 1
06BE  27E6      	ADDWF gbl_EP0_end, F, 1
06C0  0101      	MOVLB 0x01
06C2  512F      	MOVF CompTempVar654, W, 1
06C4  0100      	MOVLB 0x00
06C6  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
06C8  51E4      	MOVF gbl_EP0_start, W, 1
06CA  5DE6      	SUBWF gbl_EP0_end, W, 1
06CC  0101      	MOVLB 0x01
06CE  6F29      	MOVWF CompTempVar645, 1
06D0  0100      	MOVLB 0x00
06D2  51E5      	MOVF gbl_EP0_start+D'1', W, 1
06D4  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
06D6  0101      	MOVLB 0x01
06D8  6F2A      	MOVWF CompTempVar646, 1
06DA  512A      	MOVF CompTempVar646, W, 1
06DC  0100      	MOVLB 0x00
06DE  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
06E0  E104      	BNZ	label57
06E2  0101      	MOVLB 0x01
06E4  5129      	MOVF CompTempVar645, W, 1
06E6  0100      	MOVLB 0x00
06E8  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
06EA            label57
06EA  E213      	BC	label58
0712            label58

							            EP0_end = EP0_start + BufferCopy.wLength;
06EC  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
06EE  25E4      	ADDWF gbl_EP0_start, W, 1
06F0  0101      	MOVLB 0x01
06F2  6F2F      	MOVWF CompTempVar657, 1
06F4  0100      	MOVLB 0x00
06F6  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
06F8  0101      	MOVLB 0x01
06FA  6F30      	MOVWF CompTempVar658, 1
06FC  0100      	MOVLB 0x00
06FE  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0700  0101      	MOVLB 0x01
0702  2330      	ADDWFC CompTempVar658, F, 1
0704  512F      	MOVF CompTempVar657, W, 1
0706  0100      	MOVLB 0x00
0708  6FE6      	MOVWF gbl_EP0_end, 1
070A  0101      	MOVLB 0x01
070C  5130      	MOVF CompTempVar658, W, 1
070E  0100      	MOVLB 0x00
0710  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0(); // this copies the whole string in 8 byte pieces
0712  EC5BF000  	CALL CopyDescri_0000B

						            break;
					            case 1:
0698  0523      	DECF Process_Re_0000D_1_StringID, W, 1
069A  E03E      	BZ	label59
0718            label59

						            EP0_start = String1;
0718  0E00      	MOVLW HIGH(gbl_String1+D'0')
071A  0100      	MOVLB 0x00
071C  6FE5      	MOVWF gbl_EP0_start+D'1', 1
071E  0E92      	MOVLW LOW(gbl_String1+D'0')
0720  6FE4      	MOVWF gbl_EP0_start, 1

						            EP0_end = String1 + String1[0];
0722  0E00      	MOVLW HIGH(gbl_String1+D'0')
0724  0101      	MOVLB 0x01
0726  6F2F      	MOVWF CompTempVar662, 1
0728  0E92      	MOVLW LOW(gbl_String1+D'0')
072A  0100      	MOVLB 0x00
072C  6FE6      	MOVWF gbl_EP0_end, 1
072E  6BE7      	CLRF gbl_EP0_end+D'1', 1
0730  5192      	MOVF gbl_String1, W, 1
0732  27E6      	ADDWF gbl_EP0_end, F, 1
0734  0101      	MOVLB 0x01
0736  512F      	MOVF CompTempVar662, W, 1
0738  0100      	MOVLB 0x00
073A  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
073C  51E4      	MOVF gbl_EP0_start, W, 1
073E  5DE6      	SUBWF gbl_EP0_end, W, 1
0740  0101      	MOVLB 0x01
0742  6F2B      	MOVWF CompTempVar647, 1
0744  0100      	MOVLB 0x00
0746  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0748  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
074A  0101      	MOVLB 0x01
074C  6F2C      	MOVWF CompTempVar648, 1
074E  512C      	MOVF CompTempVar648, W, 1
0750  0100      	MOVLB 0x00
0752  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
0754  E104      	BNZ	label60
0756  0101      	MOVLB 0x01
0758  512B      	MOVF CompTempVar647, W, 1
075A  0100      	MOVLB 0x00
075C  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
075E            label60
075E  E213      	BC	label61
0786            label61

							            EP0_end = EP0_start + BufferCopy.wLength;
0760  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
0762  25E4      	ADDWF gbl_EP0_start, W, 1
0764  0101      	MOVLB 0x01
0766  6F2F      	MOVWF CompTempVar665, 1
0768  0100      	MOVLB 0x00
076A  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
076C  0101      	MOVLB 0x01
076E  6F30      	MOVWF CompTempVar666, 1
0770  0100      	MOVLB 0x00
0772  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0774  0101      	MOVLB 0x01
0776  2330      	ADDWFC CompTempVar666, F, 1
0778  512F      	MOVF CompTempVar665, W, 1
077A  0100      	MOVLB 0x00
077C  6FE6      	MOVWF gbl_EP0_end, 1
077E  0101      	MOVLB 0x01
0780  5130      	MOVF CompTempVar666, W, 1
0782  0100      	MOVLB 0x00
0784  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0 ();
0786  EC5BF000  	CALL CopyDescri_0000B

						            break;
					            case 2:
069C  0E02      	MOVLW 0x02
069E  6323      	CPFSEQ Process_Re_0000D_1_StringID, 1
06A0  D0AF      	BRA	label65
078C            label62

						            EP0_start = String2;
078C  0E00      	MOVLW HIGH(gbl_String2+D'0')
078E  0100      	MOVLB 0x00
0790  6FE5      	MOVWF gbl_EP0_start+D'1', 1
0792  0E05      	MOVLW LOW(gbl_String2+D'0')
0794  6FE4      	MOVWF gbl_EP0_start, 1

						            EP0_end = String2 + String2[0];
0796  0E00      	MOVLW HIGH(gbl_String2+D'0')
0798  0101      	MOVLB 0x01
079A  6F2F      	MOVWF CompTempVar670, 1
079C  0E05      	MOVLW LOW(gbl_String2+D'0')
079E  0100      	MOVLB 0x00
07A0  6FE6      	MOVWF gbl_EP0_end, 1
07A2  6BE7      	CLRF gbl_EP0_end+D'1', 1
07A4  5005      	MOVF gbl_String2, W
07A6  27E6      	ADDWF gbl_EP0_end, F, 1
07A8  0101      	MOVLB 0x01
07AA  512F      	MOVF CompTempVar670, W, 1
07AC  0100      	MOVLB 0x00
07AE  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
07B0  51E4      	MOVF gbl_EP0_start, W, 1
07B2  5DE6      	SUBWF gbl_EP0_end, W, 1
07B4  0101      	MOVLB 0x01
07B6  6F2D      	MOVWF CompTempVar649, 1
07B8  0100      	MOVLB 0x00
07BA  51E5      	MOVF gbl_EP0_start+D'1', W, 1
07BC  59E7      	SUBWFB gbl_EP0_end+D'1', W, 1
07BE  0101      	MOVLB 0x01
07C0  6F2E      	MOVWF CompTempVar650, 1
07C2  512E      	MOVF CompTempVar650, W, 1
07C4  0100      	MOVLB 0x00
07C6  5DC8      	SUBWF gbl_BufferCopy+D'7', W, 1
07C8  E104      	BNZ	label63
07CA  0101      	MOVLB 0x01
07CC  512D      	MOVF CompTempVar649, W, 1
07CE  0100      	MOVLB 0x00
07D0  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
07D2            label63
07D2  E213      	BC	label64
07FA            label64

							            EP0_end = EP0_start + BufferCopy.wLength;
07D4  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
07D6  25E4      	ADDWF gbl_EP0_start, W, 1
07D8  0101      	MOVLB 0x01
07DA  6F2F      	MOVWF CompTempVar673, 1
07DC  0100      	MOVLB 0x00
07DE  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
07E0  0101      	MOVLB 0x01
07E2  6F30      	MOVWF CompTempVar674, 1
07E4  0100      	MOVLB 0x00
07E6  51E5      	MOVF gbl_EP0_start+D'1', W, 1
07E8  0101      	MOVLB 0x01
07EA  2330      	ADDWFC CompTempVar674, F, 1
07EC  512F      	MOVF CompTempVar673, W, 1
07EE  0100      	MOVLB 0x00
07F0  6FE6      	MOVWF gbl_EP0_end, 1
07F2  0101      	MOVLB 0x01
07F4  5130      	MOVF CompTempVar674, W, 1
07F6  0100      	MOVLB 0x00
07F8  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0();
07FA  EC5BF000  	CALL CopyDescri_0000B

						            break;
                                // Additional string processing can be added here						
						        default:
0800            label65

                                    /* REQUEST ERROR */
						            STALL_PID_EP0IN;
0800  0ECC      	MOVLW 0xCC
0802  0104      	MOVLB 0x04
0804  6F04      	MOVWF gbl_bd0statie, 1

					        }
				        } else  {
					        /* REQUEST ERROR */
                            STALL_PID_EP0IN;
0808  0ECC      	MOVLW 0xCC
080A  0104      	MOVLB 0x04
080C  6F04      	MOVWF gbl_bd0statie, 1

                        }
				        break;
			        case GET_STATUS:
0522  53C2      	MOVF gbl_BufferCopy+D'1', F, 1
0524  B4D8      	BTFSC STATUS,Z
0526  D174      	BRA	label67
0810            label67

				        OutBuffer = (unsigned char *)BDT[EP0IN].address;
0810  51E9      	MOVF gbl_BDT+D'1', W, 1
0812  6EEA      	MOVWF FSR0H
0814  51E8      	MOVF gbl_BDT, W, 1
0816  6EE9      	MOVWF FSR0L
0818  0E04      	MOVLW 0x04
081A  26E9      	ADDWF FSR0L, F
081C  0E02      	MOVLW 0x02
081E  26E9      	ADDWF FSR0L, F
0820  50EE      	MOVF POSTINC0, W
0822  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0824  50EF      	MOVF INDF0, W
0826  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				        OutBuffer[0] = USB_status_device;
0828  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
082A  6EEA      	MOVWF FSR0H
082C  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
082E  6EE9      	MOVWF FSR0L
0830  0101      	MOVLB 0x01
0832  6B29      	CLRF CompTempVar677, 1
0834  5129      	MOVF CompTempVar677, W, 1
0836  26E9      	ADDWF FSR0L, F
0838  0100      	MOVLB 0x00
083A  51EF      	MOVF gbl_USB_status_device, W, 1
083C  6EEF      	MOVWF INDF0

				        OutBuffer[1] = 0;
083E  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0840  6EE9      	MOVWF FSR0L
0842  0E01      	MOVLW 0x01
0844  26E9      	ADDWF FSR0L, F
0846  0E00      	MOVLW 0x00
0848  6EEF      	MOVWF INDF0

				        bd0cntie = 2;
084A  0E02      	MOVLW 0x02
084C  0104      	MOVLB 0x04
084E  6F05      	MOVWF gbl_bd0cntie, 1

				        bd0statie = 0xc8;
0850  0EC8      	MOVLW 0xC8
0852  6F04      	MOVWF gbl_bd0statie, 1

				        break;
			        default:
				        break;
			    }
			    break;
            // Fifth bmRequestType ************************************	
		    case INTERFACETOHOST:
02E2  0E81      	MOVLW 0x81
02E4  63C1      	CPFSEQ gbl_BufferCopy, 1
02E6  D001      	BRA	label15
02E8  D2B6      	BRA	label68
02EA            label15
0856            label68

			    switch (BufferCopy.bRequest) {
			        case GET_INTERFACE:
0856  0E0A      	MOVLW 0x0A
0858  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
085A  D001      	BRA	label69
085C  D006      	BRA	label70
085E            label69
086A            label70

				        Interface = BufferCopy.wIndex;
086A  51C5      	MOVF gbl_BufferCopy+D'4', W, 1
086C  0101      	MOVLB 0x01
086E  6F21      	MOVWF Process_Re_0000D_1_Interface, 1

				        if ((USWSTAT== CONFIG_STATE) && (Interface < NUM_INTERFACES)) {
0870  0E03      	MOVLW 0x03
0872  0100      	MOVLB 0x00
0874  63F6      	CPFSEQ gbl_USWSTAT, 1
0876  D02C      	BRA	label71
0878  0E01      	MOVLW 0x01
087A  0101      	MOVLB 0x01
087C  6121      	CPFSLT Process_Re_0000D_1_Interface, 1
087E  D028      	BRA	label71
08D0            label71

					        OutBuffer = (unsigned char *) BDT [EP0IN].address;
0880  0100      	MOVLB 0x00
0882  51E9      	MOVF gbl_BDT+D'1', W, 1
0884  6EEA      	MOVWF FSR0H
0886  51E8      	MOVF gbl_BDT, W, 1
0888  6EE9      	MOVWF FSR0L
088A  0E04      	MOVLW 0x04
088C  26E9      	ADDWF FSR0L, F
088E  0E02      	MOVLW 0x02
0890  26E9      	ADDWF FSR0L, F
0892  50EE      	MOVF POSTINC0, W
0894  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0896  50EF      	MOVF INDF0, W
0898  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

					        OutBuffer[0] = USB_Interface[Interface];
089A  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
089E  50E9      	MOVF FSR0L, W
08A0  0101      	MOVLB 0x01
08A2  5121      	MOVF Process_Re_0000D_1_Interface, W, 1
08A4  6F2A      	MOVWF CompTempVar683, 1
08A6  512A      	MOVF CompTempVar683, W, 1
08A8  26E9      	ADDWF FSR0L, F
08AA  50EF      	MOVF INDF0, W
08AC  6F2B      	MOVWF CompTempVar684, 1
08AE  0100      	MOVLB 0x00
08B0  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
08B2  6EEA      	MOVWF FSR0H
08B4  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
08B6  6EE9      	MOVWF FSR0L
08B8  0101      	MOVLB 0x01
08BA  6B29      	CLRF CompTempVar681, 1
08BC  5129      	MOVF CompTempVar681, W, 1
08BE  26E9      	ADDWF FSR0L, F
08C0  512B      	MOVF CompTempVar684, W, 1
08C2  6EEF      	MOVWF INDF0

					        bd0cntie = 1;
08C4  0E01      	MOVLW 0x01
08C6  0104      	MOVLB 0x04
08C8  6F05      	MOVWF gbl_bd0cntie, 1

					        bd0statie = 0xc8;
08CA  0EC8      	MOVLW 0xC8
08CC  6F04      	MOVWF gbl_bd0statie, 1

				        } else {
					        STALL_EP0;
08D0  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case GET_STATUS:
085E  53C2      	MOVF gbl_BufferCopy+D'1', F, 1
0860  E039      	BZ	label72
08D4            label72

				        OutBuffer = (unsigned char *) BDT [EP0IN].address;
08D4  51E9      	MOVF gbl_BDT+D'1', W, 1
08D6  6EEA      	MOVWF FSR0H
08D8  51E8      	MOVF gbl_BDT, W, 1
08DA  6EE9      	MOVWF FSR0L
08DC  0E04      	MOVLW 0x04
08DE  26E9      	ADDWF FSR0L, F
08E0  0E02      	MOVLW 0x02
08E2  26E9      	ADDWF FSR0L, F
08E4  50EE      	MOVF POSTINC0, W
08E6  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
08E8  50EF      	MOVF INDF0, W
08EA  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				        OutBuffer[1] = 0;
08EC  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
08EE  6EEA      	MOVWF FSR0H
08F0  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
08F2  6EE9      	MOVWF FSR0L
08F4  0E01      	MOVLW 0x01
08F6  26E9      	ADDWF FSR0L, F
08F8  0E00      	MOVLW 0x00
08FA  6EEF      	MOVWF INDF0

				        bd0cntie = 2;
08FC  0E02      	MOVLW 0x02
08FE  0104      	MOVLB 0x04
0900  6F05      	MOVWF gbl_bd0cntie, 1

				        Interface = BufferCopy.wIndex;
0902  0100      	MOVLB 0x00
0904  51C5      	MOVF gbl_BufferCopy+D'4', W, 1
0906  0101      	MOVLB 0x01
0908  6F21      	MOVWF Process_Re_0000D_1_Interface, 1

				        if ((USWSTAT == ADDRESS_STATE) && (Interface == 0))	{
090A  0E02      	MOVLW 0x02
090C  0100      	MOVLB 0x00
090E  63F6      	CPFSEQ gbl_USWSTAT, 1
0910  D01B      	BRA	label73
0912  0101      	MOVLB 0x01
0914  5321      	MOVF Process_Re_0000D_1_Interface, F, 1
0916  E118      	BNZ	label73
0948            label73

					        OutBuffer[0] = USB_Interface[Interface];
0918  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
091C  50E9      	MOVF FSR0L, W
091E  5121      	MOVF Process_Re_0000D_1_Interface, W, 1
0920  6F2A      	MOVWF CompTempVar690, 1
0922  512A      	MOVF CompTempVar690, W, 1
0924  26E9      	ADDWF FSR0L, F
0926  50EF      	MOVF INDF0, W
0928  6F2B      	MOVWF CompTempVar691, 1
092A  0100      	MOVLB 0x00
092C  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
092E  6EEA      	MOVWF FSR0H
0930  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0932  6EE9      	MOVWF FSR0L
0934  0101      	MOVLB 0x01
0936  6B29      	CLRF CompTempVar688, 1
0938  5129      	MOVF CompTempVar688, W, 1
093A  26E9      	ADDWF FSR0L, F
093C  512B      	MOVF CompTempVar691, W, 1
093E  6EEF      	MOVWF INDF0

					        bd0statie = 0xc8;
0940  0EC8      	MOVLW 0xC8
0942  0104      	MOVLB 0x04
0944  6F04      	MOVWF gbl_bd0statie, 1

                        } else if ((USWSTAT == CONFIG_STATE) && (Interface < NUM_INTERFACES)) {
0948  0E03      	MOVLW 0x03
094A  0100      	MOVLB 0x00
094C  63F6      	CPFSEQ gbl_USWSTAT, 1
094E  D01C      	BRA	label74
0950  0E01      	MOVLW 0x01
0952  0101      	MOVLB 0x01
0954  6121      	CPFSLT Process_Re_0000D_1_Interface, 1
0956  D018      	BRA	label74
0988            label74

					        OutBuffer[0] = USB_Interface[Interface];
0958  EE00F0D1  	LFSR 0x00,  gbl_USB_Interface
095C  50E9      	MOVF FSR0L, W
095E  5121      	MOVF Process_Re_0000D_1_Interface, W, 1
0960  6F2A      	MOVWF CompTempVar695, 1
0962  512A      	MOVF CompTempVar695, W, 1
0964  26E9      	ADDWF FSR0L, F
0966  50EF      	MOVF INDF0, W
0968  6F2B      	MOVWF CompTempVar696, 1
096A  0100      	MOVLB 0x00
096C  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
096E  6EEA      	MOVWF FSR0H
0970  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0972  6EE9      	MOVWF FSR0L
0974  0101      	MOVLB 0x01
0976  6B29      	CLRF CompTempVar693, 1
0978  5129      	MOVF CompTempVar693, W, 1
097A  26E9      	ADDWF FSR0L, F
097C  512B      	MOVF CompTempVar696, W, 1
097E  6EEF      	MOVWF INDF0

					        bd0statie = 0xc8;
0980  0EC8      	MOVLW 0xC8
0982  0104      	MOVLB 0x04
0984  6F04      	MOVWF gbl_bd0statie, 1

				        } else {
					        STALL_EP0;
0988  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case GET_DESCRIPTOR:
0862  0E06      	MOVLW 0x06
0864  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0868  D091      	BRA	label75
098C            label75

				        DescriptorType = BufferCopy.wValue >> 8;
098C  51C4      	MOVF gbl_BufferCopy+D'3', W, 1
098E  0101      	MOVLB 0x01
0990  6F1F      	MOVWF Process_Re_0000D_1_Descrip_0000E, 1

                        if (DescriptorType == HID_REPORT_DESCRIPTOR) {
0992  0E22      	MOVLW 0x22
0994  631F      	CPFSEQ Process_Re_0000D_1_Descrip_0000E, 1
0996  D032      	BRA	label77
09FC            label77

                            /* 22 special HID request to return report descriptor */
					        USB_dev_req = GET_DESCRIPTOR;
0998  0E06      	MOVLW 0x06
099A  0100      	MOVLB 0x00
099C  6FF2      	MOVWF gbl_USB_dev_req, 1

					        if (BufferCopy.wIndex == 0);
099E  53C5      	MOVF gbl_BufferCopy+D'4', F, 1
09A0  B4D8      	BTFSC STATUS,Z
09A2  53C6      	MOVF gbl_BufferCopy+D'5', F, 1

					        {
						        EP0_start = ReportDescriptor1;
09A4  0E00      	MOVLW HIGH(gbl_ReportDescriptor1+D'0')
09A6  6FE5      	MOVWF gbl_EP0_start+D'1', 1
09A8  0E60      	MOVLW LOW(gbl_ReportDescriptor1+D'0')
09AA  6FE4      	MOVWF gbl_EP0_start, 1

				                EP0_end = EP0_start + sizeof(ReportDescriptor1);
09AC  6BE7      	CLRF gbl_EP0_end+D'1', 1
09AE  0E32      	MOVLW 0x32
09B0  25E4      	ADDWF gbl_EP0_start, W, 1
09B2  6FE6      	MOVWF gbl_EP0_end, 1
09B4  51E5      	MOVF gbl_EP0_start+D'1', W, 1
09B6  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

						        EP0_maxLength = 8;
09B8  0E08      	MOVLW 0x08
09BA  6FF7      	MOVWF gbl_EP0_maxLength, 1

				                if (BufferCopy.wLength < sizeof (ReportDescriptor1))
09BC  0E32      	MOVLW 0x32
09BE  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
09C0  E215      	BC	label76
09C2  67C8      	TSTFSZ gbl_BufferCopy+D'7', 1
09C4  D013      	BRA	label76
09EC            label76

							        EP0_end = EP0_start + BufferCopy.wLength;
09C6  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
09C8  25E4      	ADDWF gbl_EP0_start, W, 1
09CA  0101      	MOVLB 0x01
09CC  6F29      	MOVWF CompTempVar700, 1
09CE  0100      	MOVLB 0x00
09D0  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
09D2  0101      	MOVLB 0x01
09D4  6F2A      	MOVWF CompTempVar701, 1
09D6  0100      	MOVLB 0x00
09D8  51E5      	MOVF gbl_EP0_start+D'1', W, 1
09DA  0101      	MOVLB 0x01
09DC  232A      	ADDWFC CompTempVar701, F, 1
09DE  5129      	MOVF CompTempVar700, W, 1
09E0  0100      	MOVLB 0x00
09E2  6FE6      	MOVWF gbl_EP0_end, 1
09E4  0101      	MOVLB 0x01
09E6  512A      	MOVF CompTempVar701, W, 1
09E8  0100      	MOVLB 0x00
09EA  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						        CopyDescriptorToEP0();
09EC  EC5BF000  	CALL CopyDescri_0000B

					        }
					        if (BufferCopy.wIndex == 1);
09F0  0E01      	MOVLW 0x01
09F2  0100      	MOVLB 0x00
09F4  63C5      	CPFSEQ gbl_BufferCopy+D'4', 1
09F8  51C6      	MOVF gbl_BufferCopy+D'5', W, 1

					        {
					            /* Repeat above code for another Report Descriptor. */
					        }
				        } else if (DescriptorType == HID_DESCRIPTOR) {
09FC  0E21      	MOVLW 0x21
09FE  631F      	CPFSEQ Process_Re_0000D_1_Descrip_0000E, 1
0A00  D033      	BRA	label80
0A68            label80

				            /* 21 HID descriptor */
					        USB_dev_req = GET_DESCRIPTOR;
0A02  0E06      	MOVLW 0x06
0A04  0100      	MOVLB 0x00
0A06  6FF2      	MOVWF gbl_USB_dev_req, 1

					        if (BufferCopy.wIndex == 0) {
0A08  53C5      	MOVF gbl_BufferCopy+D'4', F, 1
0A0A  E128      	BNZ	label79
0A0C  53C6      	MOVF gbl_BufferCopy+D'5', F, 1
0A0E  E126      	BNZ	label79
0A5C            label79

						        EP0_start = HIDDescriptor;
0A10  0E00      	MOVLW HIGH(gbl_HIDDescriptor+D'0')
0A12  6FE5      	MOVWF gbl_EP0_start+D'1', 1
0A14  0EB8      	MOVLW LOW(gbl_HIDDescriptor+D'0')
0A16  6FE4      	MOVWF gbl_EP0_start, 1

						        EP0_end   = EP0_start + sizeof (HIDDescriptor);
0A18  6BE7      	CLRF gbl_EP0_end+D'1', 1
0A1A  0E09      	MOVLW 0x09
0A1C  25E4      	ADDWF gbl_EP0_start, W, 1
0A1E  6FE6      	MOVWF gbl_EP0_end, 1
0A20  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0A22  23E7      	ADDWFC gbl_EP0_end+D'1', F, 1

						        EP0_maxLength = 8;
0A24  0E08      	MOVLW 0x08
0A26  6FF7      	MOVWF gbl_EP0_maxLength, 1

						        if (BufferCopy.wLength < sizeof (HIDDescriptor))
0A28  0E09      	MOVLW 0x09
0A2A  5DC7      	SUBWF gbl_BufferCopy+D'6', W, 1
0A2C  E215      	BC	label78
0A2E  67C8      	TSTFSZ gbl_BufferCopy+D'7', 1
0A30  D013      	BRA	label78
0A58            label78

							        EP0_end = EP0_start + BufferCopy.wLength;
0A32  51C7      	MOVF gbl_BufferCopy+D'6', W, 1
0A34  25E4      	ADDWF gbl_EP0_start, W, 1
0A36  0101      	MOVLB 0x01
0A38  6F29      	MOVWF CompTempVar705, 1
0A3A  0100      	MOVLB 0x00
0A3C  51C8      	MOVF gbl_BufferCopy+D'7', W, 1
0A3E  0101      	MOVLB 0x01
0A40  6F2A      	MOVWF CompTempVar706, 1
0A42  0100      	MOVLB 0x00
0A44  51E5      	MOVF gbl_EP0_start+D'1', W, 1
0A46  0101      	MOVLB 0x01
0A48  232A      	ADDWFC CompTempVar706, F, 1
0A4A  5129      	MOVF CompTempVar705, W, 1
0A4C  0100      	MOVLB 0x00
0A4E  6FE6      	MOVWF gbl_EP0_end, 1
0A50  0101      	MOVLB 0x01
0A52  512A      	MOVF CompTempVar706, W, 1
0A54  0100      	MOVLB 0x00
0A56  6FE7      	MOVWF gbl_EP0_end+D'1', 1

						        CopyDescriptorToEP0();
0A58  EC5BF000  	CALL CopyDescri_0000B

					        }
					        if (BufferCopy.wIndex == 1) {
0A5C  0E01      	MOVLW 0x01
0A5E  0100      	MOVLB 0x00
0A60  63C5      	CPFSEQ gbl_BufferCopy+D'4', 1
0A64  51C6      	MOVF gbl_BufferCopy+D'5', W, 1

						        /* Repeat above code for another HID Descriptor. */
					        }
				        } else {
                            /* unrecognised request */
					        STALL_EP0;
0A68  8070      	BSF gbl_uep0,0

                        }
				        break;
			        default:
				        break;
			    }
			    break;
            // Sixth bmRequestType ************************************	
		    case ENDPOINTTOHOST:
02EA  0E82      	MOVLW 0x82
02EC  63C1      	CPFSEQ gbl_BufferCopy, 1
02EE  EF82F005  	GOTO	label83
0A6C            label81

			    if (BufferCopy.bRequest == GET_STATUS) {   
0A6C  53C2      	MOVF gbl_BufferCopy+D'1', F, 1
0A6E  A4D8      	BTFSS STATUS,Z

				    UEPArray = (unsigned char *) &uep0;
0A72  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0A74  0101      	MOVLB 0x01
0A76  6F29      	MOVWF CompTempVar707, 1
0A78  0E70      	MOVLW LOW(gbl_uep0+D'0')
0A7A  6F1D      	MOVWF Process_Re_0000D_1_UEPArray, 1
0A7C  5129      	MOVF CompTempVar707, W, 1
0A7E  6F1E      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1

				    Endpoint = BufferCopy.wIndex & 0x0F;
0A80  0E0F      	MOVLW 0x0F
0A82  0100      	MOVLB 0x00
0A84  15C5      	ANDWF gbl_BufferCopy+D'4', W, 1
0A86  0101      	MOVLB 0x01
0A88  6F20      	MOVWF Process_Re_0000D_1_Endpoint, 1

                    OutBuffer = (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie << 8));
0A8A  0104      	MOVLB 0x04
0A8C  5106      	MOVF gbl_bd0adrlie, W, 1
0A8E  0101      	MOVLB 0x01
0A90  6F29      	MOVWF CompTempVar708, 1
0A92  6B2C      	CLRF CompTempVar710+D'1', 1
0A94  6B2D      	CLRF CompTempVar711, 1
0A96  0104      	MOVLB 0x04
0A98  5107      	MOVF gbl_bd0adrhie, W, 1
0A9A  0101      	MOVLB 0x01
0A9C  6F2A      	MOVWF CompTempVar709, 1
0A9E  512D      	MOVF CompTempVar711, W, 1
0AA0  2729      	ADDWF CompTempVar708, F, 1
0AA2  512C      	MOVF CompTempVar710+D'1', W, 1
0AA4  232A      	ADDWFC CompTempVar709, F, 1
0AA6  5129      	MOVF CompTempVar708, W, 1
0AA8  0100      	MOVLB 0x00
0AAA  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0AAC  0101      	MOVLB 0x01
0AAE  512A      	MOVF CompTempVar709, W, 1
0AB0  0100      	MOVLB 0x00
0AB2  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

		            //		OutBuffer = (unsigned char * ) bd0adrlie;
				    OutBuffer[1] = 0;
0AB4  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0AB6  6EEA      	MOVWF FSR0H
0AB8  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0ABA  6EE9      	MOVWF FSR0L
0ABC  0E01      	MOVLW 0x01
0ABE  26E9      	ADDWF FSR0L, F
0AC0  0E00      	MOVLW 0x00
0AC2  6EEF      	MOVWF INDF0

				    bd0cntie = 2;
0AC4  0E02      	MOVLW 0x02
0AC6  0104      	MOVLB 0x04
0AC8  6F05      	MOVWF gbl_bd0cntie, 1


				    if (Endpoint < 3) {
0ACA  0E03      	MOVLW 0x03
0ACC  0101      	MOVLB 0x01
0ACE  6120      	CPFSLT Process_Re_0000D_1_Endpoint, 1
0AD0  D017      	BRA	label82
0B00            label82

					    OutBuffer[0] = UEPArray [Endpoint] & 0x01;
0AD2  511E      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0AD4  6EEA      	MOVWF FSR0H
0AD6  511D      	MOVF Process_Re_0000D_1_UEPArray, W, 1
0AD8  2520      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
0ADA  6EE9      	MOVWF FSR0L
0ADC  0E01      	MOVLW 0x01
0ADE  14EF      	ANDWF INDF0, W
0AE0  6F2A      	MOVWF CompTempVar719, 1
0AE2  0100      	MOVLB 0x00
0AE4  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0AE6  6EEA      	MOVWF FSR0H
0AE8  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0AEA  6EE9      	MOVWF FSR0L
0AEC  0101      	MOVLB 0x01
0AEE  6B29      	CLRF CompTempVar715, 1
0AF0  5129      	MOVF CompTempVar715, W, 1
0AF2  26E9      	ADDWF FSR0L, F
0AF4  512A      	MOVF CompTempVar719, W, 1
0AF6  6EEF      	MOVWF INDF0

					    bd0statie = 0xc8;
0AF8  0EC8      	MOVLW 0xC8
0AFA  0104      	MOVLB 0x04
0AFC  6F04      	MOVWF gbl_bd0statie, 1

				    } else {
					    STALL_EP0;
0B00  8070      	BSF gbl_uep0,0

                    }
			    }
			    break;
            // Seventh bmRequestType (others) ************************************	
		    default:
0B04            label83

		        if (BufferCopy.bmRequestType & 0x20) {
0B04  ABC1      	BTFSS gbl_BufferCopy,5, 1

	                OutBuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));						
0B08  0104      	MOVLB 0x04
0B0A  5106      	MOVF gbl_bd0adrlie, W, 1
0B0C  0101      	MOVLB 0x01
0B0E  6F29      	MOVWF CompTempVar720, 1
0B10  6B2C      	CLRF CompTempVar722+D'1', 1
0B12  6B2D      	CLRF CompTempVar723, 1
0B14  0104      	MOVLB 0x04
0B16  5107      	MOVF gbl_bd0adrhie, W, 1
0B18  0101      	MOVLB 0x01
0B1A  6F2A      	MOVWF CompTempVar721, 1
0B1C  512D      	MOVF CompTempVar723, W, 1
0B1E  2729      	ADDWF CompTempVar720, F, 1
0B20  512C      	MOVF CompTempVar722+D'1', W, 1
0B22  232A      	ADDWFC CompTempVar721, F, 1
0B24  5129      	MOVF CompTempVar720, W, 1
0B26  0100      	MOVLB 0x00
0B28  6FFE      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0B2A  0101      	MOVLB 0x01
0B2C  512A      	MOVF CompTempVar721, W, 1
0B2E  0100      	MOVLB 0x00
0B30  6FFF      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				    switch (BufferCopy.bmRequestType) {
				        case 0x21:	
0B32  0E21      	MOVLW 0x21
0B34  63C1      	CPFSEQ gbl_BufferCopy, 1
0B36  D001      	BRA	label84
0B38  D014      	BRA	label89
0B3A            label84
0B62            label89

                            /* Host to Device HID request */
					        switch (BufferCopy.bRequest) {
					            case HID_SET_PROTOCOL:	
0B62  0E0B      	MOVLW 0x0B
0B64  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B66  D001      	BRA	label90
0B68  D008      	BRA	label92
0B6A            label90
0B7A            label92

                                    /* Set Protocol */
						            USB_protocol = BufferCopy.wValue;
0B7A  51C3      	MOVF gbl_BufferCopy+D'2', W, 1
0B7C  6FF5      	MOVWF gbl_USB_protocol, 1

						            Send_0Len_pkt;	
0B7E  0104      	MOVLB 0x04
0B80  6B05      	CLRF gbl_bd0cntie, 1
0B82  0EC8      	MOVLW 0xC8
0B84  6F04      	MOVWF gbl_bd0statie, 1
0B86  0100      	MOVLB 0x00
0B88  6BF2      	CLRF gbl_USB_dev_req, 1

						            break;
					            case HID_SET_REPORT:
0B6A  0E09      	MOVLW 0x09
0B6C  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B6E  D001      	BRA	label91
0B72            label91

                                    /* Set HID Report */
	                                // Add Set_Report Function above for OUT TOKEN and uncomment following two lines
					                //	USB_dev_req = HID_SET_REPORT;
						            break;
					            case HID_SET_IDLE:
0B72  0E0A      	MOVLW 0x0A
0B74  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B76  D00C      	BRA	label94
0B8C            label93

                                    /* Set Idle */
					                STALL_EP0;
0B8C  8070      	BSF gbl_uep0,0

					                break;
					            default:
0B90            label94

					                STALL_EP0;
0B90  8070      	BSF gbl_uep0,0

					        }
					        break;
				    case 0xA1:
0B3A  0EA1      	MOVLW 0xA1
0B3C  63C1      	CPFSEQ gbl_BufferCopy, 1
0B3E  D001      	BRA	label85
0B40  D029      	BRA	label95
0B42            label85
0B94            label95

                        /* Dev2HostHIDRequest */
						switch (BufferCopy.bRequest) {
					        case HID_GET_PROTOCOL:	/* Get Protocol */
0B94  0E03      	MOVLW 0x03
0B96  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0B98  D001      	BRA	label96
0B9A  D007      	BRA	label97
0B9C            label96
0BAA            label97

						        OutBuffer[0] = USB_protocol;
0BAA  51FF      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0BAC  6EEA      	MOVWF FSR0H
0BAE  51FE      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0BB0  6EE9      	MOVWF FSR0L
0BB2  0101      	MOVLB 0x01
0BB4  6B29      	CLRF CompTempVar726, 1
0BB6  5129      	MOVF CompTempVar726, W, 1
0BB8  26E9      	ADDWF FSR0L, F
0BBA  0100      	MOVLB 0x00
0BBC  51F5      	MOVF gbl_USB_protocol, W, 1
0BBE  6EEF      	MOVWF INDF0

						        bd0cntie = 1;
0BC0  0E01      	MOVLW 0x01
0BC2  0104      	MOVLB 0x04
0BC4  6F05      	MOVWF gbl_bd0cntie, 1

						        bd0statie = 0xC8;
0BC6  0EC8      	MOVLW 0xC8
0BC8  6F04      	MOVWF gbl_bd0statie, 1

						        break;
					        case HID_GET_REPORT: /* Get HID Report */
0B9C  05C2      	DECF gbl_BufferCopy+D'1', W, 1
0B9E  B4D8      	BTFSC STATUS,Z

	                            // Add Get_Report Function here and uncomment following two lines
			    		        //	BD0IST = 0xc8;	// Turn over BDT to SIE
						        break;
					        case HID_GET_IDLE:
0BA2  0E02      	MOVLW 0x02
0BA4  63C2      	CPFSEQ gbl_BufferCopy+D'1', 1
0BA6  D014      	BRA	label99
0BCC            label98

                                /* Get Idle */
					            STALL_EP0;
0BCC  8070      	BSF gbl_uep0,0

					            break;
					        default:
0BD0            label99

                                // device does not support get idle, just stall
					            STALL_EP0;
0BD0  8070      	BSF gbl_uep0,0

					    }
					    break;
				    case 0x22:
0B42  0E22      	MOVLW 0x22
0B44  63C1      	CPFSEQ gbl_BufferCopy, 1
0B46  D001      	BRA	label86
0B48  D045      	BRA	label100
0B4A            label86
0BD4            label100

                        /* Host2DevReportRequest */
					    STALL_EP0;
0BD4  8070      	BSF gbl_uep0,0

					    break;				
				    case 0x23:
0B4A  0E23      	MOVLW 0x23
0B4C  63C1      	CPFSEQ gbl_BufferCopy, 1
0B4E  D001      	BRA	label87
0B50  D043      	BRA	label101
0B52            label87
0BD8            label101

                        /* Host2DevPhysicalRequest */
					    STALL_EP0;
0BD8  8070      	BSF gbl_uep0,0

					    break;				
				    case 0xA2:
0B52  0EA2      	MOVLW 0xA2
0B54  63C1      	CPFSEQ gbl_BufferCopy, 1
0B56  D001      	BRA	label88
0B58  D041      	BRA	label102
0B5A            label88
0BDC            label102

                        /* Dev2HostReportRequest */
					    STALL_EP0;
0BDC  8070      	BSF gbl_uep0,0

					    break;				
				    case 0xA3:
0B5A  0EA3      	MOVLW 0xA3
0B5C  63C1      	CPFSEQ gbl_BufferCopy, 1
0B5E  D042      	BRA	label104
0BE0            label103

                        /* Dev2HostPhysicalRequest */
					    STALL_EP0;
0BE0  8070      	BSF gbl_uep0,0

					    break;				
				    default:
0BE4            label104

    				    STALL_EP0;
0BE4  8070      	BSF gbl_uep0,0

				}
			}
    	}
    }
}
01FC  0012      	RETURN
0202  0012      	RETURN
0208  0012      	RETURN
020A  0012      	RETURN
0222  0012      	RETURN
0228  0012      	RETURN
022A  0012      	RETURN
023A  0012      	RETURN
0328  0012      	RETURN
032C  0012      	RETURN
0350  0012      	RETURN
0354  0012      	RETURN
0374  0012      	RETURN
0378  0012      	RETURN
03AE  0012      	RETURN
03B2  0012      	RETURN
03F0  0012      	RETURN
03F4  0012      	RETURN
03F8  0012      	RETURN
044E  0012      	RETURN
047E  0012      	RETURN
0482  0012      	RETURN
0486  0012      	RETURN
04D4  0012      	RETURN
0504  0012      	RETURN
0508  0012      	RETURN
050C  0012      	RETURN
0510  0012      	RETURN
0528  0012      	RETURN
0570  0012      	RETURN
05F6  0012      	RETURN
0678  0012      	RETURN
0716  0012      	RETURN
078A  0012      	RETURN
07FE  0012      	RETURN
0806  0012      	RETURN
080E  0012      	RETURN
0854  0012      	RETURN
0866  0012      	RETURN
08CE  0012      	RETURN
08D2  0012      	RETURN
0946  0012      	RETURN
0986  0012      	RETURN
098A  0012      	RETURN
09F6  0012      	RETURN
09FA  0012      	RETURN
0A62  0012      	RETURN
0A66  0012      	RETURN
0A6A  0012      	RETURN
0A70  0012      	RETURN
0AFE  0012      	RETURN
0B02  0012      	RETURN
0B06  0012      	RETURN
0B70  0012      	RETURN
0B8A  0012      	RETURN
0B8E  0012      	RETURN
0B92  0012      	RETURN
0BA0  0012      	RETURN
0BCA  0012      	RETURN
0BCE  0012      	RETURN
0BD2  0012      	RETURN
0BD6  0012      	RETURN
0BDA  0012      	RETURN
0BDE  0012      	RETURN
0BE2  0012      	RETURN
0BE6  0012      	RETURN


/* ********************************************************************* */
/* Branch off and service the USB interrupt flags			 */
/* ********************************************************************* */
void ServiceUSB() {

	if (bTOK_DONE)
0C42  B668      	BTFSC gbl_bTOK_DONE,3

		Process_Req();
0C44  ECA5F000  	CALL Process_Re_0000D

	
    if (bSTALL)
0C48  BA68      	BTFSC gbl_bSTALL,5

		USBStall();
0C4A  EC9CF000  	CALL USBStall_00000

	
    if (bUERR)
0C4E  B268      	BTFSC gbl_bUERR,1

	    Count_Error();
0C50  ECF4F005  	CALL Count_Erro_0000C

	
    if (bUIDLE)	
0C54  B869      	BTFSC gbl_bUIDLE,4

		USBSleep();
0C56  EC9EF000  	CALL USBSleep_00000

}
0C5A  0012      	RETURN


////////////////////////////////////////////////////////////////
// Interrupt service routine. Branch off to different interrupts
////////////////////////////////////////////////////////////////	
void interrupt(void) {

    portb = 0; //clear indicator leds
116E  CFEAF001  	MOVFF FSR0H,  Int1Context
1172  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1176  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
117A  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
117E  6A81      	CLRF gbl_portb

	if (bUSBIE && bUSBIF) {
1180  AAA0      	BTFSS gbl_bUSBIE,5
1182  D026      	BRA	label131
1184  AAA1      	BTFSS gbl_bUSBIF,5
1186  D024      	BRA	label131
11D0            label131

		if (bACTIVITY && bACTIVITY_E) // WAS IT AN ACTIVITY WAKEUP?
1188  A468      	BTFSS gbl_bACTIVITY,2
118A  D004      	BRA	label126
118C  A469      	BTFSS gbl_bACTIVITY_E,2
118E  D002      	BRA	label126
1194            label126

			USBActivity ();
1190  EC55F000  	CALL USBActivit_0000A

		
        if (bUSBRST && bUSBRST_E) // USB reset must be serviced immediately
1194  A068      	BTFSS gbl_bUSBRST,0
1196  D004      	BRA	label127
1198  A069      	BTFSS gbl_bUSBRST_E,0
119A  D002      	BRA	label127
11A0            label127

			USBReset();
119C  EC3AF000  	CALL USBReset_00000

		
        if (bTOK_DONE && bTOK_DONE_E) { // WAS IT A TOKEN DONE 
11A0  A668      	BTFSS gbl_bTOK_DONE,3
11A2  D015      	BRA	label130
11A4  A669      	BTFSS gbl_bTOK_DONE_E,3
11A6  D013      	BRA	label130
11CE            label130

			if (USB_dev_req == SET_ADDRESS)	{
11A8  0E05      	MOVLW 0x05
11AA  0100      	MOVLB 0x00
11AC  63F2      	CPFSEQ gbl_USB_dev_req, 1
11AE  D00E      	BRA	label129

                // Finish Set Address
				USB_dev_req = NULL;
11B0  6BF2      	CLRF gbl_USB_dev_req, 1

				USB_Curr_Config = 0;
11B2  6BF0      	CLRF gbl_USB_Curr_Config, 1

				uaddr = USB_address_pending;
11B4  51F1      	MOVF gbl_USB_address_pending, W, 1
11B6  6E6E      	MOVWF gbl_uaddr

				uie = 00000001b;		// enable just the reset interrupt
11B8  0E01      	MOVLW 0x01
11BA  6E69      	MOVWF gbl_uie

 				if (USB_address_pending > 0)
11BC  0E00      	MOVLW 0x00
11BE  65F1      	CPFSGT gbl_USB_address_pending, 1
11C0  D003      	BRA	label128
11C8            label128

					USWSTAT= ADDRESS_STATE;
11C2  0E02      	MOVLW 0x02
11C4  6FF6      	MOVWF gbl_USWSTAT, 1

				else
11C6  D002      	BRA	label129
11CC            label129

					USWSTAT= DEFAULT_STATE;
11C8  0E01      	MOVLW 0x01
11CA  6FF6      	MOVWF gbl_USWSTAT, 1

			}
			bTOK_DONE = 0; // clear Token Done flag
11CC  9668      	BCF gbl_bTOK_DONE,3

		}
		bUSBIF = 0;	 // Clear USB interrupt flag
11CE  9AA1      	BCF gbl_bUSBIF,5

	}
}
11D0  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
11D4  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
11D8  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
11DC  C001FFEA  	MOVFF Int1Context,  FSR0H
11E0  0011      	RETFIE 1


//*****************************************************
//  AT LAST THE MAIN PROGRAM
//*****************************************************
void main() {

	unsigned char i;
	unsigned short j;
	signed char buffer[3];
    const signed char tablex [] = {-1, -1, -1, 1, 1, 1,  1,  1, 1, -1,  -1, -1};
0D2E  0101      	MOVLB 0x01
0D30  6900      	SETF main_1_tablex, 1
0D32  6901      	SETF main_1_tablex+D'1', 1
0D34  6902      	SETF main_1_tablex+D'2', 1
0D36  0E01      	MOVLW 0x01
0D38  6F03      	MOVWF main_1_tablex+D'3', 1
0D3A  6F04      	MOVWF main_1_tablex+D'4', 1
0D3C  6F05      	MOVWF main_1_tablex+D'5', 1
0D3E  6F06      	MOVWF main_1_tablex+D'6', 1
0D40  6F07      	MOVWF main_1_tablex+D'7', 1
0D42  6F08      	MOVWF main_1_tablex+D'8', 1
0D44  6909      	SETF main_1_tablex+D'9', 1
0D46  690A      	SETF main_1_tablex+D'10', 1
0D48  690B      	SETF main_1_tablex+D'11', 1

    const signed char tabley [] = {-1, 0, 1,  1,  0, -1, -1, 0,  1, 1, 0, -1 };
0D4A  690C      	SETF main_1_tabley, 1
0D4C  6B0D      	CLRF main_1_tabley+D'1', 1
0D4E  0E01      	MOVLW 0x01
0D50  6F0E      	MOVWF main_1_tabley+D'2', 1
0D52  6F0F      	MOVWF main_1_tabley+D'3', 1
0D54  6B10      	CLRF main_1_tabley+D'4', 1
0D56  6911      	SETF main_1_tabley+D'5', 1
0D58  6912      	SETF main_1_tabley+D'6', 1
0D5A  6B13      	CLRF main_1_tabley+D'7', 1
0D5C  0E01      	MOVLW 0x01
0D5E  6F14      	MOVWF main_1_tabley+D'8', 1
0D60  6F15      	MOVWF main_1_tabley+D'9', 1
0D62  6B16      	CLRF main_1_tabley+D'10', 1
0D64  6917      	SETF main_1_tabley+D'11', 1

	const unsigned char led[] = {1, 2, 4, 8, 16};
0D66  0E01      	MOVLW 0x01
0D68  6F18      	MOVWF main_1_led, 1
0D6A  0E02      	MOVLW 0x02
0D6C  6F19      	MOVWF main_1_led+D'1', 1
0D6E  0E04      	MOVLW 0x04
0D70  6F1A      	MOVWF main_1_led+D'2', 1
0D72  0E08      	MOVLW 0x08
0D74  6F1B      	MOVWF main_1_led+D'3', 1
0D76  0E10      	MOVLW 0x10
0D78  6F1C      	MOVWF main_1_led+D'4', 1

    // The table array contains the directional data for simulated mouse 
    // movement to form the infinity symbol (i.e. figure 8).   Movements are relative
    // to the previous position. 
	ddrb = 0;
0D7A  6A93      	CLRF gbl_ddrb

	for (i = 0; i < 5; i++) {
0D7C  0100      	MOVLB 0x00
0D7E  6BF8      	CLRF main_1_i, 1
0D80            label114
0D80  0E05      	MOVLW 0x05
0D82  61F8      	CPFSLT main_1_i, 1
0D84  D014      	BRA	label118
0DAA  2BF8      	INCF main_1_i, F, 1
0DAC  D7E9      	BRA	label114
0DAE            label118

	    portb = led[i]; // flash leds to make sure chip is running
0D86  EE01F018  	LFSR 0x00,  main_1_led
0D8A  50E9      	MOVF FSR0L, W
0D8C  51F8      	MOVF main_1_i, W, 1
0D8E  26E9      	ADDWF FSR0L, F
0D90  50EF      	MOVF INDF0, W
0D92  6E81      	MOVWF gbl_portb

	    for (j=0; j<64000; j++); // Small delay (greater than 16us) in order to
0D94  6BF9      	CLRF main_1_j, 1
0D96  6BFA      	CLRF main_1_j+D'1', 1
0D98            label115
0D98  0EFA      	MOVLW 0xFA
0D9A  5DFA      	SUBWF main_1_j+D'1', W, 1
0D9C  E102      	BNZ	label116
0D9E  0E00      	MOVLW 0x00
0DA0  5DF9      	SUBWF main_1_j, W, 1
0DA2            label116
0DA2  E203      	BC	label117
0DA4  4BF9      	INFSNZ main_1_j, F, 1
0DA6  2BFA      	INCF main_1_j+D'1', F, 1
0DA8  D7F7      	BRA	label115
0DAA            label117

	};

	InitUSB(); // allow SIE to come online before beginning USB initialization
0DAE  EC72F006  	CALL InitUSB_00000

	buffer[0] = 0;	//we won't be simulating mouse buttons		
0DB2  6BFB      	CLRF main_1_buffer, 1

	i = 10;
0DB4  0E0A      	MOVLW 0x0A
0DB6  6FF8      	MOVWF main_1_i, 1

	j = 0;
0DB8  6BF9      	CLRF main_1_j, 1
0DBA  6BFA      	CLRF main_1_j+D'1', 1

    t0con = 11000111b; //set up timer0 as 8 bit timer with prescaler of 256 and enable
0DBC  0EC7      	MOVLW 0xC7
0DBE  6ED5      	MOVWF gbl_t0con

    // 4/24* 10^6 * 256 * 256 = 10.9 msec timer overflow

	while (1) {
0DC0            label119
0E62  D7AE      	BRA	label119

		if (bTMR0IF) {	// Poll all functions every 10.9ms
0DC0  A4F2      	BTFSS gbl_bTMR0IF,2
0DC2  D021      	BRA	label121

			bTMR0IF = 0;   // clear the timer flag
0DC4  94F2      	BCF gbl_bTMR0IF,2

			ServiceUSB();	// Service USB functions
0DC6  EC21F006  	CALL ServiceUSB_00000

			if (isJiggling) {
0DCA  A05F      	BTFSS gbl_isJiggling,0
0DCC  D01C      	BRA	label121
0E06            label121

                // send same data 10 times (100 msec)
                if (i > 9) {
0DCE  0E09      	MOVLW 0x09
0DD0  0100      	MOVLB 0x00
0DD2  65F8      	CPFSGT main_1_i, 1
0DD4  D00A      	BRA	label120

                    i = 0;
0DD6  6BF8      	CLRF main_1_i, 1

                    j++;
0DD8  4BF9      	INFSNZ main_1_j, F, 1
0DDA  2BFA      	INCF main_1_j+D'1', F, 1

                    // (limit to length of table array)
                    if (j == 12)
0DDC  0E0C      	MOVLW 0x0C
0DDE  63F9      	CPFSEQ main_1_j, 1
0DE0  D004      	BRA	label120
0DE2  51FA      	MOVF main_1_j+D'1', W, 1
0DE4  E102      	BNZ	label120
0DEA            label120

                        j = 0;
0DE6  6BF9      	CLRF main_1_j, 1
0DE8  6BFA      	CLRF main_1_j+D'1', 1

                }
                // Increment infinity vectors
                buffer[1] = tablex[j];	// X vector 
0DEA  EE01F000  	LFSR 0x00,  main_1_tablex
0DEE  50E9      	MOVF FSR0L, W
0DF0  51F9      	MOVF main_1_j, W, 1
0DF2  26E9      	ADDWF FSR0L, F
0DF4  50EF      	MOVF INDF0, W
0DF6  6FFC      	MOVWF main_1_buffer+D'1', 1

                buffer[2] = tabley[j];	// Y vector
0DF8  EE01F00C  	LFSR 0x00,  main_1_tabley
0DFC  50E9      	MOVF FSR0L, W
0DFE  51F9      	MOVF main_1_j, W, 1
0E00  26E9      	ADDWF FSR0L, F
0E02  50EF      	MOVF INDF0, W
0E04  6FFD      	MOVWF main_1_buffer+D'2', 1

            }
        }
        if (ConfiguredUSB()) {
0E06  0E03      	MOVLW 0x03
0E08  0100      	MOVLB 0x00
0E0A  15F6      	ANDWF gbl_USWSTAT, W, 1
0E0C  6FFE      	MOVWF CompTempVar733, 1
0E0E  0E03      	MOVLW 0x03
0E10  63FE      	CPFSEQ CompTempVar733, 1
0E12  D00D      	BRA	label122

            // Wait until device is configured before using EP1.  If Endpoints 1 or 2 are used before
			//   the device is configured, errors will occur.
		    if (PutEP1(3, buffer)) {
0E14  0E03      	MOVLW 0x03
0E16  6FFE      	MOVWF PutEP1_00000_arg_bytes, 1
0E18  0E00      	MOVLW HIGH(main_1_buffer+D'0')
0E1A  0101      	MOVLB 0x01
0E1C  6F1E      	MOVWF PutEP1_00000_arg_buffer+D'1', 1
0E1E  0EFB      	MOVLW LOW(main_1_buffer+D'0')
0E20  6F1D      	MOVWF PutEP1_00000_arg_buffer, 1
0E22  EC2EF006  	CALL PutEP1_00000
0E26  5322      	MOVF CompTempVarRet569, F, 1
0E28  E002      	BZ	label122

                // Increment i if EP1 IN buffer is accessible
                i++;
0E2A  0100      	MOVLB 0x00
0E2C  2BF8      	INCF main_1_i, F, 1

                //   to the PIC.  If not accessible, try again next time.
            }
		}
        
        // Check for button press
        if (buttonOld != BUTTON) {
0E2E  0E00      	MOVLW 0x00
0E30  B481      	BTFSC gbl_portb,2
0E32  0A01      	XORLW 0x01
0E34  B25F      	BTFSC gbl_buttonOld,1
0E36  0A01      	XORLW 0x01
0E38  0BFF      	ANDLW 0xFF
0E3A  E010      	BZ	label124

            if(!BUTTON) {
0E3C  B481      	BTFSC gbl_portb,2
0E3E  D00E      	BRA	label124

                delay_ms(100);
0E40  0E64      	MOVLW 0x64
0E42  0100      	MOVLB 0x00
0E44  6FFE      	MOVWF delay_ms_00000_arg_del, 1
0E46  EC06F000  	CALL delay_ms_00000

                if(!BUTTON) {
0E4A  B481      	BTFSC gbl_portb,2
0E4C  D007      	BRA	label124

                    if (!isJiggling) {
0E4E  B05F      	BTFSC gbl_isJiggling,0
0E50  D003      	BRA	label123
0E58            label123

                        isJiggling = 1;
0E52  805F      	BSF gbl_isJiggling,0

                        LED = 1;
0E54  8281      	BSF gbl_portb,1

                    } else {
0E56  D002      	BRA	label124
0E5C            label124

                        isJiggling = 0;
0E58  905F      	BCF gbl_isJiggling,0

                        LED = 0;
0E5A  9281      	BCF gbl_portb,1

                    }
                }
            }
        }
        buttonOld = BUTTON;
0E5C  925F      	BCF gbl_buttonOld,1
0E5E  B481      	BTFSC gbl_portb,2
0E60  825F      	BSF gbl_buttonOld,1

	}
}

}
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF32F007  	GOTO	_startup

0008  EFB7F008  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53FE      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF9      	MOVLW 0xF9
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0FFF      	ADDLW 0xFF
0040  A4D8      	BTFSS STATUS,Z
0042  D7E9      	BRA	label2
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  0000      	NOP
0062  0000      	NOP
0064  0000      	NOP
0066  0000      	NOP
0068  0000      	NOP
006A  0000      	NOP
006C  0000      	NOP
006E  2FFE      	DECFSZ delay_ms_00000_arg_del, F, 1
0070  D7D1      	BRA	label1
0072  0012      	RETURN
0074            ; } delay_ms function end



































0E64            _startup

116A  EF97F006  	GOTO	main

300000  0E30      	DW 0x0E30
300002  1E3E      	DW 0x1E3E
300004  00FF      	DW 0x00FF
300006  FF80      	DW 0xFF80
300008  C00F      	DW 0xC00F
30000A  E00F      	DW 0xE00F
30000C  400F      	DW 0x400F
