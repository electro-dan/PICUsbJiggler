;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PICUSBJIGGLER_H_
#define _PICUSBJIGGLER_H_

#define LED (portb.1) // LED pin
#define BUTTON (portb.2) // Button (switch) pin

bit isJiggling = 0; // When 0, device does nothing
0E2A  91E5      	BCF gbl_isJiggling,0, 1

char buttonState = 0xFF; // Records state every 10.9ms
0E2C  69E6      	SETF gbl_buttonState, 1


#define TRUE   1
#define FALSE  0
#define NULL   0

#define DEBUG_SERIAL 	1
#define NUM_CONFIGURATIONS      1
#define NUM_INTERFACES          1

#define ConfiguredUSB() ((USWSTAT&0x3) == CONFIG_STATE)
#define STALL_EP0    	set_bit(uep0,EPSTALL)
#define STALL_PID_EP0IN 	bd0statie = 0xCC  /* REQUEST ERROR */
#define Send_0Len_pkt	bd0cntie = 0;	bd0statie = 0xc8;	USB_dev_req = NULL

#define POWERED_STATE	        0x00
#define DEFAULT_STATE	        0x01
#define ADDRESS_STATE	        0x02
#define CONFIG_STATE	        0x03
#define ENDPT_DISABLED	        0x10  // For 18F2455 with handshaking
#define ENDPT_IN_ONLY	        0x12
#define ENDPT_OUT_ONLY	        0x14
#define ENDPT_CONTROL	        0x16	/* enable for in, out and setup */
#define ENDPT_NON_CONTROL		0x1E	/* enable for in, and out */
#define TOKEN_OUT	(0x01<<2)
#define TOKEN_ACK	(0x02<<2)
#define TOKEN_IN	(0x09<<2)
#define TOKEN_SETUP	(0x0D<<2)
#define CLEAR_FEATURE	        0x01
#define GET_CONFIGURATION	0x08
#define GET_DESCRIPTOR	        0x06
#define GET_INTERFACE	        0x0A
#define GET_STATUS	        0x00
#define SET_ADDRESS	        0x05
#define SET_CONFIGURATION	0x09
#define SET_FEATURE	        0x03
#define SET_INTERFACE	        0x0B
#define HID_GET_REPORT		0x01
#define	HID_GET_IDLE		0x02
#define	HID_GET_PROTOCOL	0x03
#define HID_SET_REPORT		0x09
#define HID_SET_IDLE		0x0A
#define HID_SET_PROTOCOL	0x0B
#define HID_REPORT_DESCRIPTOR 	0x22
#define HID_DESCRIPTOR 			0x21
#define VEND_SET_MEMORY	        0x80
#define HOSTTODEVICE            0x00
#define HOSTTOINTERFACE         0x01
#define HOSTTOENDPOINT          0x02
#define DEVICETOHOST            0x80
#define INTERFACETOHOST         0x81
#define ENDPOINTTOHOST          0x82
#define EP0OUT                  0
#define EP0IN                   1
#define EP1OUT                  2
#define EP1IN                   3
#define EP2OUT                  4
#define EP2IN                   5

// Descriptor Types
#define DEVICE                  1
#define CONFIGURATION           2
#define STRING                  3
#define INTERFACE               4
#define ENDPOINT                5
#define CS_INTERFACE            0x24
#define CS_ENDPOINT             0x25

// BUFFER REGISTERS
// NAMING CONVENTION bdNXXXXDP  where 
// N is endpoint# = 0,1,2,3
// XXXX is the type: stat, cnt, adrl or adrh
// D is direction=i,o (in,out) 
// P is pingpong=e,o  (even,odd)
/* non-pingpong buffering, 8 byte buffers*/
char bd0statoe@0x400;
char bd0cntoe@0x401 = 8;
0E2E  0E08      	MOVLW 0x08
0E30  0104      	MOVLB 0x04
0E32  6F01      	MOVWF gbl_bd0cntoe, 1

char bd0adrloe@0x402 = 0x00;
0E34  6B02      	CLRF gbl_bd0adrloe, 1

char bd0adrhoe@0x403 = 0x05;
0E36  0E05      	MOVLW 0x05
0E38  6F03      	MOVWF gbl_bd0adrhoe, 1


char bd0statie@0x404;
char bd0cntie@0x405 = 8;
0E3A  0E08      	MOVLW 0x08
0E3C  6F05      	MOVWF gbl_bd0cntie, 1

char bd0adrlie@0x406 = 0x80;
0E3E  0E80      	MOVLW 0x80
0E40  6F06      	MOVWF gbl_bd0adrlie, 1

char bd0adrhie@0x407 = 0x05;
0E42  0E05      	MOVLW 0x05
0E44  6F07      	MOVWF gbl_bd0adrhie, 1


char bd1statoe@0x408;
char bd1cntoe@0x409 = 8;
0E46  0E08      	MOVLW 0x08
0E48  6F09      	MOVWF gbl_bd1cntoe, 1

char bd1adrloe@0x40A = 0x00;
0E4A  6B0A      	CLRF gbl_bd1adrloe, 1

char bd1adrhoe@0x40B = 0x06;
0E4C  0E06      	MOVLW 0x06
0E4E  6F0B      	MOVWF gbl_bd1adrhoe, 1


char bd1statie@0x40C;
char bd1cntie@0x40D = 8;
0E50  0E08      	MOVLW 0x08
0E52  6F0D      	MOVWF gbl_bd1cntie, 1

char bd1adrlie@0x40E = 0x80;
0E54  0E80      	MOVLW 0x80
0E56  6F0E      	MOVWF gbl_bd1adrlie, 1

char bd1adrhie@0x40F = 0x06;
0E58  0E06      	MOVLW 0x06
0E5A  6F0F      	MOVWF gbl_bd1adrhie, 1


char bd2statoe@0x410;
char bd2cntoe@0x411 = 8;
0E5C  0E08      	MOVLW 0x08
0E5E  6F11      	MOVWF gbl_bd2cntoe, 1

char bd2adrloe@0x412 = 0x00;
0E60  6B12      	CLRF gbl_bd2adrloe, 1

char bd2adrhoe@0x413 = 0x07;
0E62  0E07      	MOVLW 0x07
0E64  6F13      	MOVWF gbl_bd2adrhoe, 1


char bd2statie@0x414;
char bd2cntie@0x415 = 8;
0E66  0E08      	MOVLW 0x08
0E68  6F15      	MOVWF gbl_bd2cntie, 1

char bd2adrlie@0x416 = 0x80;
0E6A  0E80      	MOVLW 0x80
0E6C  6F16      	MOVWF gbl_bd2adrlie, 1

char bd2adrhie@0x417 = 0x07;
0E6E  0E07      	MOVLW 0x07
0E70  6F17      	MOVWF gbl_bd2adrhie, 1



#endif //_PICUSBJIGGLER_H_

//###########################################################################
// filename:		PICUsbJiggler.c
//##########################################################################
// The Jiggle Mouse - Program causes the mouse pointer to move in a figure 8 
//		(infinity) shape. Modified by electro-dan to switch on/off.
//		Also modified to work with PIC18F2550 with 4MHz crystal
//		Serial debugging removed
//   CC indicates changes from original Circuit Cellar source
//
// Author:	                Copyright 2005 by Robert Lang		
// Building on the work of: Reston Condit
//                          Dan Butler
//                          Andrew Smallridge
//
// Revision:		1.1 
// Date:		January 2005
// Compiled using:	BOOSTC 1.93
//
// Revision History:
//   1.0 Initial development and conversion to BOOSTC and PIC18F2455 based on 
//       program "Mouse in a circle" example
//   1.1 Added serial port for debugging messages
//
// Comments:
// bXXX indicate specific bits in registers defined in usb_defs.h
// usb buffers are defined in usbdefs.h

//################################################################################
//
// include files:
#include <system.h>
#include "PICUsbJiggler.h" 

// Configuration registers
// FOSC3:FOSC0 = HSPLL PLLDIV2:PLLDIV0 = 0, CPUDIV1:CPUDIV0 = 10 (/4)
#pragma DATA    _CONFIG1L, 00110000b // USBDIV on, CPU divide by 4, PLL direct
#pragma DATA    _CONFIG1H, 00001110b // disable oscillator switchover, disable failsafe clock monitor, HSPLL
#pragma DATA    _CONFIG2L, 00111110b // USB voltage regulator enabled, brownout set for 2.1 volts, hardware brownout only, PWRT enabled
#pragma DATA    _CONFIG2H, 00011110b // Watchdog timer disabled
#pragma DATA    _CONFIG3H, 00000000b // MCLR disabled, RB4:RB0 digital on POR
#pragma DATA    _CONFIG4L, 10000000b // Debug off, extended instructions disabled, LVP disabled, disable stack full/underflow reset
#pragma DATA    _CONFIG5L, 00001111b // Read code protection off
#pragma DATA    _CONFIG5H, 11000000b // Read EEPROM and boot block protection off
#pragma DATA    _CONFIG6L, 00001111b // Write code protection off
#pragma DATA    _CONFIG6H, 11100000b // Write EEPROM, boot block and config register protection off
#pragma DATA    _CONFIG7L, 00001111b // Table read protection off
#pragma DATA    _CONFIG7H, 01000000b // Boot block table read protection off

// 4 MHz crystal but the system clock is 24MHz due to CPUDIV configuration
#pragma CLOCK_FREQ 24000000

unsigned char USB_IsIdle;
unsigned char USB_status_device;
unsigned char USB_Curr_Config; 
unsigned char USB_address_pending;
unsigned char USB_dev_req;
unsigned char USB_Interface [3];
unsigned char USB_USTAT;
unsigned char ACTIVE_BUF;
unsigned char USB_protocol;
unsigned char USWSTAT;
unsigned int USB_PID_ERR   = 0; //error counters
0E72  0100      	MOVLB 0x00
0E74  6BCB      	CLRF gbl_USB_PID_ERR, 1
0E76  6BCC      	CLRF gbl_USB_PID_ERR+D'1', 1

unsigned int USB_CRC5_ERR  = 0;
0E78  6BCD      	CLRF gbl_USB_CRC5_ERR, 1
0E7A  6BCE      	CLRF gbl_USB_CRC5_ERR+D'1', 1

unsigned int USB_CRC16_ERR = 0;
0E7C  6BCF      	CLRF gbl_USB_CRC16_ERR, 1
0E7E  6BD0      	CLRF gbl_USB_CRC16_ERR+D'1', 1

unsigned int USB_DFN8_ERR  = 0;
0E80  6BD1      	CLRF gbl_USB_DFN8_ERR, 1
0E82  6BD2      	CLRF gbl_USB_DFN8_ERR+D'1', 1

unsigned int USB_BTO_ERR   = 0;
0E84  6BD3      	CLRF gbl_USB_BTO_ERR, 1
0E86  6BD4      	CLRF gbl_USB_BTO_ERR+D'1', 1

unsigned int USB_WRT_ERR   = 0;
0E88  6BD5      	CLRF gbl_USB_WRT_ERR, 1
0E8A  6BD6      	CLRF gbl_USB_WRT_ERR+D'1', 1

unsigned int USB_OWN_ERR   = 0;
0E8C  6BD7      	CLRF gbl_USB_OWN_ERR, 1
0E8E  6BD8      	CLRF gbl_USB_OWN_ERR+D'1', 1

unsigned int USB_BTS_ERR   = 0;
0E90  6BD9      	CLRF gbl_USB_BTS_ERR, 1
0E92  6BDA      	CLRF gbl_USB_BTS_ERR+D'1', 1


unsigned char * EP0_start;  //ep0 pointers modified from CC
unsigned char * EP0_end;    // modified from CC
unsigned char EP0_maxLength;

struct BufferDescriptorEntry { // buffer descriptor
	unsigned char EPStat;
	unsigned char bytes;
	unsigned int address;
};

struct BufferStruct { // buffer structure
	unsigned char bmRequestType;
	unsigned char bRequest;
	unsigned int   wValue;
	unsigned int   wIndex;
	unsigned int   wLength;
};

struct BufferDescriptorEntry * BDT= (struct BufferDescriptorEntry *)0x400; 
0E94  6BDF      	CLRF gbl_BDT, 1
0E96  0E04      	MOVLW 0x04
0E98  6FE0      	MOVWF gbl_BDT+D'1', 1

struct BufferStruct *  Buffer;  //define Buffer as pointer to a BufferStruct
struct BufferStruct  BufferCopy;
struct BufferDescriptorEntry BDTCopy; 

//string descriptors in unicode format
const char String0 []  = {4, STRING, 9, 4};
0E9A  0E04      	MOVLW 0x04
0E9C  6FC7      	MOVWF gbl_String0, 1
0E9E  0E03      	MOVLW 0x03
0EA0  6FC8      	MOVWF gbl_String0+D'1', 1
0EA2  0E09      	MOVLW 0x09
0EA4  6FC9      	MOVWF gbl_String0+D'2', 1
0EA6  0E04      	MOVLW 0x04
0EA8  6FCA      	MOVWF gbl_String0+D'3', 1

const char String1 [] = {20, STRING,
0EAA  0E14      	MOVLW 0x14
0EAC  6F90      	MOVWF gbl_String1, 1
0EAE  0E03      	MOVLW 0x03
0EB0  6F91      	MOVWF gbl_String1+D'1', 1

'M',0,
0EB2  0E4D      	MOVLW 0x4D
0EB4  6F92      	MOVWF gbl_String1+D'2', 1
0EB6  6B93      	CLRF gbl_String1+D'3', 1

'i',0,
0EB8  0E69      	MOVLW 0x69
0EBA  6F94      	MOVWF gbl_String1+D'4', 1
0EBC  6B95      	CLRF gbl_String1+D'5', 1

'c',0,
0EBE  0E63      	MOVLW 0x63
0EC0  6F96      	MOVWF gbl_String1+D'6', 1
0EC2  6B97      	CLRF gbl_String1+D'7', 1

'r',0,
0EC4  0E72      	MOVLW 0x72
0EC6  6F98      	MOVWF gbl_String1+D'8', 1
0EC8  6B99      	CLRF gbl_String1+D'9', 1

'o',0,
0ECA  0E6F      	MOVLW 0x6F
0ECC  6F9A      	MOVWF gbl_String1+D'10', 1
0ECE  6B9B      	CLRF gbl_String1+D'11', 1

'c',0,
0ED0  0E63      	MOVLW 0x63
0ED2  6F9C      	MOVWF gbl_String1+D'12', 1
0ED4  6B9D      	CLRF gbl_String1+D'13', 1

'h',0,
0ED6  0E68      	MOVLW 0x68
0ED8  6F9E      	MOVWF gbl_String1+D'14', 1
0EDA  6B9F      	CLRF gbl_String1+D'15', 1

'i',0,
0EDC  0E69      	MOVLW 0x69
0EDE  6FA0      	MOVWF gbl_String1+D'16', 1
0EE0  6BA1      	CLRF gbl_String1+D'17', 1

'p',0};
0EE2  0E70      	MOVLW 0x70
0EE4  6FA2      	MOVWF gbl_String1+D'18', 1
0EE6  6BA3      	CLRF gbl_String1+D'19', 1

const char String2[] = {48,STRING,
0EE8  0E30      	MOVLW 0x30
0EEA  6F60      	MOVWF gbl_String2, 1
0EEC  0E03      	MOVLW 0x03
0EEE  6F61      	MOVWF gbl_String2+D'1', 1

'P',0,
0EF0  0E50      	MOVLW 0x50
0EF2  6F62      	MOVWF gbl_String2+D'2', 1
0EF4  6B63      	CLRF gbl_String2+D'3', 1

'i',0,
0EF6  0E69      	MOVLW 0x69
0EF8  6F64      	MOVWF gbl_String2+D'4', 1
0EFA  6B65      	CLRF gbl_String2+D'5', 1

'c',0,
0EFC  0E63      	MOVLW 0x63
0EFE  6F66      	MOVWF gbl_String2+D'6', 1
0F00  6B67      	CLRF gbl_String2+D'7', 1

'1',0,
0F02  0E31      	MOVLW 0x31
0F04  6F68      	MOVWF gbl_String2+D'8', 1
0F06  6B69      	CLRF gbl_String2+D'9', 1

'8',0,
0F08  0E38      	MOVLW 0x38
0F0A  6F6A      	MOVWF gbl_String2+D'10', 1
0F0C  6B6B      	CLRF gbl_String2+D'11', 1

'F',0,
0F0E  0E46      	MOVLW 0x46
0F10  6F6C      	MOVWF gbl_String2+D'12', 1
0F12  6B6D      	CLRF gbl_String2+D'13', 1

'2',0,
0F14  0E32      	MOVLW 0x32
0F16  6F6E      	MOVWF gbl_String2+D'14', 1
0F18  6B6F      	CLRF gbl_String2+D'15', 1

'5',0,
0F1A  0E35      	MOVLW 0x35
0F1C  6F70      	MOVWF gbl_String2+D'16', 1
0F1E  6B71      	CLRF gbl_String2+D'17', 1

'5',0,
0F20  0E35      	MOVLW 0x35
0F22  6F72      	MOVWF gbl_String2+D'18', 1
0F24  6B73      	CLRF gbl_String2+D'19', 1

'0',0,
0F26  0E30      	MOVLW 0x30
0F28  6F74      	MOVWF gbl_String2+D'20', 1
0F2A  6B75      	CLRF gbl_String2+D'21', 1

' ',0,
0F2C  0E20      	MOVLW 0x20
0F2E  6F76      	MOVWF gbl_String2+D'22', 1
0F30  6B77      	CLRF gbl_String2+D'23', 1

'J',0,
0F32  0E4A      	MOVLW 0x4A
0F34  6F78      	MOVWF gbl_String2+D'24', 1
0F36  6B79      	CLRF gbl_String2+D'25', 1

'i',0,
0F38  0E69      	MOVLW 0x69
0F3A  6F7A      	MOVWF gbl_String2+D'26', 1
0F3C  6B7B      	CLRF gbl_String2+D'27', 1

'g',0,
0F3E  0E67      	MOVLW 0x67
0F40  6F7C      	MOVWF gbl_String2+D'28', 1
0F42  6B7D      	CLRF gbl_String2+D'29', 1

'g',0,
0F44  0E67      	MOVLW 0x67
0F46  6F7E      	MOVWF gbl_String2+D'30', 1
0F48  6B7F      	CLRF gbl_String2+D'31', 1

'l',0,
0F4A  0E6C      	MOVLW 0x6C
0F4C  6F80      	MOVWF gbl_String2+D'32', 1
0F4E  6B81      	CLRF gbl_String2+D'33', 1

'e',0,
0F50  0E65      	MOVLW 0x65
0F52  6F82      	MOVWF gbl_String2+D'34', 1
0F54  6B83      	CLRF gbl_String2+D'35', 1

' ',0, 
0F56  0E20      	MOVLW 0x20
0F58  6F84      	MOVWF gbl_String2+D'36', 1
0F5A  6B85      	CLRF gbl_String2+D'37', 1

'M',0,
0F5C  0E4D      	MOVLW 0x4D
0F5E  6F86      	MOVWF gbl_String2+D'38', 1
0F60  6B87      	CLRF gbl_String2+D'39', 1

'o',0,
0F62  0E6F      	MOVLW 0x6F
0F64  6F88      	MOVWF gbl_String2+D'40', 1
0F66  6B89      	CLRF gbl_String2+D'41', 1

'u',0,
0F68  0E75      	MOVLW 0x75
0F6A  6F8A      	MOVWF gbl_String2+D'42', 1
0F6C  6B8B      	CLRF gbl_String2+D'43', 1

's',0,
0F6E  0E73      	MOVLW 0x73
0F70  6F8C      	MOVWF gbl_String2+D'44', 1
0F72  6B8D      	CLRF gbl_String2+D'45', 1

'e',0};
0F74  0E65      	MOVLW 0x65
0F76  6F8E      	MOVWF gbl_String2+D'46', 1
0F78  6B8F      	CLRF gbl_String2+D'47', 1


// Report descriptor prepared by USB DESCRIPTOR TOOL
// http://www.usb.org/developers/hidpage/#Descriptor_Tool
const char ReportDescriptor1[] = {
   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
0F7A  0E05      	MOVLW 0x05
0F7C  6E05      	MOVWF gbl_ReportDescriptor1
0F7E  0E01      	MOVLW 0x01
0F80  6E06      	MOVWF gbl_ReportDescriptor1+D'1'

   0x09, 0x02,                    //  USAGE (Mouse)
0F82  0E09      	MOVLW 0x09
0F84  6E07      	MOVWF gbl_ReportDescriptor1+D'2'
0F86  0E02      	MOVLW 0x02
0F88  6E08      	MOVWF gbl_ReportDescriptor1+D'3'

   0xa1, 0x01,                    //  COLLECTION (Application)
0F8A  0EA1      	MOVLW 0xA1
0F8C  6E09      	MOVWF gbl_ReportDescriptor1+D'4'
0F8E  0E01      	MOVLW 0x01
0F90  6E0A      	MOVWF gbl_ReportDescriptor1+D'5'

   0x09, 0x01,                    //  USAGE (Pointer)
0F92  0E09      	MOVLW 0x09
0F94  6E0B      	MOVWF gbl_ReportDescriptor1+D'6'
0F96  0E01      	MOVLW 0x01
0F98  6E0C      	MOVWF gbl_ReportDescriptor1+D'7'

   0xa1, 0x00,                    //  COLLECTION (Physical)
0F9A  0EA1      	MOVLW 0xA1
0F9C  6E0D      	MOVWF gbl_ReportDescriptor1+D'8'
0F9E  6A0E      	CLRF gbl_ReportDescriptor1+D'9'

   0x05, 0x09,                    //  USAGE_PAGE (Button)
0FA0  0E05      	MOVLW 0x05
0FA2  6E0F      	MOVWF gbl_ReportDescriptor1+D'10'
0FA4  0E09      	MOVLW 0x09
0FA6  6E10      	MOVWF gbl_ReportDescriptor1+D'11'

   0x19, 0x01,                    //  USAGE_MINIMUM (Button 1)
0FA8  0E19      	MOVLW 0x19
0FAA  6E11      	MOVWF gbl_ReportDescriptor1+D'12'
0FAC  0E01      	MOVLW 0x01
0FAE  6E12      	MOVWF gbl_ReportDescriptor1+D'13'

   0x29, 0x03,                    //  USAGE_MAXIMUM (Button 3)
0FB0  0E29      	MOVLW 0x29
0FB2  6E13      	MOVWF gbl_ReportDescriptor1+D'14'
0FB4  0E03      	MOVLW 0x03
0FB6  6E14      	MOVWF gbl_ReportDescriptor1+D'15'

   0x15, 0x00,                    //  LOGICAL_MINIMUM (0)
0FB8  0E15      	MOVLW 0x15
0FBA  6E15      	MOVWF gbl_ReportDescriptor1+D'16'
0FBC  6A16      	CLRF gbl_ReportDescriptor1+D'17'

   0x25, 0x01,                    //  LOGICAL_MAXIMUM (1)
0FBE  0E25      	MOVLW 0x25
0FC0  6E17      	MOVWF gbl_ReportDescriptor1+D'18'
0FC2  0E01      	MOVLW 0x01
0FC4  6E18      	MOVWF gbl_ReportDescriptor1+D'19'

   0x95, 0x03,                    //  REPORT_COUNT (3)
0FC6  0E95      	MOVLW 0x95
0FC8  6E19      	MOVWF gbl_ReportDescriptor1+D'20'
0FCA  0E03      	MOVLW 0x03
0FCC  6E1A      	MOVWF gbl_ReportDescriptor1+D'21'

   0x75, 0x01,                    //  REPORT_SIZE (1)
0FCE  0E75      	MOVLW 0x75
0FD0  6E1B      	MOVWF gbl_ReportDescriptor1+D'22'
0FD2  0E01      	MOVLW 0x01
0FD4  6E1C      	MOVWF gbl_ReportDescriptor1+D'23'

   0x81, 0x02,                    //  INPUT (Data,Var,Abs)
0FD6  0E81      	MOVLW 0x81
0FD8  6E1D      	MOVWF gbl_ReportDescriptor1+D'24'
0FDA  0E02      	MOVLW 0x02
0FDC  6E1E      	MOVWF gbl_ReportDescriptor1+D'25'

   0x95, 0x01,                    //  REPORT_COUNT (1)
0FDE  0E95      	MOVLW 0x95
0FE0  6E1F      	MOVWF gbl_ReportDescriptor1+D'26'
0FE2  0E01      	MOVLW 0x01
0FE4  6E20      	MOVWF gbl_ReportDescriptor1+D'27'

   0x75, 0x05,                    //  REPORT_SIZE (5)
0FE6  0E75      	MOVLW 0x75
0FE8  6E21      	MOVWF gbl_ReportDescriptor1+D'28'
0FEA  0E05      	MOVLW 0x05
0FEC  6E22      	MOVWF gbl_ReportDescriptor1+D'29'

   0x81, 0x01,                    //  INPUT (Cnst,Ary,Abs)
0FEE  0E81      	MOVLW 0x81
0FF0  6E23      	MOVWF gbl_ReportDescriptor1+D'30'
0FF2  0E01      	MOVLW 0x01
0FF4  6E24      	MOVWF gbl_ReportDescriptor1+D'31'

   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
0FF6  0E05      	MOVLW 0x05
0FF8  6E25      	MOVWF gbl_ReportDescriptor1+D'32'
0FFA  0E01      	MOVLW 0x01
0FFC  6E26      	MOVWF gbl_ReportDescriptor1+D'33'

   0x09, 0x30,                    //  USAGE (X)
0FFE  0E09      	MOVLW 0x09
1000  6E27      	MOVWF gbl_ReportDescriptor1+D'34'
1002  0E30      	MOVLW 0x30
1004  6E28      	MOVWF gbl_ReportDescriptor1+D'35'

   0x09, 0x31,                    //  USAGE (Y)
1006  0E09      	MOVLW 0x09
1008  6E29      	MOVWF gbl_ReportDescriptor1+D'36'
100A  0E31      	MOVLW 0x31
100C  6E2A      	MOVWF gbl_ReportDescriptor1+D'37'

   0x15, 0x81,                    //  LOGICAL_MINIMUM (-127)
100E  0E15      	MOVLW 0x15
1010  6E2B      	MOVWF gbl_ReportDescriptor1+D'38'
1012  0E81      	MOVLW 0x81
1014  6E2C      	MOVWF gbl_ReportDescriptor1+D'39'

   0x25, 0x7f,                    //  LOGICAL_MAXIMUM (127)
1016  0E25      	MOVLW 0x25
1018  6E2D      	MOVWF gbl_ReportDescriptor1+D'40'
101A  0E7F      	MOVLW 0x7F
101C  6E2E      	MOVWF gbl_ReportDescriptor1+D'41'

   0x75, 0x08,                    //  REPORT_SIZE (8)
101E  0E75      	MOVLW 0x75
1020  6E2F      	MOVWF gbl_ReportDescriptor1+D'42'
1022  0E08      	MOVLW 0x08
1024  6E30      	MOVWF gbl_ReportDescriptor1+D'43'

   0x95, 0x02,                    //  REPORT_COUNT (2)
1026  0E95      	MOVLW 0x95
1028  6E31      	MOVWF gbl_ReportDescriptor1+D'44'
102A  0E02      	MOVLW 0x02
102C  6E32      	MOVWF gbl_ReportDescriptor1+D'45'

   0x81, 0x06,                    //  INPUT (Data,Var,Rel)
102E  0E81      	MOVLW 0x81
1030  6E33      	MOVWF gbl_ReportDescriptor1+D'46'
1032  0E06      	MOVLW 0x06
1034  6E34      	MOVWF gbl_ReportDescriptor1+D'47'

   0xc0,                          //  END_COLLECTION
1036  0EC0      	MOVLW 0xC0
1038  6E35      	MOVWF gbl_ReportDescriptor1+D'48'

   0xc0                           //  END_COLLECTION
103A  0EC0      	MOVLW 0xC0
103C  6E36      	MOVWF gbl_ReportDescriptor1+D'49'

};

const char DeviceDescriptor [] = {
    0x12, // 18 bytes long 
103E  0E12      	MOVLW 0x12
1040  6FA4      	MOVWF gbl_DeviceDescriptor, 1

    DEVICE, // descriptor type
1042  0E01      	MOVLW 0x01
1044  6FA5      	MOVWF gbl_DeviceDescriptor+D'1', 1

    0x10, 0x01, // USB specification release (1.10)
1046  0E10      	MOVLW 0x10
1048  6FA6      	MOVWF gbl_DeviceDescriptor+D'2', 1
104A  0E01      	MOVLW 0x01
104C  6FA7      	MOVWF gbl_DeviceDescriptor+D'3', 1

    0x00, // class code
104E  6BA8      	CLRF gbl_DeviceDescriptor+D'4', 1

    0x00, // subclass code
1050  6BA9      	CLRF gbl_DeviceDescriptor+D'5', 1

    0x00, // protocol code
1052  6BAA      	CLRF gbl_DeviceDescriptor+D'6', 1

    0x08, // maximum packet size
1054  0E08      	MOVLW 0x08
1056  6FAB      	MOVWF gbl_DeviceDescriptor+D'7', 1

    0xD8,0x04, // vendor id (04d8) microchip
1058  0ED8      	MOVLW 0xD8
105A  6FAC      	MOVWF gbl_DeviceDescriptor+D'8', 1
105C  0E04      	MOVLW 0x04
105E  6FAD      	MOVWF gbl_DeviceDescriptor+D'9', 1

    0x09,0x00, //product id (0009)
1060  0E09      	MOVLW 0x09
1062  6FAE      	MOVWF gbl_DeviceDescriptor+D'10', 1
1064  6BAF      	CLRF gbl_DeviceDescriptor+D'11', 1

    0x00,0x02, // device release number 2.00
1066  6BB0      	CLRF gbl_DeviceDescriptor+D'12', 1
1068  0E02      	MOVLW 0x02
106A  6FB1      	MOVWF gbl_DeviceDescriptor+D'13', 1

    0x01, // index to string that describes vendor
106C  0E01      	MOVLW 0x01
106E  6FB2      	MOVWF gbl_DeviceDescriptor+D'14', 1

    0x02, // index to string that describes product
1070  0E02      	MOVLW 0x02
1072  6FB3      	MOVWF gbl_DeviceDescriptor+D'15', 1

    0x00, // index to string that describes serial number (none)
1074  6BB4      	CLRF gbl_DeviceDescriptor+D'16', 1

    0x01  // number of possible configurations
1076  0E01      	MOVLW 0x01
1078  6FB5      	MOVWF gbl_DeviceDescriptor+D'17', 1

};

//CONFIG DESCRIPTOR ORDER CORRESPONDS TO HID 1.0 OR LATER
const char ConfigDescriptor [] = {
    0x09, // 9 bytes long
107A  0E09      	MOVLW 0x09
107C  6E37      	MOVWF gbl_ConfigDescriptor

    CONFIGURATION, // descriptor type
107E  0E02      	MOVLW 0x02
1080  6E38      	MOVWF gbl_ConfigDescriptor+D'1'

    0x22, 0x00, // total length of config, interface, HID and endpoint descriptors
1082  0E22      	MOVLW 0x22
1084  6E39      	MOVWF gbl_ConfigDescriptor+D'2'
1086  6A3A      	CLRF gbl_ConfigDescriptor+D'3'

    0x01, // number of interfaces
1088  0E01      	MOVLW 0x01
108A  6E3B      	MOVWF gbl_ConfigDescriptor+D'4'

    0x01, // configuration number
108C  0E01      	MOVLW 0x01
108E  6E3C      	MOVWF gbl_ConfigDescriptor+D'5'

    0x00, // index to string that describes configuration (none)
1090  6A3D      	CLRF gbl_ConfigDescriptor+D'6'

    0xA0, // configuration attributes , remote wakeup
1092  0EA0      	MOVLW 0xA0
1094  6E3E      	MOVWF gbl_ConfigDescriptor+D'7'

    0x32, // current consumption in 2mA units (100 mA) 
1096  0E32      	MOVLW 0x32
1098  6E3F      	MOVWF gbl_ConfigDescriptor+D'8'

    /* Interface Descriptor  */      0x09,// 9 bytes long
109A  0E09      	MOVLW 0x09
109C  6E40      	MOVWF gbl_ConfigDescriptor+D'9'

    INTERFACE, // descriptor type
109E  0E04      	MOVLW 0x04
10A0  6E41      	MOVWF gbl_ConfigDescriptor+D'10'

    0x00, // number of this interface (zerp based)
10A2  6A42      	CLRF gbl_ConfigDescriptor+D'11'

    0x00, // alternate setting (none)
10A4  6A43      	CLRF gbl_ConfigDescriptor+D'12'

    0x01, // number of endpoints used by interface
10A6  0E01      	MOVLW 0x01
10A8  6E44      	MOVWF gbl_ConfigDescriptor+D'13'

    0x03, // class code
10AA  0E03      	MOVLW 0x03
10AC  6E45      	MOVWF gbl_ConfigDescriptor+D'14'

    0x01, // subclass code
10AE  0E01      	MOVLW 0x01
10B0  6E46      	MOVWF gbl_ConfigDescriptor+D'15'

    0x02, // protocol 
10B2  0E02      	MOVLW 0x02
10B4  6E47      	MOVWF gbl_ConfigDescriptor+D'16'

    0x00, // index to string that describes endpoint (none)
10B6  6A48      	CLRF gbl_ConfigDescriptor+D'17'

    /* HID descriptor described above */     
    0x09, 0x21, 0x10, 0x01, 0x00, 0x01, 0x22, sizeof(ReportDescriptor1), sizeof(ReportDescriptor1)>>8,
10B8  0E09      	MOVLW 0x09
10BA  6E49      	MOVWF gbl_ConfigDescriptor+D'18'
10BC  0E21      	MOVLW 0x21
10BE  6E4A      	MOVWF gbl_ConfigDescriptor+D'19'
10C0  0E10      	MOVLW 0x10
10C2  6E4B      	MOVWF gbl_ConfigDescriptor+D'20'
10C4  0E01      	MOVLW 0x01
10C6  6E4C      	MOVWF gbl_ConfigDescriptor+D'21'
10C8  6A4D      	CLRF gbl_ConfigDescriptor+D'22'
10CA  0E01      	MOVLW 0x01
10CC  6E4E      	MOVWF gbl_ConfigDescriptor+D'23'
10CE  0E22      	MOVLW 0x22
10D0  6E4F      	MOVWF gbl_ConfigDescriptor+D'24'
10D2  0E32      	MOVLW 0x32
10D4  6E50      	MOVWF gbl_ConfigDescriptor+D'25'
10D6  6A51      	CLRF gbl_ConfigDescriptor+D'26'

    /* Endpoint 1 descriptor */       0x07, // 7 bytes long
10D8  0E07      	MOVLW 0x07
10DA  6E52      	MOVWF gbl_ConfigDescriptor+D'27'

    ENDPOINT, // descriptor type
10DC  0E05      	MOVLW 0x05
10DE  6E53      	MOVWF gbl_ConfigDescriptor+D'28'

    0x81, // endpoint characteristics (IN endpoint)
10E0  0E81      	MOVLW 0x81
10E2  6E54      	MOVWF gbl_ConfigDescriptor+D'29'

    0x03, // endpoint attributes  (interrupt)
10E4  0E03      	MOVLW 0x03
10E6  6E55      	MOVWF gbl_ConfigDescriptor+D'30'

    0x03, 0x00, // max packet size (HID 3 byte report)
10E8  0E03      	MOVLW 0x03
10EA  6E56      	MOVWF gbl_ConfigDescriptor+D'31'
10EC  6A57      	CLRF gbl_ConfigDescriptor+D'32'

    0x0A //polling interval in 1 msec increments (10)
10EE  0E0A      	MOVLW 0x0A
10F0  6E58      	MOVWF gbl_ConfigDescriptor+D'33'

};

const unsigned int ReportDescrSize = sizeof(ReportDescriptor1);
10F2  0E32      	MOVLW 0x32
10F4  6FE3      	MOVWF gbl_ReportDescrSize, 1
10F6  6BE4      	CLRF gbl_ReportDescrSize+D'1', 1

const char  HIDDescriptor [] =    {
    0x09, // 9 bytes long
10F8  0E09      	MOVLW 0x09
10FA  6FB6      	MOVWF gbl_HIDDescriptor, 1

    0x21, // descriptor type, HID=21
10FC  0E21      	MOVLW 0x21
10FE  6FB7      	MOVWF gbl_HIDDescriptor+D'1', 1

    0x10, 0x01,  // HUD class version 1.10
1100  0E10      	MOVLW 0x10
1102  6FB8      	MOVWF gbl_HIDDescriptor+D'2', 1
1104  0E01      	MOVLW 0x01
1106  6FB9      	MOVWF gbl_HIDDescriptor+D'3', 1

    0x00, // country code (none)
1108  6BBA      	CLRF gbl_HIDDescriptor+D'4', 1

    0x01, // Number of HID class descriptors
110A  0E01      	MOVLW 0x01
110C  6FBB      	MOVWF gbl_HIDDescriptor+D'5', 1

    0x22, // Type of class descriptor (report)
110E  0E22      	MOVLW 0x22
1110  6FBC      	MOVWF gbl_HIDDescriptor+D'6', 1

    sizeof(ReportDescriptor1), sizeof(ReportDescriptor1)>>8  // Size of report descriptor
1112  0E32      	MOVLW 0x32
1114  6FBD      	MOVWF gbl_HIDDescriptor+D'7', 1
1116  6BBE      	CLRF gbl_HIDDescriptor+D'8', 1

};

/***********************************************************************************
 PutEP1 
 Tests the EP1 IN OWNS bit.  If there is a buffer available to us, your buffer is 
 copied and turned over to the SIE for transmission on the next IN transfer and 
 returns TRUE (1).  If the buffer is not available, FALSE is returned (0).                                                  
***********************************************************************************/
unsigned char PutEP1(unsigned char bytes, signed char *buffer) {

	signed char * tobuffer;
	unsigned char i;

	ddrb = 0; //setup b for output
0C72  6A93      	CLRF gbl_ddrb


	if ((bd1statie & 0x80) == 0) { /* do we own the buffer? UOWN=0*/
0C74  0E80      	MOVLW 0x80
0C76  0104      	MOVLB 0x04
0C78  150C      	ANDWF gbl_bd1statie, W, 1
0C7A  0100      	MOVLB 0x00
0C7C  6FFE      	MOVWF CompTempVar571, 1
0C7E  53FE      	MOVF CompTempVar571, F, 1
0C80  E13A      	BNZ	label116
0CF6            label116

		bd1cntie = bytes;
0C82  51F8      	MOVF PutEP1_00000_arg_bytes, W, 1
0C84  0104      	MOVLB 0x04
0C86  6F0D      	MOVWF gbl_bd1cntie, 1

        tobuffer = (signed char *) ((unsigned int)bd1adrlie + (unsigned int)(bd1adrhie <<8));
0C88  510E      	MOVF gbl_bd1adrlie, W, 1
0C8A  0100      	MOVLB 0x00
0C8C  6FFB      	MOVWF PutEP1_00000_1_tobuffer, 1
0C8E  0101      	MOVLB 0x01
0C90  6B19      	CLRF CompTempVar574+D'1', 1
0C92  0100      	MOVLB 0x00
0C94  6BFF      	CLRF CompTempVar575, 1
0C96  0104      	MOVLB 0x04
0C98  510F      	MOVF gbl_bd1adrhie, W, 1
0C9A  0100      	MOVLB 0x00
0C9C  6FFC      	MOVWF PutEP1_00000_1_tobuffer+D'1', 1
0C9E  51FF      	MOVF CompTempVar575, W, 1
0CA0  27FB      	ADDWF PutEP1_00000_1_tobuffer, F, 1
0CA2  0101      	MOVLB 0x01
0CA4  5119      	MOVF CompTempVar574+D'1', W, 1
0CA6  0100      	MOVLB 0x00
0CA8  23FC      	ADDWFC PutEP1_00000_1_tobuffer+D'1', F, 1


		for (i = 0; i < bytes; i++) {
0CAA  6BFD      	CLRF PutEP1_00000_1_i, 1
0CAC            label114
0CAC  51F8      	MOVF PutEP1_00000_arg_bytes, W, 1
0CAE  61FD      	CPFSLT PutEP1_00000_1_i, 1
0CB0  D017      	BRA	label115
0CDA  0100      	MOVLB 0x00
0CDC  2BFD      	INCF PutEP1_00000_1_i, F, 1
0CDE  D7E6      	BRA	label114
0CE0            label115

	        tobuffer[i] = buffer[i];
0CB2  51FA      	MOVF PutEP1_00000_arg_buffer+D'1', W, 1
0CB4  6EEA      	MOVWF FSR0H
0CB6  51F9      	MOVF PutEP1_00000_arg_buffer, W, 1
0CB8  6EE9      	MOVWF FSR0L
0CBA  51FD      	MOVF PutEP1_00000_1_i, W, 1
0CBC  6FFF      	MOVWF CompTempVar579, 1
0CBE  51FF      	MOVF CompTempVar579, W, 1
0CC0  26E9      	ADDWF FSR0L, F
0CC2  50EF      	MOVF INDF0, W
0CC4  0101      	MOVLB 0x01
0CC6  6F18      	MOVWF CompTempVar580, 1
0CC8  0100      	MOVLB 0x00
0CCA  51FC      	MOVF PutEP1_00000_1_tobuffer+D'1', W, 1
0CCC  6EEA      	MOVWF FSR0H
0CCE  51FB      	MOVF PutEP1_00000_1_tobuffer, W, 1
0CD0  25FD      	ADDWF PutEP1_00000_1_i, W, 1
0CD2  6EE9      	MOVWF FSR0L
0CD4  0101      	MOVLB 0x01
0CD6  5118      	MOVF CompTempVar580, W, 1
0CD8  6EEF      	MOVWF INDF0

		}

	    bd1statie &= 0x40; /* save only the Data 1/0 bit */
0CE0  0E40      	MOVLW 0x40
0CE2  0104      	MOVLB 0x04
0CE4  170C      	ANDWF gbl_bd1statie, F, 1

	    bd1statie ^= 0x40; /* toggle Data 0/1 bit */
0CE6  0E40      	MOVLW 0x40
0CE8  1B0C      	XORWF gbl_bd1statie, F, 1

	    bd1statie ^= 0x88; /* release buffer */ 
0CEA  0E88      	MOVLW 0x88
0CEC  1B0C      	XORWF gbl_bd1statie, F, 1

		return TRUE;
0CEE  0E01      	MOVLW 0x01
0CF0  0100      	MOVLB 0x00
0CF2  6FFF      	MOVWF CompTempVarRet570, 1

	}
	return FALSE;	/* Buffer not available, return false */
0CF6  6BFF      	CLRF CompTempVarRet570, 1

}
0CF4  0012      	RETURN
0CF8  0012      	RETURN


/***********************************************************************************
 Enable Wakeup on interupt and Activity interrupt then put the device to sleep to 
 save power.  Activity on the D+/D- lines will set the ACTIVITY interrupt, waking up
 the part.                       
***********************************************************************************/
void USBSleep() {

	uie.ACTVIE = 1; // enable activity interrupt
014A  8469      	BSF gbl_uie,2

	uie.IDLEIE = 0; //disable idle interrupt
014C  9869      	BCF gbl_uie,4

	ucon.SUSPND	= 1; // put in suspend mode
014E  826D      	BSF gbl_ucon,1

	USB_IsIdle = 1; // mark device as idle
0150  0E01      	MOVLW 0x01
0152  0100      	MOVLB 0x00
0154  6FE7      	MOVWF gbl_USB_IsIdle, 1

}
0156  0012      	RETURN


/***********************************************************************************
 Service the Activity Interrupt.  This is only enabled when the device is put to 
 sleep as a result of inactivity on the bus.  This code wakes up the part, disables 
 the activity interrupt and reenables the idle interrupt.                                                   
***********************************************************************************/
void USBActivity() {

	uir.ACTVIF = 0;
00A6  9468      	BCF gbl_uir,2

	uie.ACTVIE = 0;
00A8  9469      	BCF gbl_uie,2

	ucon.SUSPND = 0; //normal operation
00AA  926D      	BCF gbl_ucon,1

	USB_IsIdle = 0;
00AC  0100      	MOVLB 0x00
00AE  6BE7      	CLRF gbl_USB_IsIdle, 1

}
00B0  0012      	RETURN


/***********************************************************************************
 USB Reset interrupt triggered (SE0)                                
 initialize the Buffer Descriptor Table,                            
 Transition to the DEFAULT state,                                   
 Set address to 0                                                   
 Enable the USB                                                     
***********************************************************************************/
void USBReset() {

	USB_Curr_Config = 0;
0074  0100      	MOVLB 0x00
0076  6BE9      	CLRF gbl_USB_Curr_Config, 1

	USB_IsIdle = 0;
0078  6BE7      	CLRF gbl_USB_IsIdle, 1

	uir.TRNIF = 0; // clear TOK_DNE bit in uir 4 times to 
007A  9668      	BCF gbl_uir,3

	uir.TRNIF = 0; // clear out the USTAT FIFO.  See Microchip 	
007C  9668      	BCF gbl_uir,3

	uir.TRNIF = 0; // 18F2455 data sheet.
007E  9668      	BCF gbl_uir,3

	uir.TRNIF = 0;
0080  9668      	BCF gbl_uir,3

	bd0cntoe = 8; //set up for 8 byte buffer
0082  0E08      	MOVLW 0x08
0084  0104      	MOVLB 0x04
0086  6F01      	MOVWF gbl_bd0cntoe, 1

	bd0statoe = 0x88;	// EP0 Out buffer (USB OWNS)
0088  0E88      	MOVLW 0x88
008A  6F00      	MOVWF gbl_bd0statoe, 1

	bd0statie = 0x08;    // EP0 In buffer (MCU OWNS)
008C  0E08      	MOVLW 0x08
008E  6F04      	MOVWF gbl_bd0statie, 1

	uaddr = 0; // clear address
0090  6A6E      	CLRF gbl_uaddr

	uir = 0; // clear USB interrupt flag
0092  6A68      	CLRF gbl_uir

	uie	= 00000101b; // enable reset and activity interrupt
0094  0E05      	MOVLW 0x05
0096  6E69      	MOVWF gbl_uie

	uep0 = ENDPT_CONTROL;
0098  0E16      	MOVLW 0x16
009A  6E70      	MOVWF gbl_uep0

	USWSTAT = DEFAULT_STATE;
009C  0E01      	MOVLW 0x01
009E  0100      	MOVLB 0x00
00A0  6FEF      	MOVWF gbl_USWSTAT, 1

	USB_status_device = 1;
00A2  6FE8      	MOVWF gbl_USB_status_device, 1

}
00A4  0012      	RETURN


/***********************************************************************************
 CopyDescriptorToEP0 
 copies the next chunk of buffer descriptor over to the EP0 In buffer.  
 Inputs:                                                                
    EP0_start - points to first byte of configuration table to transfer 
    EP0_end - total number of bytes to transfer                         
    EP0_maxLength - maximum number of bytes that can be sent during     
    a single transfer                                                   
                                                                        
 toggles the data0/1 bit before setting the UOWN bit over to SIE.       
***********************************************************************************/
void CopyDescriptorToEP0() {

	unsigned char *  USBbuffer;  /* pointer to the USB Buffers */
	unsigned char bufindex;
	USBbuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));
00B2  0104      	MOVLB 0x04
00B4  5106      	MOVF gbl_bd0adrlie, W, 1
00B6  0101      	MOVLB 0x01
00B8  6F24      	MOVWF CopyDescri_0000B_1_USBbuffer, 1
00BA  6B28      	CLRF CompTempVar583+D'1', 1
00BC  6B29      	CLRF CompTempVar584, 1
00BE  0104      	MOVLB 0x04
00C0  5107      	MOVF gbl_bd0adrhie, W, 1
00C2  0101      	MOVLB 0x01
00C4  6F25      	MOVWF CopyDescri_0000B_1_USBbuffer+D'1', 1
00C6  5129      	MOVF CompTempVar584, W, 1
00C8  2724      	ADDWF CopyDescri_0000B_1_USBbuffer, F, 1
00CA  5128      	MOVF CompTempVar583+D'1', W, 1
00CC  2325      	ADDWFC CopyDescri_0000B_1_USBbuffer+D'1', F, 1

	bufindex  = 0;
00CE  6B26      	CLRF CopyDescri_0000B_1_bufindex, 1

    while ((bufindex < EP0_maxLength) && ((unsigned short)EP0_start <(unsigned short) EP0_end)) {
00D0            label3
00D0  0100      	MOVLB 0x00
00D2  51F0      	MOVF gbl_EP0_maxLength, W, 1
00D4  0101      	MOVLB 0x01
00D6  6126      	CPFSLT CopyDescri_0000B_1_bufindex, 1
00D8  D01B      	BRA	label5
00DA  0100      	MOVLB 0x00
00DC  51DE      	MOVF gbl_EP0_end+D'1', W, 1
00DE  5DDC      	SUBWF gbl_EP0_start+D'1', W, 1
00E0  E102      	BNZ	label4
00E2  51DD      	MOVF gbl_EP0_end, W, 1
00E4  5DDB      	SUBWF gbl_EP0_start, W, 1
00E6            label4
00E6  E214      	BC	label5
010E  D7E0      	BRA	label3
0110            label5

		USBbuffer [bufindex] = *EP0_start;
00E8  51DC      	MOVF gbl_EP0_start+D'1', W, 1
00EA  6EEA      	MOVWF FSR0H
00EC  51DB      	MOVF gbl_EP0_start, W, 1
00EE  6EE9      	MOVWF FSR0L
00F0  50EF      	MOVF INDF0, W
00F2  0101      	MOVLB 0x01
00F4  6F27      	MOVWF CompTempVar587, 1
00F6  5125      	MOVF CopyDescri_0000B_1_USBbuffer+D'1', W, 1
00F8  6EEA      	MOVWF FSR0H
00FA  5124      	MOVF CopyDescri_0000B_1_USBbuffer, W, 1
00FC  2526      	ADDWF CopyDescri_0000B_1_bufindex, W, 1
00FE  6EE9      	MOVWF FSR0L
0100  5127      	MOVF CompTempVar587, W, 1
0102  6EEF      	MOVWF INDF0

		++ EP0_start;
0104  0100      	MOVLB 0x00
0106  4BDB      	INFSNZ gbl_EP0_start, F, 1
0108  2BDC      	INCF gbl_EP0_start+D'1', F, 1

		++ bufindex;
010A  0101      	MOVLB 0x01
010C  2B26      	INCF CopyDescri_0000B_1_bufindex, F, 1

	}
	if (bufindex < EP0_maxLength)	/* are we sending a short packet? */
0110  0100      	MOVLB 0x00
0112  51F0      	MOVF gbl_EP0_maxLength, W, 1
0114  0101      	MOVLB 0x01
0116  6126      	CPFSLT CopyDescri_0000B_1_bufindex, 1
0118  D002      	BRA	label6
011E            label6

		USB_dev_req = 0;	/* Yes, clear the device reqest */
011A  0100      	MOVLB 0x00
011C  6BEB      	CLRF gbl_USB_dev_req, 1


	bd0cntie  = bufindex;
011E  0101      	MOVLB 0x01
0120  5126      	MOVF CopyDescri_0000B_1_bufindex, W, 1
0122  0104      	MOVLB 0x04
0124  6F05      	MOVWF gbl_bd0cntie, 1

	bd0statie &= 0x40;		/* save only the DTS bit */
0126  0E40      	MOVLW 0x40
0128  1704      	ANDWF gbl_bd0statie, F, 1

	bd0statie ^= 0x40;		/* toggle data DTS bit */
012A  0E40      	MOVLW 0x40
012C  1B04      	XORWF gbl_bd0statie, F, 1

	bd0statie |= 0x88;		/* set OWN and DTSEN bits */
012E  0E88      	MOVLW 0x88
0130  1304      	IORWF gbl_bd0statie, F, 1

}
0132  0012      	RETURN


/***********************************************************************************
 Init USB
 Initializes the USB peripheral, sets up the interrupts
***********************************************************************************/
void InitUSB() {

	//ucfg.UTRDIS = 0; // enable internal transceiver
	ucfg.FSEN = 1; // Full speed enable
0CFA  846F      	BSF gbl_ucfg,2

	ucfg.UPUEN = 1; // Enable on-chip pull-ups
0CFC  886F      	BSF gbl_ucfg,4

	//ucfg.PPB1 = 0; // Disable ping-pong buffering
	//ucfg.PPB0 = 0; // Disable ping-pong buffering
	//uie.STALLIE = 1; // interrupt on stall
	//uie.TRNIE = 1; //   on transaction complete
	uie.URSTIE = 1; //   on reset 
0CFE  8069      	BSF gbl_uie,0

	pie2.USBIE = 1; // general USB interrupts
0D00  8AA0      	BSF gbl_pie2,5

	
	ucon.PPBRST = 1; // reset pingpong buffers
0D02  8C6D      	BSF gbl_ucon,6

	ucon.PPBRST = 0; // unlock pingpong buffers
0D04  9C6D      	BCF gbl_ucon,6

	ucon.USBEN = 1;	// enable usb
0D06  866D      	BSF gbl_ucon,3

	
	USB_Curr_Config = 0;
0D08  0100      	MOVLB 0x00
0D0A  6BE9      	CLRF gbl_USB_Curr_Config, 1

	USB_status_device = 1;
0D0C  0E01      	MOVLW 0x01
0D0E  6FE8      	MOVWF gbl_USB_status_device, 1

	char USB_Interface[] = {0,0,0};
0D10  6BF8      	CLRF InitUSB_00000_1_USB_Interface, 1
0D12  6BF9      	CLRF InitUSB_00000_1_USB_Interface+D'1', 1
0D14  6BFA      	CLRF InitUSB_00000_1_USB_Interface+D'2', 1

	USB_dev_req = NULL;
0D16  6BEB      	CLRF gbl_USB_dev_req, 1

	// clear all error counters
	USB_PID_ERR = 0;
0D18  6BCB      	CLRF gbl_USB_PID_ERR, 1
0D1A  6BCC      	CLRF gbl_USB_PID_ERR+D'1', 1

	USB_CRC5_ERR = 0;
0D1C  6BCD      	CLRF gbl_USB_CRC5_ERR, 1
0D1E  6BCE      	CLRF gbl_USB_CRC5_ERR+D'1', 1

	USB_CRC16_ERR = 0;
0D20  6BCF      	CLRF gbl_USB_CRC16_ERR, 1
0D22  6BD0      	CLRF gbl_USB_CRC16_ERR+D'1', 1

	USB_DFN8_ERR = 0;
0D24  6BD1      	CLRF gbl_USB_DFN8_ERR, 1
0D26  6BD2      	CLRF gbl_USB_DFN8_ERR+D'1', 1

	USB_BTO_ERR = 0;
0D28  6BD3      	CLRF gbl_USB_BTO_ERR, 1
0D2A  6BD4      	CLRF gbl_USB_BTO_ERR+D'1', 1

	USB_BTS_ERR = 0;
0D2C  6BD9      	CLRF gbl_USB_BTS_ERR, 1
0D2E  6BDA      	CLRF gbl_USB_BTS_ERR+D'1', 1

	intcon.GIE = 1; // Enable GIE & PEIE
0D30  8EF2      	BSF gbl_intcon,7

	intcon.PEIE = 1;
0D32  8CF2      	BSF gbl_intcon,6

}
0D34  0012      	RETURN


/***********************************************************************************
 This is activated by the STALL bit in the UIR register. It really just tells us 
 that the SIE sent a STALL handshake.  So far, Don't see that any action is 
 required.  Clear the bit and move on.
***********************************************************************************/
void USBStall() {

	uir.STALLIF = 0;
0146  9A68      	BCF gbl_uir,5

}
0148  0012      	RETURN


/***********************************************************************************
 The SIE detected an error.  This code increments the appropriate error counter 
 and clears the flag.
***********************************************************************************/
void Count_Error() {

	if (ueir.PIDEF && ueie.PIDEE) {
0BCC  A06A      	BTFSS gbl_ueir,0
0BCE  D005      	BRA	label106
0BD0  A06B      	BTFSS gbl_ueie,0
0BD2  D003      	BRA	label106

		++USB_PID_ERR;
0BD4  0100      	MOVLB 0x00
0BD6  4BCB      	INFSNZ gbl_USB_PID_ERR, F, 1
0BD8  2BCC      	INCF gbl_USB_PID_ERR+D'1', F, 1
0BDA            label106

	}
	if (ueir.CRC5EF && ueie.CRC5EE) {
0BDA  A26A      	BTFSS gbl_ueir,1
0BDC  D005      	BRA	label107
0BDE  A26B      	BTFSS gbl_ueie,1
0BE0  D003      	BRA	label107

		++USB_CRC5_ERR;
0BE2  0100      	MOVLB 0x00
0BE4  4BCD      	INFSNZ gbl_USB_CRC5_ERR, F, 1
0BE6  2BCE      	INCF gbl_USB_CRC5_ERR+D'1', F, 1
0BE8            label107

	}
	if (ueir.CRC16EF && ueie.CRC16EE) {
0BE8  A46A      	BTFSS gbl_ueir,2
0BEA  D005      	BRA	label108
0BEC  A46B      	BTFSS gbl_ueie,2
0BEE  D003      	BRA	label108

		++USB_CRC16_ERR;
0BF0  0100      	MOVLB 0x00
0BF2  4BCF      	INFSNZ gbl_USB_CRC16_ERR, F, 1
0BF4  2BD0      	INCF gbl_USB_CRC16_ERR+D'1', F, 1
0BF6            label108

	}
	if (ueir.DFN8EF && ueie.DFN8EE) {
0BF6  A66A      	BTFSS gbl_ueir,3
0BF8  D005      	BRA	label109
0BFA  A66B      	BTFSS gbl_ueie,3
0BFC  D003      	BRA	label109

		++USB_DFN8_ERR;
0BFE  0100      	MOVLB 0x00
0C00  4BD1      	INFSNZ gbl_USB_DFN8_ERR, F, 1
0C02  2BD2      	INCF gbl_USB_DFN8_ERR+D'1', F, 1
0C04            label109

	}
	if (ueir.BTOEF && ueie.BTOEE) {
0C04  A86A      	BTFSS gbl_ueir,4
0C06  D005      	BRA	label110
0C08  A86B      	BTFSS gbl_ueie,4
0C0A  D003      	BRA	label110

		++USB_BTO_ERR;
0C0C  0100      	MOVLB 0x00
0C0E  4BD3      	INFSNZ gbl_USB_BTO_ERR, F, 1
0C10  2BD4      	INCF gbl_USB_BTO_ERR+D'1', F, 1
0C12            label110

	}
	if (ueir.BTSEF && ueie.BTSEE) {
0C12  AE6A      	BTFSS gbl_ueir,7
0C14  D005      	BRA	label111
0C16  AE6B      	BTFSS gbl_ueie,7
0C18  D003      	BRA	label111

		++USB_BTS_ERR;
0C1A  0100      	MOVLB 0x00
0C1C  4BD9      	INFSNZ gbl_USB_BTS_ERR, F, 1
0C1E  2BDA      	INCF gbl_USB_BTS_ERR+D'1', F, 1
0C20            label111

	}
	ueir = 0; // Clear all USB error flag bits
0C20  6A6A      	CLRF gbl_ueir

	uir.UERRIF = 0; // Clear master USB error flag bit
0C22  9268      	BCF gbl_uir,1

}
0C24  0012      	RETURN


/***********************************************************************************
 Process token done interrupt...  Most of the work gets done through this interrupt.  
 Token Done is signaled in response to an In, Out, or Setup transaction.
***********************************************************************************/
void Process_Req() {

	unsigned char *OutBuffer;
	unsigned char *UEPArray;
	unsigned char DescriptorType;
	unsigned char Endpoint;
	unsigned char Interface;
	unsigned char DescriptorID;
	unsigned char StringID;
	USB_USTAT = ustat;
0158  506C      	MOVF gbl_ustat, W
015A  0100      	MOVLB 0x00
015C  6FEC      	MOVWF gbl_USB_USTAT, 1

	ACTIVE_BUF = (USB_USTAT >> 3) * 2; //EP*2 (IF OUTPUT)
015E  31EC      	RRCF gbl_USB_USTAT, W, 1
0160  6FED      	MOVWF gbl_ACTIVE_BUF, 1
0162  33ED      	RRCF gbl_ACTIVE_BUF, F, 1
0164  33ED      	RRCF gbl_ACTIVE_BUF, F, 1
0166  0E1F      	MOVLW 0x1F
0168  17ED      	ANDWF gbl_ACTIVE_BUF, F, 1
016A  90D8      	BCF STATUS,C
016C  37ED      	RLCF gbl_ACTIVE_BUF, F, 1

	ACTIVE_BUF = (ACTIVE_BUF + (USB_USTAT & 0x4) >> 2);  //=EP*2 + 1 (IF INPUT) 
016E  0E04      	MOVLW 0x04
0170  15EC      	ANDWF gbl_USB_USTAT, W, 1
0172  0101      	MOVLB 0x01
0174  6F1C      	MOVWF CompTempVar594, 1
0176  6B1D      	CLRF CompTempVar597, 1
0178  511C      	MOVF CompTempVar594, W, 1
017A  0100      	MOVLB 0x00
017C  27ED      	ADDWF gbl_ACTIVE_BUF, F, 1
017E  E302      	BNC	label8
0180  0101      	MOVLB 0x01
0182  2B1D      	INCF CompTempVar597, F, 1
0184  0101      	MOVLB 0x01
0186  331D      	RRCF CompTempVar597, F, 1
0188  0100      	MOVLB 0x00
018A  33ED      	RRCF gbl_ACTIVE_BUF, F, 1
018C  0101      	MOVLB 0x01
018E  331D      	RRCF CompTempVar597, F, 1
0190  0100      	MOVLB 0x00
0192  33ED      	RRCF gbl_ACTIVE_BUF, F, 1

	// save data in buffer descriptor table
	BDTCopy.EPStat = BDT[ACTIVE_BUF].EPStat;
0194  51E0      	MOVF gbl_BDT+D'1', W, 1
0196  6EEA      	MOVWF FSR0H
0198  51DF      	MOVF gbl_BDT, W, 1
019A  6EE9      	MOVWF FSR0L
019C  51ED      	MOVF gbl_ACTIVE_BUF, W, 1
019E  0101      	MOVLB 0x01
01A0  6F1C      	MOVWF CompTempVar598, 1
01A2  371C      	RLCF CompTempVar598, F, 1
01A4  371C      	RLCF CompTempVar598, F, 1
01A6  0EFC      	MOVLW 0xFC
01A8  151C      	ANDWF CompTempVar598, W, 1
01AA  26E9      	ADDWF FSR0L, F
01AC  50EF      	MOVF INDF0, W
01AE  6E59      	MOVWF gbl_BDTCopy

	BDTCopy.bytes = BDT[ACTIVE_BUF].bytes;
01B0  0100      	MOVLB 0x00
01B2  51DF      	MOVF gbl_BDT, W, 1
01B4  6EE9      	MOVWF FSR0L
01B6  51ED      	MOVF gbl_ACTIVE_BUF, W, 1
01B8  0101      	MOVLB 0x01
01BA  6F1C      	MOVWF CompTempVar599, 1
01BC  371C      	RLCF CompTempVar599, F, 1
01BE  371C      	RLCF CompTempVar599, F, 1
01C0  0EFC      	MOVLW 0xFC
01C2  151C      	ANDWF CompTempVar599, W, 1
01C4  26E9      	ADDWF FSR0L, F
01C6  50EC      	MOVF PREINC0, W
01C8  6E5A      	MOVWF gbl_BDTCopy+D'1'

	BDTCopy.address = BDT[ACTIVE_BUF].address;
01CA  0100      	MOVLB 0x00
01CC  51DF      	MOVF gbl_BDT, W, 1
01CE  6EE9      	MOVWF FSR0L
01D0  51ED      	MOVF gbl_ACTIVE_BUF, W, 1
01D2  0101      	MOVLB 0x01
01D4  6F1C      	MOVWF CompTempVar600, 1
01D6  371C      	RLCF CompTempVar600, F, 1
01D8  371C      	RLCF CompTempVar600, F, 1
01DA  0EFC      	MOVLW 0xFC
01DC  151C      	ANDWF CompTempVar600, W, 1
01DE  26E9      	ADDWF FSR0L, F
01E0  0E02      	MOVLW 0x02
01E2  26E9      	ADDWF FSR0L, F
01E4  50EE      	MOVF POSTINC0, W
01E6  6E5B      	MOVWF gbl_BDTCopy+D'2'
01E8  50EF      	MOVF INDF0, W
01EA  6E5C      	MOVWF gbl_BDTCopy+D'3'

	uir.TRNIF = 0;
01EC  9668      	BCF gbl_uir,3

	if ((BDTCopy.EPStat & 0x3C) == TOKEN_IN) {
01EE  0E3C      	MOVLW 0x3C
01F0  1459      	ANDWF gbl_BDTCopy, W
01F2  6F19      	MOVWF CompTempVar588, 1
01F4  0E24      	MOVLW 0x24
01F6  6319      	CPFSEQ CompTempVar588, 1
01F8  D00E      	BRA	label10
0216            label10

        // TOKEN IN
		if (USB_USTAT == 0x04) { 
01FA  0E04      	MOVLW 0x04
01FC  0100      	MOVLB 0x00
01FE  63EC      	CPFSEQ gbl_USB_USTAT, 1
0200  D006      	BRA	label9
020E            label9

            /* Process EP0 In's */
			if (USB_dev_req == GET_DESCRIPTOR) {
0202  0E06      	MOVLW 0x06
0204  63EB      	CPFSEQ gbl_USB_dev_req, 1

				CopyDescriptorToEP0 ();
0208  EC59F000  	CALL CopyDescri_0000B

			}
		} else if (USB_USTAT == 0x0C) {
020E  0E0C      	MOVLW 0x0C
0210  63EC      	CPFSEQ gbl_USB_USTAT, 1

            /* process EP1 In's */
        } else {
		    /* process EP2 In's */
		}
	} else if ((BDTCopy.EPStat & 0x3C) == TOKEN_OUT) {
0216  0E3C      	MOVLW 0x3C
0218  1459      	ANDWF gbl_BDTCopy, W
021A  6F1A      	MOVWF CompTempVar589, 1
021C  0E04      	MOVLW 0x04
021E  631A      	CPFSEQ CompTempVar589, 1
0220  D008      	BRA	label11
0232            label11

        //TOKEN OUT
		if (USB_USTAT == 0x00) {
0222  0100      	MOVLB 0x00
0224  53EC      	MOVF gbl_USB_USTAT, F, 1
0226  B4D8      	BTFSC STATUS,Z

		    /* process EP1 Out's */
		} else if (USB_USTAT == 0x08) {
022A  0E08      	MOVLW 0x08
022C  63EC      	CPFSEQ gbl_USB_USTAT, 1

            /* process EP1 Out's */
		} else {
            /* process EP2 Out's */
		}
	} else if ((BDTCopy.EPStat & 0x3C) == TOKEN_SETUP) {
0232  0E3C      	MOVLW 0x3C
0234  1459      	ANDWF gbl_BDTCopy, W
0236  6F1B      	MOVWF CompTempVar590, 1
0238  0E34      	MOVLW 0x34
023A  631B      	CPFSEQ CompTempVar590, 1

        // TOKEN SETUP
		Buffer = (struct BufferStruct*) ((unsigned int)bd0adrloe + (unsigned int)(bd0adrhoe << 8));
023E  0104      	MOVLB 0x04
0240  5102      	MOVF gbl_bd0adrloe, W, 1
0242  0100      	MOVLB 0x00
0244  6FE1      	MOVWF gbl_Buffer, 1
0246  0101      	MOVLB 0x01
0248  6B1F      	CLRF CompTempVar606+D'1', 1
024A  6B20      	CLRF CompTempVar607, 1
024C  0104      	MOVLB 0x04
024E  5103      	MOVF gbl_bd0adrhoe, W, 1
0250  0100      	MOVLB 0x00
0252  6FE2      	MOVWF gbl_Buffer+D'1', 1
0254  0101      	MOVLB 0x01
0256  5120      	MOVF CompTempVar607, W, 1
0258  0100      	MOVLB 0x00
025A  27E1      	ADDWF gbl_Buffer, F, 1
025C  0101      	MOVLB 0x01
025E  511F      	MOVF CompTempVar606+D'1', W, 1
0260  0100      	MOVLB 0x00
0262  23E2      	ADDWFC gbl_Buffer+D'1', F, 1

		BufferCopy.bmRequestType = Buffer->bmRequestType;
0264  51E2      	MOVF gbl_Buffer+D'1', W, 1
0266  6EEA      	MOVWF FSR0H
0268  51E1      	MOVF gbl_Buffer, W, 1
026A  6EE9      	MOVWF FSR0L
026C  50EF      	MOVF INDF0, W
026E  6FBF      	MOVWF gbl_BufferCopy, 1

		BufferCopy.bRequest = Buffer->bRequest;
0270  50EC      	MOVF PREINC0, W
0272  6FC0      	MOVWF gbl_BufferCopy+D'1', 1

		BufferCopy.wValue = Buffer->wValue;
0274  06E9      	DECF FSR0L, F
0276  0E02      	MOVLW 0x02
0278  26E9      	ADDWF FSR0L, F
027A  50EE      	MOVF POSTINC0, W
027C  6FC1      	MOVWF gbl_BufferCopy+D'2', 1
027E  50EF      	MOVF INDF0, W
0280  6FC2      	MOVWF gbl_BufferCopy+D'3', 1

		BufferCopy.wIndex = Buffer->wIndex;
0282  51E1      	MOVF gbl_Buffer, W, 1
0284  6EE9      	MOVWF FSR0L
0286  0E04      	MOVLW 0x04
0288  26E9      	ADDWF FSR0L, F
028A  50EE      	MOVF POSTINC0, W
028C  6FC3      	MOVWF gbl_BufferCopy+D'4', 1
028E  50EF      	MOVF INDF0, W
0290  6FC4      	MOVWF gbl_BufferCopy+D'5', 1

		BufferCopy.wLength = Buffer->wLength;
0292  51E1      	MOVF gbl_Buffer, W, 1
0294  6EE9      	MOVWF FSR0L
0296  0E06      	MOVLW 0x06
0298  26E9      	ADDWF FSR0L, F
029A  50EE      	MOVF POSTINC0, W
029C  6FC5      	MOVWF gbl_BufferCopy+D'6', 1
029E  50EF      	MOVF INDF0, W
02A0  6FC6      	MOVWF gbl_BufferCopy+D'7', 1

        ueir.PIDEF = 0;  // Clear REQUEST ERROR  
02A2  906A      	BCF gbl_ueir,0

		bd0cntoe = 0x08;
02A4  0E08      	MOVLW 0x08
02A6  0104      	MOVLB 0x04
02A8  6F01      	MOVWF gbl_bd0cntoe, 1

		if (BufferCopy.bmRequestType == 0x21)
02AA  0E21      	MOVLW 0x21
02AC  0100      	MOVLB 0x00
02AE  63BF      	CPFSEQ gbl_BufferCopy, 1
02B0  D004      	BRA	label12
02BA            label12

			bd0statoe = 0xC8;
02B2  0EC8      	MOVLW 0xC8
02B4  0104      	MOVLB 0x04
02B6  6F00      	MOVWF gbl_bd0statoe, 1

		else
02B8  D003      	BRA	label13
02C0            label13
02F2  D3AC      	BRA	label82
030E  D035      	BRA	label26
03C6  D015      	BRA	label35
0400  D03F      	BRA	label41
0696  D074      	BRA	label63
0B44  D03F      	BRA	label104
0B5C  D009      	BRA	label94
0B8C  D011      	BRA	label99

	        bd0statoe = 0x88;/* Turn the buffer around, make it available for the SIE */
02BA  0E88      	MOVLW 0x88
02BC  0104      	MOVLB 0x04
02BE  6F00      	MOVWF gbl_bd0statoe, 1

		bd0statie = 0x08;
02C0  0E08      	MOVLW 0x08
02C2  6F04      	MOVWF gbl_bd0statie, 1

		ucon.PKTDIS = 0;
02C4  986D      	BCF gbl_ucon,4

		USB_dev_req = 0;
02C6  0100      	MOVLB 0x00
02C8  6BEB      	CLRF gbl_USB_dev_req, 1

		switch (BufferCopy.bmRequestType) {
            // First bmRequestType ************************************		
		    case HOSTTODEVICE:
02CA  53BF      	MOVF gbl_BufferCopy, F, 1
02CC  E013      	BZ	label17
02F4            label17

                // 00
			    switch (BufferCopy.bRequest) {
		            case CLEAR_FEATURE:
02F4  05C0      	DECF gbl_BufferCopy+D'1', W, 1
02F6  E00C      	BZ	label20
0310            label20

                        //01
		                /* Remote wakeup is only valid device feature */
				        if (BufferCopy.wValue == 1)	{
0310  0E01      	MOVLW 0x01
0312  63C1      	CPFSEQ gbl_BufferCopy+D'2', 1
0314  D00A      	BRA	label21
0316  51C2      	MOVF gbl_BufferCopy+D'3', W, 1
0318  E108      	BNZ	label21
032A            label21

					        USB_status_device &= 0xFD;
031A  93E8      	BCF gbl_USB_status_device,1, 1

				            Send_0Len_pkt;
031C  0104      	MOVLB 0x04
031E  6B05      	CLRF gbl_bd0cntie, 1
0320  0EC8      	MOVLW 0xC8
0322  6F04      	MOVWF gbl_bd0statie, 1
0324  0100      	MOVLB 0x00
0326  6BEB      	CLRF gbl_USB_dev_req, 1

				        } else {
				            STALL_EP0;
032A  8070      	BSF gbl_uep0,0

                        }
				        break;

			        case SET_FEATURE:
02F8  0E03      	MOVLW 0x03
02FA  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
02FC  D001      	BRA	label18
02FE  D017      	BRA	label22
0300            label18
032E            label22

                        //03
			            /* Set Device Feature.  Only valid device */
				        if ((BufferCopy.wValue & 0xff) == 1) {
032E  51C1      	MOVF gbl_BufferCopy+D'2', W, 1
0330  0101      	MOVLB 0x01
0332  6F1C      	MOVWF CompTempVar601, 1
0334  6B1D      	CLRF CompTempVar602, 1
0336  0E01      	MOVLW 0x01
0338  631C      	CPFSEQ CompTempVar601, 1
033A  D00B      	BRA	label23
033C  511D      	MOVF CompTempVar602, W, 1
033E  E109      	BNZ	label23
0352            label23

				            USB_status_device |= 0x02;	/* feature is remote wakeup */
0340  0100      	MOVLB 0x00
0342  83E8      	BSF gbl_USB_status_device,1, 1

					        Send_0Len_pkt;
0344  0104      	MOVLB 0x04
0346  6B05      	CLRF gbl_bd0cntie, 1
0348  0EC8      	MOVLW 0xC8
034A  6F04      	MOVWF gbl_bd0statie, 1
034C  0100      	MOVLB 0x00
034E  6BEB      	CLRF gbl_USB_dev_req, 1

				        } else {
				            STALL_EP0;
0352  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case SET_ADDRESS:
0300  0E05      	MOVLW 0x05
0302  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
0304  D001      	BRA	label19
0306  D027      	BRA	label24
0308            label19
0356            label24

                        //05
			            USB_address_pending = BufferCopy.wValue;
0356  51C1      	MOVF gbl_BufferCopy+D'2', W, 1
0358  6FEA      	MOVWF gbl_USB_address_pending, 1

				        if (USB_address_pending < 0x80) {
035A  0E80      	MOVLW 0x80
035C  61EA      	CPFSLT gbl_USB_address_pending, 1
035E  D00B      	BRA	label25
0376            label25

					        Send_0Len_pkt;
0360  0104      	MOVLB 0x04
0362  6B05      	CLRF gbl_bd0cntie, 1
0364  0EC8      	MOVLW 0xC8
0366  6F04      	MOVWF gbl_bd0statie, 1
0368  0100      	MOVLB 0x00
036A  6BEB      	CLRF gbl_USB_dev_req, 1

					        USB_dev_req = SET_ADDRESS;
036C  0E05      	MOVLW 0x05
036E  6FEB      	MOVWF gbl_USB_dev_req, 1

		                    uie = 00001001b; //enable transaction complete and reset interrupts
0370  0E09      	MOVLW 0x09
0372  6E69      	MOVWF gbl_uie

				        } else {
				            STALL_EP0;
0376  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case SET_CONFIGURATION:
0308  0E09      	MOVLW 0x09
030A  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
030C  D051      	BRA	label30
037A            label26

                        //09
				        if (BufferCopy.wValue <= NUM_CONFIGURATIONS)
037A  0E01      	MOVLW 0x01
037C  65C1      	CPFSGT gbl_BufferCopy+D'2', 1
037E  67C2      	TSTFSZ gbl_BufferCopy+D'3', 1
0380  D002      	BRA	label27
0386            label27

					        USB_Curr_Config = BufferCopy.wValue;
0382  51C1      	MOVF gbl_BufferCopy+D'2', W, 1
0384  6FE9      	MOVWF gbl_USB_Curr_Config, 1


				        if (BufferCopy.wValue == 0) {
0386  53C1      	MOVF gbl_BufferCopy+D'2', F, 1
0388  E105      	BNZ	label28
038A  53C2      	MOVF gbl_BufferCopy+D'3', F, 1
038C  E103      	BNZ	label28
0394            label28

					        USWSTAT = ADDRESS_STATE;
038E  0E02      	MOVLW 0x02
0390  6FEF      	MOVWF gbl_USWSTAT, 1

					    } else {
0392  D002      	BRA	label29
0398            label29

					        USWSTAT = CONFIG_STATE;
0394  0E03      	MOVLW 0x03
0396  6FEF      	MOVWF gbl_USWSTAT, 1

				        }
				        Send_0Len_pkt;
0398  0104      	MOVLB 0x04
039A  6B05      	CLRF gbl_bd0cntie, 1
039C  0EC8      	MOVLW 0xC8
039E  6F04      	MOVWF gbl_bd0statie, 1
03A0  0100      	MOVLB 0x00
03A2  6BEB      	CLRF gbl_USB_dev_req, 1

	                    bd1statie = 0x48; //SET MCU AS OWNER OF THIS BUFFER, ENABLE DATA TOGGLE SYNC
03A4  0E48      	MOVLW 0x48
03A6  0104      	MOVLB 0x04
03A8  6F0C      	MOVWF gbl_bd1statie, 1

				        uep1 = ENDPT_NON_CONTROL;
03AA  0E1E      	MOVLW 0x1E
03AC  6E71      	MOVWF gbl_uep1

  	                    break;
			        default:
03B0            label30

			            STALL_EP0;
03B0  8070      	BSF gbl_uep0,0

				        break;
			    }
			    break;
            // Second bmRequestType ************************************	
            case HOSTTOINTERFACE:   
02CE  05BF      	DECF gbl_BufferCopy, W, 1
02D0  B4D8      	BTFSC STATUS,Z
02D2  D070      	BRA	label31
03B4            label31

                //01
                switch (BufferCopy.bRequest) {
                    case SET_INTERFACE:
03B4  0E0B      	MOVLW 0x0B
03B6  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
03B8  D001      	BRA	label32
03BA  D006      	BRA	label33
03BC            label32
03C8            label33

                        //0B
                        if (USWSTAT == CONFIG_STATE) {
03C8  0E03      	MOVLW 0x03
03CA  63EF      	CPFSEQ gbl_USWSTAT, 1
03CC  D010      	BRA	label34
03EE            label34

                            Interface = BufferCopy.wIndex;
03CE  51C3      	MOVF gbl_BufferCopy+D'4', W, 1
03D0  6FFE      	MOVWF Process_Re_0000D_1_Interface, 1

                            USB_Interface[Interface] = BufferCopy.wValue;
03D2  EE00F05D  	LFSR 0x00,  gbl_USB_Interface
03D6  50E9      	MOVF FSR0L, W
03D8  51FE      	MOVF Process_Re_0000D_1_Interface, W, 1
03DA  26E9      	ADDWF FSR0L, F
03DC  51C1      	MOVF gbl_BufferCopy+D'2', W, 1
03DE  6EEF      	MOVWF INDF0

                            Send_0Len_pkt;
03E0  0104      	MOVLB 0x04
03E2  6B05      	CLRF gbl_bd0cntie, 1
03E4  0EC8      	MOVLW 0xC8
03E6  6F04      	MOVWF gbl_bd0statie, 1
03E8  0100      	MOVLB 0x00
03EA  6BEB      	CLRF gbl_USB_dev_req, 1

                        } else {
                            STALL_EP0;
03EE  8070      	BSF gbl_uep0,0

                        }
                        break;
                    case CLEAR_FEATURE:
03BC  05C0      	DECF gbl_BufferCopy+D'1', W, 1
03BE  E019      	BZ	label35
03F2            label35

                        //01
                    case SET_FEATURE:
03C0  0E03      	MOVLW 0x03
03C2  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
03C4  D016      	BRA	label35

                        //03
                        /* Set Interface feature - Not Valid */
                    default:
                        STALL_EP0;
03F2  8070      	BSF gbl_uep0,0

                        break;
                }
                break;
            // Third bmRequestType ************************************				
		    case HOSTTOENDPOINT:
02D4  0E02      	MOVLW 0x02
02D6  63BF      	CPFSEQ gbl_BufferCopy, 1
02D8  D001      	BRA	label14
02DA  D08D      	BRA	label36
02DC            label14
03F6            label36

			    switch (BufferCopy.bRequest) {
			        case CLEAR_FEATURE:
03F6  05C0      	DECF gbl_BufferCopy+D'1', W, 1
03F8  E004      	BZ	label37
0402            label37

                        //01
				        UEPArray = (unsigned char *) &uep0;
0402  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0404  6FFB      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1
0406  0E70      	MOVLW LOW(gbl_uep0+D'0')
0408  6FFA      	MOVWF Process_Re_0000D_1_UEPArray, 1

				        Endpoint = BufferCopy.wIndex & 0x0F;
040A  0E0F      	MOVLW 0x0F
040C  15C3      	ANDWF gbl_BufferCopy+D'4', W, 1
040E  6FFD      	MOVWF Process_Re_0000D_1_Endpoint, 1

	                    if (BufferCopy.wValue == 0) {
0410  53C1      	MOVF gbl_BufferCopy+D'2', F, 1
0412  E134      	BNZ	label40
0414  53C2      	MOVF gbl_BufferCopy+D'3', F, 1
0416  E132      	BNZ	label40
047C            label40

	                        /* Only valid feature is 0 (Remote Wakeup) */
				            if (((USWSTAT & 0x03) == ADDRESS_STATE) && (Endpoint == 0)) {
0418  0E03      	MOVLW 0x03
041A  15EF      	ANDWF gbl_USWSTAT, W, 1
041C  0101      	MOVLB 0x01
041E  6F1E      	MOVWF CompTempVar611, 1
0420  0E02      	MOVLW 0x02
0422  631E      	CPFSEQ CompTempVar611, 1
0424  D010      	BRA	label38
0426  0100      	MOVLB 0x00
0428  53FD      	MOVF Process_Re_0000D_1_Endpoint, F, 1
042A  E10D      	BNZ	label38
0446            label38

						        UEPArray [Endpoint] &= 0xFE;
042C  51FB      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
042E  6EEA      	MOVWF FSR0H
0430  51FA      	MOVF Process_Re_0000D_1_UEPArray, W, 1
0432  25FD      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
0434  6EE9      	MOVWF FSR0L
0436  90EF      	BCF INDF0,0

						        Send_0Len_pkt;
0438  0104      	MOVLB 0x04
043A  6B05      	CLRF gbl_bd0cntie, 1
043C  0EC8      	MOVLW 0xC8
043E  6F04      	MOVWF gbl_bd0statie, 1
0440  0100      	MOVLB 0x00
0442  6BEB      	CLRF gbl_USB_dev_req, 1

					        } else if (((USWSTAT& 0x03) == CONFIG_STATE) && (Endpoint < 3)) {
0446  0E03      	MOVLW 0x03
0448  0100      	MOVLB 0x00
044A  15EF      	ANDWF gbl_USWSTAT, W, 1
044C  0101      	MOVLB 0x01
044E  6F1E      	MOVWF CompTempVar613, 1
0450  0E03      	MOVLW 0x03
0452  631E      	CPFSEQ CompTempVar613, 1
0454  D011      	BRA	label39
0456  0E03      	MOVLW 0x03
0458  0100      	MOVLB 0x00
045A  61FD      	CPFSLT Process_Re_0000D_1_Endpoint, 1
045C  D00D      	BRA	label39
0478            label39

						        UEPArray [Endpoint] &= 0xFE;
045E  51FB      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0460  6EEA      	MOVWF FSR0H
0462  51FA      	MOVF Process_Re_0000D_1_UEPArray, W, 1
0464  25FD      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
0466  6EE9      	MOVWF FSR0L
0468  90EF      	BCF INDF0,0

						        Send_0Len_pkt;
046A  0104      	MOVLB 0x04
046C  6B05      	CLRF gbl_bd0cntie, 1
046E  0EC8      	MOVLW 0xC8
0470  6F04      	MOVWF gbl_bd0statie, 1
0472  0100      	MOVLB 0x00
0474  6BEB      	CLRF gbl_USB_dev_req, 1

					        } else {
					            STALL_EP0;
0478  8070      	BSF gbl_uep0,0

                            }
				        } else {
					        STALL_EP0;
047C  8070      	BSF gbl_uep0,0

                        }
				        break;

			        case SET_FEATURE:
03FA  0E03      	MOVLW 0x03
03FC  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
03FE  D085      	BRA	label45
0480            label41

                        //03
				        UEPArray = (unsigned char *) &uep0;
0480  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0482  0101      	MOVLB 0x01
0484  6F1E      	MOVWF CompTempVar615, 1
0486  0E70      	MOVLW LOW(gbl_uep0+D'0')
0488  0100      	MOVLB 0x00
048A  6FFA      	MOVWF Process_Re_0000D_1_UEPArray, 1
048C  0101      	MOVLB 0x01
048E  511E      	MOVF CompTempVar615, W, 1
0490  0100      	MOVLB 0x00
0492  6FFB      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1

				        Endpoint = BufferCopy.wIndex & 0x0F;
0494  0E0F      	MOVLW 0x0F
0496  15C3      	ANDWF gbl_BufferCopy+D'4', W, 1
0498  6FFD      	MOVWF Process_Re_0000D_1_Endpoint, 1

	                    if (BufferCopy.wValue == 0) {
049A  53C1      	MOVF gbl_BufferCopy+D'2', F, 1
049C  E134      	BNZ	label44
049E  53C2      	MOVF gbl_BufferCopy+D'3', F, 1
04A0  E132      	BNZ	label44
0506            label44

                            /* Only valid feature is 0 (Remote Wakeup) */
				            if (((USWSTAT& 0x03) == ADDRESS_STATE) && (Endpoint == 0)) {
04A2  0E03      	MOVLW 0x03
04A4  15EF      	ANDWF gbl_USWSTAT, W, 1
04A6  0101      	MOVLB 0x01
04A8  6F1E      	MOVWF CompTempVar616, 1
04AA  0E02      	MOVLW 0x02
04AC  631E      	CPFSEQ CompTempVar616, 1
04AE  D010      	BRA	label42
04B0  0100      	MOVLB 0x00
04B2  53FD      	MOVF Process_Re_0000D_1_Endpoint, F, 1
04B4  E10D      	BNZ	label42
04D0            label42

						        UEPArray [Endpoint] |= 1;
04B6  51FB      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
04B8  6EEA      	MOVWF FSR0H
04BA  51FA      	MOVF Process_Re_0000D_1_UEPArray, W, 1
04BC  25FD      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
04BE  6EE9      	MOVWF FSR0L
04C0  80EF      	BSF INDF0,0

						        Send_0Len_pkt;
04C2  0104      	MOVLB 0x04
04C4  6B05      	CLRF gbl_bd0cntie, 1
04C6  0EC8      	MOVLW 0xC8
04C8  6F04      	MOVWF gbl_bd0statie, 1
04CA  0100      	MOVLB 0x00
04CC  6BEB      	CLRF gbl_USB_dev_req, 1

					        } else if (((USWSTAT& 0x03) == CONFIG_STATE) && (Endpoint < 3)) {
04D0  0E03      	MOVLW 0x03
04D2  0100      	MOVLB 0x00
04D4  15EF      	ANDWF gbl_USWSTAT, W, 1
04D6  0101      	MOVLB 0x01
04D8  6F1E      	MOVWF CompTempVar618, 1
04DA  0E03      	MOVLW 0x03
04DC  631E      	CPFSEQ CompTempVar618, 1
04DE  D011      	BRA	label43
04E0  0E03      	MOVLW 0x03
04E2  0100      	MOVLB 0x00
04E4  61FD      	CPFSLT Process_Re_0000D_1_Endpoint, 1
04E6  D00D      	BRA	label43
0502            label43

						        UEPArray [Endpoint] |= 1;
04E8  51FB      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
04EA  6EEA      	MOVWF FSR0H
04EC  51FA      	MOVF Process_Re_0000D_1_UEPArray, W, 1
04EE  25FD      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
04F0  6EE9      	MOVWF FSR0L
04F2  80EF      	BSF INDF0,0

						        Send_0Len_pkt;
04F4  0104      	MOVLB 0x04
04F6  6B05      	CLRF gbl_bd0cntie, 1
04F8  0EC8      	MOVLW 0xC8
04FA  6F04      	MOVWF gbl_bd0statie, 1
04FC  0100      	MOVLB 0x00
04FE  6BEB      	CLRF gbl_USB_dev_req, 1

					        } else {
					            STALL_EP0;
0502  8070      	BSF gbl_uep0,0

                            }
				        } else {
				  	        STALL_EP0;
0506  8070      	BSF gbl_uep0,0

                        }
				        break;
			        default:
050A            label45

                        STALL_EP0;
050A  8070      	BSF gbl_uep0,0

			    }
			    break;

            // Fourth bmRequestType ************************************	
		    case DEVICETOHOST:  
02DC  0E80      	MOVLW 0x80
02DE  63BF      	CPFSEQ gbl_BufferCopy, 1
02E0  D001      	BRA	label15
02E2  D115      	BRA	label46
02E4            label15
050E            label46

                //80
			    switch (BufferCopy.bRequest) {
			        case GET_CONFIGURATION:
050E  0E08      	MOVLW 0x08
0510  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
0512  D001      	BRA	label47
0514  D008      	BRA	label49
0516            label47
0526            label49

                        OutBuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));
0526  0104      	MOVLB 0x04
0528  5106      	MOVF gbl_bd0adrlie, W, 1
052A  0100      	MOVLB 0x00
052C  6FF8      	MOVWF Process_Re_0000D_1_OutBuffer, 1
052E  0101      	MOVLB 0x01
0530  6B1F      	CLRF CompTempVar622+D'1', 1
0532  6B20      	CLRF CompTempVar623, 1
0534  0104      	MOVLB 0x04
0536  5107      	MOVF gbl_bd0adrhie, W, 1
0538  0100      	MOVLB 0x00
053A  6FF9      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1
053C  0101      	MOVLB 0x01
053E  5120      	MOVF CompTempVar623, W, 1
0540  0100      	MOVLB 0x00
0542  27F8      	ADDWF Process_Re_0000D_1_OutBuffer, F, 1
0544  0101      	MOVLB 0x01
0546  511F      	MOVF CompTempVar622+D'1', W, 1
0548  0100      	MOVLB 0x00
054A  23F9      	ADDWFC Process_Re_0000D_1_OutBuffer+D'1', F, 1

			            OutBuffer [0] = USB_Curr_Config;
054C  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
054E  6EEA      	MOVWF FSR0H
0550  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0552  6EE9      	MOVWF FSR0L
0554  0101      	MOVLB 0x01
0556  6B1E      	CLRF CompTempVar626, 1
0558  511E      	MOVF CompTempVar626, W, 1
055A  26E9      	ADDWF FSR0L, F
055C  0100      	MOVLB 0x00
055E  51E9      	MOVF gbl_USB_Curr_Config, W, 1
0560  6EEF      	MOVWF INDF0

				        bd0cntie = 1;
0562  0E01      	MOVLW 0x01
0564  0104      	MOVLB 0x04
0566  6F05      	MOVWF gbl_bd0cntie, 1

				        bd0statie = 0xc8;
0568  0EC8      	MOVLW 0xC8
056A  6F04      	MOVWF gbl_bd0statie, 1

				        break;
			        case GET_DESCRIPTOR:
0516  0E06      	MOVLW 0x06
0518  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
051A  D001      	BRA	label48
051C  D028      	BRA	label50
051E            label48
056E            label50

				        DescriptorID = (unsigned char) (BufferCopy.wValue >> 8);
056E  51C2      	MOVF gbl_BufferCopy+D'3', W, 1
0570  6FFF      	MOVWF Process_Re_0000D_1_DescriptorID, 1

				        if (DescriptorID == DEVICE) {
0572  05FF      	DECF Process_Re_0000D_1_DescriptorID, W, 1
0574  E13D      	BNZ	label53
05F0            label53

							USB_dev_req = GET_DESCRIPTOR;
0576  0E06      	MOVLW 0x06
0578  6FEB      	MOVWF gbl_USB_dev_req, 1

					        EP0_start = DeviceDescriptor;
057A  0E00      	MOVLW HIGH(gbl_DeviceDescriptor+D'0')
057C  6FDC      	MOVWF gbl_EP0_start+D'1', 1
057E  0EA4      	MOVLW LOW(gbl_DeviceDescriptor+D'0')
0580  6FDB      	MOVWF gbl_EP0_start, 1

				            EP0_end = DeviceDescriptor + sizeof(DeviceDescriptor);
0582  0E00      	MOVLW HIGH(gbl_DeviceDescriptor+D'0')
0584  0101      	MOVLB 0x01
0586  6F20      	MOVWF CompTempVar632, 1
0588  0EA4      	MOVLW LOW(gbl_DeviceDescriptor+D'0')
058A  0100      	MOVLB 0x00
058C  6FDD      	MOVWF gbl_EP0_end, 1
058E  6BDE      	CLRF gbl_EP0_end+D'1', 1
0590  0E12      	MOVLW 0x12
0592  27DD      	ADDWF gbl_EP0_end, F, 1
0594  0101      	MOVLB 0x01
0596  5120      	MOVF CompTempVar632, W, 1
0598  0100      	MOVLB 0x00
059A  23DE      	ADDWFC gbl_EP0_end+D'1', F, 1

                            if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
059C  51DB      	MOVF gbl_EP0_start, W, 1
059E  5DDD      	SUBWF gbl_EP0_end, W, 1
05A0  0101      	MOVLB 0x01
05A2  6F1E      	MOVWF CompTempVar628, 1
05A4  0100      	MOVLB 0x00
05A6  51DC      	MOVF gbl_EP0_start+D'1', W, 1
05A8  59DE      	SUBWFB gbl_EP0_end+D'1', W, 1
05AA  0101      	MOVLB 0x01
05AC  6F1F      	MOVWF CompTempVar629, 1
05AE  511F      	MOVF CompTempVar629, W, 1
05B0  0100      	MOVLB 0x00
05B2  5DC6      	SUBWF gbl_BufferCopy+D'7', W, 1
05B4  E104      	BNZ	label51
05B6  0101      	MOVLB 0x01
05B8  511E      	MOVF CompTempVar628, W, 1
05BA  0100      	MOVLB 0x00
05BC  5DC5      	SUBWF gbl_BufferCopy+D'6', W, 1
05BE            label51
05BE  E213      	BC	label52
05E6            label52

						        EP0_end = EP0_start + BufferCopy.wLength;
05C0  51C5      	MOVF gbl_BufferCopy+D'6', W, 1
05C2  25DB      	ADDWF gbl_EP0_start, W, 1
05C4  0101      	MOVLB 0x01
05C6  6F20      	MOVWF CompTempVar635, 1
05C8  0100      	MOVLB 0x00
05CA  51C6      	MOVF gbl_BufferCopy+D'7', W, 1
05CC  0101      	MOVLB 0x01
05CE  6F21      	MOVWF CompTempVar636, 1
05D0  0100      	MOVLB 0x00
05D2  51DC      	MOVF gbl_EP0_start+D'1', W, 1
05D4  0101      	MOVLB 0x01
05D6  2321      	ADDWFC CompTempVar636, F, 1
05D8  5120      	MOVF CompTempVar635, W, 1
05DA  0100      	MOVLB 0x00
05DC  6FDD      	MOVWF gbl_EP0_end, 1
05DE  0101      	MOVLB 0x01
05E0  5121      	MOVF CompTempVar636, W, 1
05E2  0100      	MOVLB 0x00
05E4  6FDE      	MOVWF gbl_EP0_end+D'1', 1

					        EP0_maxLength = 8;
05E6  0E08      	MOVLW 0x08
05E8  6FF0      	MOVWF gbl_EP0_maxLength, 1

					        CopyDescriptorToEP0();
05EA  EC59F000  	CALL CopyDescri_0000B

				        } else if (DescriptorID == CONFIGURATION) {
05F0  0E02      	MOVLW 0x02
05F2  63FF      	CPFSEQ Process_Re_0000D_1_DescriptorID, 1
05F4  D03D      	BRA	label56
0670            label56

					        USB_dev_req = GET_DESCRIPTOR;
05F6  0E06      	MOVLW 0x06
05F8  6FEB      	MOVWF gbl_USB_dev_req, 1

					        EP0_start = ConfigDescriptor;
05FA  0E00      	MOVLW HIGH(gbl_ConfigDescriptor+D'0')
05FC  6FDC      	MOVWF gbl_EP0_start+D'1', 1
05FE  0E37      	MOVLW LOW(gbl_ConfigDescriptor+D'0')
0600  6FDB      	MOVWF gbl_EP0_start, 1

				            EP0_end = ConfigDescriptor + sizeof(ConfigDescriptor);
0602  0E00      	MOVLW HIGH(gbl_ConfigDescriptor+D'0')
0604  0101      	MOVLB 0x01
0606  6F20      	MOVWF CompTempVar641, 1
0608  0E37      	MOVLW LOW(gbl_ConfigDescriptor+D'0')
060A  0100      	MOVLB 0x00
060C  6FDD      	MOVWF gbl_EP0_end, 1
060E  6BDE      	CLRF gbl_EP0_end+D'1', 1
0610  0E22      	MOVLW 0x22
0612  27DD      	ADDWF gbl_EP0_end, F, 1
0614  0101      	MOVLB 0x01
0616  5120      	MOVF CompTempVar641, W, 1
0618  0100      	MOVLB 0x00
061A  23DE      	ADDWFC gbl_EP0_end+D'1', F, 1

                            if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
061C  51DB      	MOVF gbl_EP0_start, W, 1
061E  5DDD      	SUBWF gbl_EP0_end, W, 1
0620  0101      	MOVLB 0x01
0622  6F1E      	MOVWF CompTempVar637, 1
0624  0100      	MOVLB 0x00
0626  51DC      	MOVF gbl_EP0_start+D'1', W, 1
0628  59DE      	SUBWFB gbl_EP0_end+D'1', W, 1
062A  0101      	MOVLB 0x01
062C  6F1F      	MOVWF CompTempVar638, 1
062E  511F      	MOVF CompTempVar638, W, 1
0630  0100      	MOVLB 0x00
0632  5DC6      	SUBWF gbl_BufferCopy+D'7', W, 1
0634  E104      	BNZ	label54
0636  0101      	MOVLB 0x01
0638  511E      	MOVF CompTempVar637, W, 1
063A  0100      	MOVLB 0x00
063C  5DC5      	SUBWF gbl_BufferCopy+D'6', W, 1
063E            label54
063E  E213      	BC	label55
0666            label55

						        EP0_end = EP0_start + BufferCopy.wLength;
0640  51C5      	MOVF gbl_BufferCopy+D'6', W, 1
0642  25DB      	ADDWF gbl_EP0_start, W, 1
0644  0101      	MOVLB 0x01
0646  6F20      	MOVWF CompTempVar644, 1
0648  0100      	MOVLB 0x00
064A  51C6      	MOVF gbl_BufferCopy+D'7', W, 1
064C  0101      	MOVLB 0x01
064E  6F21      	MOVWF CompTempVar645, 1
0650  0100      	MOVLB 0x00
0652  51DC      	MOVF gbl_EP0_start+D'1', W, 1
0654  0101      	MOVLB 0x01
0656  2321      	ADDWFC CompTempVar645, F, 1
0658  5120      	MOVF CompTempVar644, W, 1
065A  0100      	MOVLB 0x00
065C  6FDD      	MOVWF gbl_EP0_end, 1
065E  0101      	MOVLB 0x01
0660  5121      	MOVF CompTempVar645, W, 1
0662  0100      	MOVLB 0x00
0664  6FDE      	MOVWF gbl_EP0_end+D'1', 1

					        EP0_maxLength = 8;
0666  0E08      	MOVLW 0x08
0668  6FF0      	MOVWF gbl_EP0_maxLength, 1

					        CopyDescriptorToEP0();
066A  EC59F000  	CALL CopyDescri_0000B

				        } else if (DescriptorID == STRING) {
0670  0E03      	MOVLW 0x03
0672  63FF      	CPFSEQ Process_Re_0000D_1_DescriptorID, 1
0674  D0C3      	BRA	label67
07FC            label67

					        StringID = (unsigned char) BufferCopy.wValue;
0676  51C1      	MOVF gbl_BufferCopy+D'2', W, 1
0678  0101      	MOVLB 0x01
067A  6F18      	MOVWF Process_Re_0000D_1_StringID, 1

					        USB_dev_req = GET_DESCRIPTOR;
067C  0E06      	MOVLW 0x06
067E  0100      	MOVLB 0x00
0680  6FEB      	MOVWF gbl_USB_dev_req, 1

					        EP0_maxLength = 8;
0682  0E08      	MOVLW 0x08
0684  6FF0      	MOVWF gbl_EP0_maxLength, 1

					        switch (StringID) {
					            case 0:
0686  0101      	MOVLB 0x01
0688  5318      	MOVF Process_Re_0000D_1_StringID, F, 1
068A  E006      	BZ	label57
0698            label57

						            EP0_start = String0;  // String0 is start of string0
0698  0E00      	MOVLW HIGH(gbl_String0+D'0')
069A  0100      	MOVLB 0x00
069C  6FDC      	MOVWF gbl_EP0_start+D'1', 1
069E  0EC7      	MOVLW LOW(gbl_String0+D'0')
06A0  6FDB      	MOVWF gbl_EP0_start, 1

						            EP0_end = String0 + String0[0]; // String[0] is length of String0
06A2  0E00      	MOVLW HIGH(gbl_String0+D'0')
06A4  0101      	MOVLB 0x01
06A6  6F24      	MOVWF CompTempVar655, 1
06A8  0EC7      	MOVLW LOW(gbl_String0+D'0')
06AA  0100      	MOVLB 0x00
06AC  6FDD      	MOVWF gbl_EP0_end, 1
06AE  6BDE      	CLRF gbl_EP0_end+D'1', 1
06B0  51C7      	MOVF gbl_String0, W, 1
06B2  27DD      	ADDWF gbl_EP0_end, F, 1
06B4  0101      	MOVLB 0x01
06B6  5124      	MOVF CompTempVar655, W, 1
06B8  0100      	MOVLB 0x00
06BA  23DE      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
06BC  51DB      	MOVF gbl_EP0_start, W, 1
06BE  5DDD      	SUBWF gbl_EP0_end, W, 1
06C0  0101      	MOVLB 0x01
06C2  6F1E      	MOVWF CompTempVar646, 1
06C4  0100      	MOVLB 0x00
06C6  51DC      	MOVF gbl_EP0_start+D'1', W, 1
06C8  59DE      	SUBWFB gbl_EP0_end+D'1', W, 1
06CA  0101      	MOVLB 0x01
06CC  6F1F      	MOVWF CompTempVar647, 1
06CE  511F      	MOVF CompTempVar647, W, 1
06D0  0100      	MOVLB 0x00
06D2  5DC6      	SUBWF gbl_BufferCopy+D'7', W, 1
06D4  E104      	BNZ	label58
06D6  0101      	MOVLB 0x01
06D8  511E      	MOVF CompTempVar646, W, 1
06DA  0100      	MOVLB 0x00
06DC  5DC5      	SUBWF gbl_BufferCopy+D'6', W, 1
06DE            label58
06DE  E213      	BC	label59
0706            label59

							            EP0_end = EP0_start + BufferCopy.wLength;
06E0  51C5      	MOVF gbl_BufferCopy+D'6', W, 1
06E2  25DB      	ADDWF gbl_EP0_start, W, 1
06E4  0101      	MOVLB 0x01
06E6  6F24      	MOVWF CompTempVar658, 1
06E8  0100      	MOVLB 0x00
06EA  51C6      	MOVF gbl_BufferCopy+D'7', W, 1
06EC  0101      	MOVLB 0x01
06EE  6F25      	MOVWF CompTempVar659, 1
06F0  0100      	MOVLB 0x00
06F2  51DC      	MOVF gbl_EP0_start+D'1', W, 1
06F4  0101      	MOVLB 0x01
06F6  2325      	ADDWFC CompTempVar659, F, 1
06F8  5124      	MOVF CompTempVar658, W, 1
06FA  0100      	MOVLB 0x00
06FC  6FDD      	MOVWF gbl_EP0_end, 1
06FE  0101      	MOVLB 0x01
0700  5125      	MOVF CompTempVar659, W, 1
0702  0100      	MOVLB 0x00
0704  6FDE      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0(); // this copies the whole string in 8 byte pieces
0706  EC59F000  	CALL CopyDescri_0000B

						            break;
					            case 1:
068C  0518      	DECF Process_Re_0000D_1_StringID, W, 1
068E  E03E      	BZ	label60
070C            label60

						            EP0_start = String1;
070C  0E00      	MOVLW HIGH(gbl_String1+D'0')
070E  0100      	MOVLB 0x00
0710  6FDC      	MOVWF gbl_EP0_start+D'1', 1
0712  0E90      	MOVLW LOW(gbl_String1+D'0')
0714  6FDB      	MOVWF gbl_EP0_start, 1

						            EP0_end = String1 + String1[0];
0716  0E00      	MOVLW HIGH(gbl_String1+D'0')
0718  0101      	MOVLB 0x01
071A  6F24      	MOVWF CompTempVar663, 1
071C  0E90      	MOVLW LOW(gbl_String1+D'0')
071E  0100      	MOVLB 0x00
0720  6FDD      	MOVWF gbl_EP0_end, 1
0722  6BDE      	CLRF gbl_EP0_end+D'1', 1
0724  5190      	MOVF gbl_String1, W, 1
0726  27DD      	ADDWF gbl_EP0_end, F, 1
0728  0101      	MOVLB 0x01
072A  5124      	MOVF CompTempVar663, W, 1
072C  0100      	MOVLB 0x00
072E  23DE      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
0730  51DB      	MOVF gbl_EP0_start, W, 1
0732  5DDD      	SUBWF gbl_EP0_end, W, 1
0734  0101      	MOVLB 0x01
0736  6F20      	MOVWF CompTempVar648, 1
0738  0100      	MOVLB 0x00
073A  51DC      	MOVF gbl_EP0_start+D'1', W, 1
073C  59DE      	SUBWFB gbl_EP0_end+D'1', W, 1
073E  0101      	MOVLB 0x01
0740  6F21      	MOVWF CompTempVar649, 1
0742  5121      	MOVF CompTempVar649, W, 1
0744  0100      	MOVLB 0x00
0746  5DC6      	SUBWF gbl_BufferCopy+D'7', W, 1
0748  E104      	BNZ	label61
074A  0101      	MOVLB 0x01
074C  5120      	MOVF CompTempVar648, W, 1
074E  0100      	MOVLB 0x00
0750  5DC5      	SUBWF gbl_BufferCopy+D'6', W, 1
0752            label61
0752  E213      	BC	label62
077A            label62

							            EP0_end = EP0_start + BufferCopy.wLength;
0754  51C5      	MOVF gbl_BufferCopy+D'6', W, 1
0756  25DB      	ADDWF gbl_EP0_start, W, 1
0758  0101      	MOVLB 0x01
075A  6F24      	MOVWF CompTempVar666, 1
075C  0100      	MOVLB 0x00
075E  51C6      	MOVF gbl_BufferCopy+D'7', W, 1
0760  0101      	MOVLB 0x01
0762  6F25      	MOVWF CompTempVar667, 1
0764  0100      	MOVLB 0x00
0766  51DC      	MOVF gbl_EP0_start+D'1', W, 1
0768  0101      	MOVLB 0x01
076A  2325      	ADDWFC CompTempVar667, F, 1
076C  5124      	MOVF CompTempVar666, W, 1
076E  0100      	MOVLB 0x00
0770  6FDD      	MOVWF gbl_EP0_end, 1
0772  0101      	MOVLB 0x01
0774  5125      	MOVF CompTempVar667, W, 1
0776  0100      	MOVLB 0x00
0778  6FDE      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0 ();
077A  EC59F000  	CALL CopyDescri_0000B

						            break;
					            case 2:
0690  0E02      	MOVLW 0x02
0692  6318      	CPFSEQ Process_Re_0000D_1_StringID, 1
0694  D0AF      	BRA	label66
0780            label63

						            EP0_start = String2;
0780  0E00      	MOVLW HIGH(gbl_String2+D'0')
0782  0100      	MOVLB 0x00
0784  6FDC      	MOVWF gbl_EP0_start+D'1', 1
0786  0E60      	MOVLW LOW(gbl_String2+D'0')
0788  6FDB      	MOVWF gbl_EP0_start, 1

						            EP0_end = String2 + String2[0];
078A  0E00      	MOVLW HIGH(gbl_String2+D'0')
078C  0101      	MOVLB 0x01
078E  6F24      	MOVWF CompTempVar671, 1
0790  0E60      	MOVLW LOW(gbl_String2+D'0')
0792  0100      	MOVLB 0x00
0794  6FDD      	MOVWF gbl_EP0_end, 1
0796  6BDE      	CLRF gbl_EP0_end+D'1', 1
0798  5160      	MOVF gbl_String2, W, 1
079A  27DD      	ADDWF gbl_EP0_end, F, 1
079C  0101      	MOVLB 0x01
079E  5124      	MOVF CompTempVar671, W, 1
07A0  0100      	MOVLB 0x00
07A2  23DE      	ADDWFC gbl_EP0_end+D'1', F, 1

                                    if (BufferCopy.wLength < ((unsigned short)EP0_end - (unsigned short)EP0_start))
07A4  51DB      	MOVF gbl_EP0_start, W, 1
07A6  5DDD      	SUBWF gbl_EP0_end, W, 1
07A8  0101      	MOVLB 0x01
07AA  6F22      	MOVWF CompTempVar650, 1
07AC  0100      	MOVLB 0x00
07AE  51DC      	MOVF gbl_EP0_start+D'1', W, 1
07B0  59DE      	SUBWFB gbl_EP0_end+D'1', W, 1
07B2  0101      	MOVLB 0x01
07B4  6F23      	MOVWF CompTempVar651, 1
07B6  5123      	MOVF CompTempVar651, W, 1
07B8  0100      	MOVLB 0x00
07BA  5DC6      	SUBWF gbl_BufferCopy+D'7', W, 1
07BC  E104      	BNZ	label64
07BE  0101      	MOVLB 0x01
07C0  5122      	MOVF CompTempVar650, W, 1
07C2  0100      	MOVLB 0x00
07C4  5DC5      	SUBWF gbl_BufferCopy+D'6', W, 1
07C6            label64
07C6  E213      	BC	label65
07EE            label65

							            EP0_end = EP0_start + BufferCopy.wLength;
07C8  51C5      	MOVF gbl_BufferCopy+D'6', W, 1
07CA  25DB      	ADDWF gbl_EP0_start, W, 1
07CC  0101      	MOVLB 0x01
07CE  6F24      	MOVWF CompTempVar674, 1
07D0  0100      	MOVLB 0x00
07D2  51C6      	MOVF gbl_BufferCopy+D'7', W, 1
07D4  0101      	MOVLB 0x01
07D6  6F25      	MOVWF CompTempVar675, 1
07D8  0100      	MOVLB 0x00
07DA  51DC      	MOVF gbl_EP0_start+D'1', W, 1
07DC  0101      	MOVLB 0x01
07DE  2325      	ADDWFC CompTempVar675, F, 1
07E0  5124      	MOVF CompTempVar674, W, 1
07E2  0100      	MOVLB 0x00
07E4  6FDD      	MOVWF gbl_EP0_end, 1
07E6  0101      	MOVLB 0x01
07E8  5125      	MOVF CompTempVar675, W, 1
07EA  0100      	MOVLB 0x00
07EC  6FDE      	MOVWF gbl_EP0_end+D'1', 1

						            CopyDescriptorToEP0();
07EE  EC59F000  	CALL CopyDescri_0000B

						            break;
                                // Additional string processing can be added here						
						        default:
07F4            label66

                                    /* REQUEST ERROR */
						            STALL_PID_EP0IN;
07F4  0ECC      	MOVLW 0xCC
07F6  0104      	MOVLB 0x04
07F8  6F04      	MOVWF gbl_bd0statie, 1

					        }
				        } else  {
					        /* REQUEST ERROR */
                            STALL_PID_EP0IN;
07FC  0ECC      	MOVLW 0xCC
07FE  0104      	MOVLB 0x04
0800  6F04      	MOVWF gbl_bd0statie, 1

                        }
				        break;
			        case GET_STATUS:
051E  53C0      	MOVF gbl_BufferCopy+D'1', F, 1
0520  B4D8      	BTFSC STATUS,Z
0522  D170      	BRA	label68
0804            label68

				        OutBuffer = (unsigned char *)BDT[EP0IN].address;
0804  51E0      	MOVF gbl_BDT+D'1', W, 1
0806  6EEA      	MOVWF FSR0H
0808  51DF      	MOVF gbl_BDT, W, 1
080A  6EE9      	MOVWF FSR0L
080C  0E04      	MOVLW 0x04
080E  26E9      	ADDWF FSR0L, F
0810  0E02      	MOVLW 0x02
0812  26E9      	ADDWF FSR0L, F
0814  50EE      	MOVF POSTINC0, W
0816  6FF8      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0818  50EF      	MOVF INDF0, W
081A  6FF9      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				        OutBuffer[0] = USB_status_device;
081C  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
081E  6EEA      	MOVWF FSR0H
0820  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0822  6EE9      	MOVWF FSR0L
0824  0101      	MOVLB 0x01
0826  6B1E      	CLRF CompTempVar678, 1
0828  511E      	MOVF CompTempVar678, W, 1
082A  26E9      	ADDWF FSR0L, F
082C  0100      	MOVLB 0x00
082E  51E8      	MOVF gbl_USB_status_device, W, 1
0830  6EEF      	MOVWF INDF0

				        OutBuffer[1] = 0;
0832  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0834  6EE9      	MOVWF FSR0L
0836  0E01      	MOVLW 0x01
0838  26E9      	ADDWF FSR0L, F
083A  0E00      	MOVLW 0x00
083C  6EEF      	MOVWF INDF0

				        bd0cntie = 2;
083E  0E02      	MOVLW 0x02
0840  0104      	MOVLB 0x04
0842  6F05      	MOVWF gbl_bd0cntie, 1

				        bd0statie = 0xc8;
0844  0EC8      	MOVLW 0xC8
0846  6F04      	MOVWF gbl_bd0statie, 1

				        break;
			        default:
				        break;
			    }
			    break;
            // Fifth bmRequestType ************************************	
		    case INTERFACETOHOST:
02E4  0E81      	MOVLW 0x81
02E6  63BF      	CPFSEQ gbl_BufferCopy, 1
02E8  D001      	BRA	label16
02EA  D2AF      	BRA	label69
02EC            label16
084A            label69

			    switch (BufferCopy.bRequest) {
			        case GET_INTERFACE:
084A  0E0A      	MOVLW 0x0A
084C  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
084E  D001      	BRA	label70
0850  D006      	BRA	label71
0852            label70
085E            label71

				        Interface = BufferCopy.wIndex;
085E  51C3      	MOVF gbl_BufferCopy+D'4', W, 1
0860  6FFE      	MOVWF Process_Re_0000D_1_Interface, 1

				        if ((USWSTAT== CONFIG_STATE) && (Interface < NUM_INTERFACES)) {
0862  0E03      	MOVLW 0x03
0864  63EF      	CPFSEQ gbl_USWSTAT, 1
0866  D02A      	BRA	label72
0868  0E01      	MOVLW 0x01
086A  61FE      	CPFSLT Process_Re_0000D_1_Interface, 1
086C  D027      	BRA	label72
08BC            label72

					        OutBuffer = (unsigned char *) BDT [EP0IN].address;
086E  51E0      	MOVF gbl_BDT+D'1', W, 1
0870  6EEA      	MOVWF FSR0H
0872  51DF      	MOVF gbl_BDT, W, 1
0874  6EE9      	MOVWF FSR0L
0876  0E04      	MOVLW 0x04
0878  26E9      	ADDWF FSR0L, F
087A  0E02      	MOVLW 0x02
087C  26E9      	ADDWF FSR0L, F
087E  50EE      	MOVF POSTINC0, W
0880  6FF8      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0882  50EF      	MOVF INDF0, W
0884  6FF9      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

					        OutBuffer[0] = USB_Interface[Interface];
0886  EE00F05D  	LFSR 0x00,  gbl_USB_Interface
088A  50E9      	MOVF FSR0L, W
088C  51FE      	MOVF Process_Re_0000D_1_Interface, W, 1
088E  0101      	MOVLB 0x01
0890  6F1F      	MOVWF CompTempVar684, 1
0892  511F      	MOVF CompTempVar684, W, 1
0894  26E9      	ADDWF FSR0L, F
0896  50EF      	MOVF INDF0, W
0898  6F20      	MOVWF CompTempVar685, 1
089A  0100      	MOVLB 0x00
089C  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
089E  6EEA      	MOVWF FSR0H
08A0  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
08A2  6EE9      	MOVWF FSR0L
08A4  0101      	MOVLB 0x01
08A6  6B1E      	CLRF CompTempVar682, 1
08A8  511E      	MOVF CompTempVar682, W, 1
08AA  26E9      	ADDWF FSR0L, F
08AC  5120      	MOVF CompTempVar685, W, 1
08AE  6EEF      	MOVWF INDF0

					        bd0cntie = 1;
08B0  0E01      	MOVLW 0x01
08B2  0104      	MOVLB 0x04
08B4  6F05      	MOVWF gbl_bd0cntie, 1

					        bd0statie = 0xc8;
08B6  0EC8      	MOVLW 0xC8
08B8  6F04      	MOVWF gbl_bd0statie, 1

				        } else {
					        STALL_EP0;
08BC  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case GET_STATUS:
0852  53C0      	MOVF gbl_BufferCopy+D'1', F, 1
0854  E035      	BZ	label73
08C0            label73

				        OutBuffer = (unsigned char *) BDT [EP0IN].address;
08C0  51E0      	MOVF gbl_BDT+D'1', W, 1
08C2  6EEA      	MOVWF FSR0H
08C4  51DF      	MOVF gbl_BDT, W, 1
08C6  6EE9      	MOVWF FSR0L
08C8  0E04      	MOVLW 0x04
08CA  26E9      	ADDWF FSR0L, F
08CC  0E02      	MOVLW 0x02
08CE  26E9      	ADDWF FSR0L, F
08D0  50EE      	MOVF POSTINC0, W
08D2  6FF8      	MOVWF Process_Re_0000D_1_OutBuffer, 1
08D4  50EF      	MOVF INDF0, W
08D6  6FF9      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				        OutBuffer[1] = 0;
08D8  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
08DA  6EEA      	MOVWF FSR0H
08DC  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
08DE  6EE9      	MOVWF FSR0L
08E0  0E01      	MOVLW 0x01
08E2  26E9      	ADDWF FSR0L, F
08E4  0E00      	MOVLW 0x00
08E6  6EEF      	MOVWF INDF0

				        bd0cntie = 2;
08E8  0E02      	MOVLW 0x02
08EA  0104      	MOVLB 0x04
08EC  6F05      	MOVWF gbl_bd0cntie, 1

				        Interface = BufferCopy.wIndex;
08EE  0100      	MOVLB 0x00
08F0  51C3      	MOVF gbl_BufferCopy+D'4', W, 1
08F2  6FFE      	MOVWF Process_Re_0000D_1_Interface, 1

				        if ((USWSTAT == ADDRESS_STATE) && (Interface == 0))	{
08F4  0E02      	MOVLW 0x02
08F6  63EF      	CPFSEQ gbl_USWSTAT, 1
08F8  D01B      	BRA	label74
08FA  53FE      	MOVF Process_Re_0000D_1_Interface, F, 1
08FC  E119      	BNZ	label74
0930            label74

					        OutBuffer[0] = USB_Interface[Interface];
08FE  EE00F05D  	LFSR 0x00,  gbl_USB_Interface
0902  50E9      	MOVF FSR0L, W
0904  51FE      	MOVF Process_Re_0000D_1_Interface, W, 1
0906  0101      	MOVLB 0x01
0908  6F1F      	MOVWF CompTempVar691, 1
090A  511F      	MOVF CompTempVar691, W, 1
090C  26E9      	ADDWF FSR0L, F
090E  50EF      	MOVF INDF0, W
0910  6F20      	MOVWF CompTempVar692, 1
0912  0100      	MOVLB 0x00
0914  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0916  6EEA      	MOVWF FSR0H
0918  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
091A  6EE9      	MOVWF FSR0L
091C  0101      	MOVLB 0x01
091E  6B1E      	CLRF CompTempVar689, 1
0920  511E      	MOVF CompTempVar689, W, 1
0922  26E9      	ADDWF FSR0L, F
0924  5120      	MOVF CompTempVar692, W, 1
0926  6EEF      	MOVWF INDF0

					        bd0statie = 0xc8;
0928  0EC8      	MOVLW 0xC8
092A  0104      	MOVLB 0x04
092C  6F04      	MOVWF gbl_bd0statie, 1

                        } else if ((USWSTAT == CONFIG_STATE) && (Interface < NUM_INTERFACES)) {
0930  0E03      	MOVLW 0x03
0932  63EF      	CPFSEQ gbl_USWSTAT, 1
0934  D01C      	BRA	label75
0936  0E01      	MOVLW 0x01
0938  61FE      	CPFSLT Process_Re_0000D_1_Interface, 1
093A  D019      	BRA	label75
096E            label75

					        OutBuffer[0] = USB_Interface[Interface];
093C  EE00F05D  	LFSR 0x00,  gbl_USB_Interface
0940  50E9      	MOVF FSR0L, W
0942  51FE      	MOVF Process_Re_0000D_1_Interface, W, 1
0944  0101      	MOVLB 0x01
0946  6F1F      	MOVWF CompTempVar696, 1
0948  511F      	MOVF CompTempVar696, W, 1
094A  26E9      	ADDWF FSR0L, F
094C  50EF      	MOVF INDF0, W
094E  6F20      	MOVWF CompTempVar697, 1
0950  0100      	MOVLB 0x00
0952  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0954  6EEA      	MOVWF FSR0H
0956  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0958  6EE9      	MOVWF FSR0L
095A  0101      	MOVLB 0x01
095C  6B1E      	CLRF CompTempVar694, 1
095E  511E      	MOVF CompTempVar694, W, 1
0960  26E9      	ADDWF FSR0L, F
0962  5120      	MOVF CompTempVar697, W, 1
0964  6EEF      	MOVWF INDF0

					        bd0statie = 0xc8;
0966  0EC8      	MOVLW 0xC8
0968  0104      	MOVLB 0x04
096A  6F04      	MOVWF gbl_bd0statie, 1

				        } else {
					        STALL_EP0;
096E  8070      	BSF gbl_uep0,0

                        }
				        break;
			        case GET_DESCRIPTOR:
0856  0E06      	MOVLW 0x06
0858  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
085C  D08A      	BRA	label76
0972            label76

				        DescriptorType = BufferCopy.wValue >> 8;
0972  51C2      	MOVF gbl_BufferCopy+D'3', W, 1
0974  6FFC      	MOVWF Process_Re_0000D_1_Descrip_0000E, 1

                        if (DescriptorType == HID_REPORT_DESCRIPTOR) {
0976  0E22      	MOVLW 0x22
0978  63FC      	CPFSEQ Process_Re_0000D_1_Descrip_0000E, 1
097A  D031      	BRA	label78
09DE            label78

                            /* 22 special HID request to return report descriptor */
					        USB_dev_req = GET_DESCRIPTOR;
097C  0E06      	MOVLW 0x06
097E  6FEB      	MOVWF gbl_USB_dev_req, 1

					        if (BufferCopy.wIndex == 0);
0980  53C3      	MOVF gbl_BufferCopy+D'4', F, 1
0982  B4D8      	BTFSC STATUS,Z
0984  53C4      	MOVF gbl_BufferCopy+D'5', F, 1

					        {
						        EP0_start = ReportDescriptor1;
0986  0E00      	MOVLW HIGH(gbl_ReportDescriptor1+D'0')
0988  6FDC      	MOVWF gbl_EP0_start+D'1', 1
098A  0E05      	MOVLW LOW(gbl_ReportDescriptor1+D'0')
098C  6FDB      	MOVWF gbl_EP0_start, 1

				                EP0_end = EP0_start + sizeof(ReportDescriptor1);
098E  6BDE      	CLRF gbl_EP0_end+D'1', 1
0990  0E32      	MOVLW 0x32
0992  25DB      	ADDWF gbl_EP0_start, W, 1
0994  6FDD      	MOVWF gbl_EP0_end, 1
0996  51DC      	MOVF gbl_EP0_start+D'1', W, 1
0998  23DE      	ADDWFC gbl_EP0_end+D'1', F, 1

						        EP0_maxLength = 8;
099A  0E08      	MOVLW 0x08
099C  6FF0      	MOVWF gbl_EP0_maxLength, 1

				                if (BufferCopy.wLength < sizeof (ReportDescriptor1))
099E  0E32      	MOVLW 0x32
09A0  5DC5      	SUBWF gbl_BufferCopy+D'6', W, 1
09A2  E215      	BC	label77
09A4  67C6      	TSTFSZ gbl_BufferCopy+D'7', 1
09A6  D013      	BRA	label77
09CE            label77

							        EP0_end = EP0_start + BufferCopy.wLength;
09A8  51C5      	MOVF gbl_BufferCopy+D'6', W, 1
09AA  25DB      	ADDWF gbl_EP0_start, W, 1
09AC  0101      	MOVLB 0x01
09AE  6F1E      	MOVWF CompTempVar701, 1
09B0  0100      	MOVLB 0x00
09B2  51C6      	MOVF gbl_BufferCopy+D'7', W, 1
09B4  0101      	MOVLB 0x01
09B6  6F1F      	MOVWF CompTempVar702, 1
09B8  0100      	MOVLB 0x00
09BA  51DC      	MOVF gbl_EP0_start+D'1', W, 1
09BC  0101      	MOVLB 0x01
09BE  231F      	ADDWFC CompTempVar702, F, 1
09C0  511E      	MOVF CompTempVar701, W, 1
09C2  0100      	MOVLB 0x00
09C4  6FDD      	MOVWF gbl_EP0_end, 1
09C6  0101      	MOVLB 0x01
09C8  511F      	MOVF CompTempVar702, W, 1
09CA  0100      	MOVLB 0x00
09CC  6FDE      	MOVWF gbl_EP0_end+D'1', 1

						        CopyDescriptorToEP0();
09CE  EC59F000  	CALL CopyDescri_0000B

					        }
					        if (BufferCopy.wIndex == 1);
09D2  0E01      	MOVLW 0x01
09D4  0100      	MOVLB 0x00
09D6  63C3      	CPFSEQ gbl_BufferCopy+D'4', 1
09DA  51C4      	MOVF gbl_BufferCopy+D'5', W, 1

					        {
					            /* Repeat above code for another Report Descriptor. */
					        }
				        } else if (DescriptorType == HID_DESCRIPTOR) {
09DE  0E21      	MOVLW 0x21
09E0  63FC      	CPFSEQ Process_Re_0000D_1_Descrip_0000E, 1
09E2  D032      	BRA	label81
0A48            label81

				            /* 21 HID descriptor */
					        USB_dev_req = GET_DESCRIPTOR;
09E4  0E06      	MOVLW 0x06
09E6  6FEB      	MOVWF gbl_USB_dev_req, 1

					        if (BufferCopy.wIndex == 0) {
09E8  53C3      	MOVF gbl_BufferCopy+D'4', F, 1
09EA  E128      	BNZ	label80
09EC  53C4      	MOVF gbl_BufferCopy+D'5', F, 1
09EE  E126      	BNZ	label80
0A3C            label80

						        EP0_start = HIDDescriptor;
09F0  0E00      	MOVLW HIGH(gbl_HIDDescriptor+D'0')
09F2  6FDC      	MOVWF gbl_EP0_start+D'1', 1
09F4  0EB6      	MOVLW LOW(gbl_HIDDescriptor+D'0')
09F6  6FDB      	MOVWF gbl_EP0_start, 1

						        EP0_end   = EP0_start + sizeof (HIDDescriptor);
09F8  6BDE      	CLRF gbl_EP0_end+D'1', 1
09FA  0E09      	MOVLW 0x09
09FC  25DB      	ADDWF gbl_EP0_start, W, 1
09FE  6FDD      	MOVWF gbl_EP0_end, 1
0A00  51DC      	MOVF gbl_EP0_start+D'1', W, 1
0A02  23DE      	ADDWFC gbl_EP0_end+D'1', F, 1

						        EP0_maxLength = 8;
0A04  0E08      	MOVLW 0x08
0A06  6FF0      	MOVWF gbl_EP0_maxLength, 1

						        if (BufferCopy.wLength < sizeof (HIDDescriptor))
0A08  0E09      	MOVLW 0x09
0A0A  5DC5      	SUBWF gbl_BufferCopy+D'6', W, 1
0A0C  E215      	BC	label79
0A0E  67C6      	TSTFSZ gbl_BufferCopy+D'7', 1
0A10  D013      	BRA	label79
0A38            label79

							        EP0_end = EP0_start + BufferCopy.wLength;
0A12  51C5      	MOVF gbl_BufferCopy+D'6', W, 1
0A14  25DB      	ADDWF gbl_EP0_start, W, 1
0A16  0101      	MOVLB 0x01
0A18  6F1E      	MOVWF CompTempVar706, 1
0A1A  0100      	MOVLB 0x00
0A1C  51C6      	MOVF gbl_BufferCopy+D'7', W, 1
0A1E  0101      	MOVLB 0x01
0A20  6F1F      	MOVWF CompTempVar707, 1
0A22  0100      	MOVLB 0x00
0A24  51DC      	MOVF gbl_EP0_start+D'1', W, 1
0A26  0101      	MOVLB 0x01
0A28  231F      	ADDWFC CompTempVar707, F, 1
0A2A  511E      	MOVF CompTempVar706, W, 1
0A2C  0100      	MOVLB 0x00
0A2E  6FDD      	MOVWF gbl_EP0_end, 1
0A30  0101      	MOVLB 0x01
0A32  511F      	MOVF CompTempVar707, W, 1
0A34  0100      	MOVLB 0x00
0A36  6FDE      	MOVWF gbl_EP0_end+D'1', 1

						        CopyDescriptorToEP0();
0A38  EC59F000  	CALL CopyDescri_0000B

					        }
					        if (BufferCopy.wIndex == 1) {
0A3C  0E01      	MOVLW 0x01
0A3E  0100      	MOVLB 0x00
0A40  63C3      	CPFSEQ gbl_BufferCopy+D'4', 1
0A44  51C4      	MOVF gbl_BufferCopy+D'5', W, 1

						        /* Repeat above code for another HID Descriptor. */
					        }
				        } else {
                            /* unrecognised request */
					        STALL_EP0;
0A48  8070      	BSF gbl_uep0,0

                        }
				        break;
			        default:
				        break;
			    }
			    break;
            // Sixth bmRequestType ************************************	
		    case ENDPOINTTOHOST:
02EC  0E82      	MOVLW 0x82
02EE  63BF      	CPFSEQ gbl_BufferCopy, 1
02F0  D3FB      	BRA	label84
0A4C            label82

			    if (BufferCopy.bRequest == GET_STATUS) {   
0A4C  53C0      	MOVF gbl_BufferCopy+D'1', F, 1
0A4E  A4D8      	BTFSS STATUS,Z

				    UEPArray = (unsigned char *) &uep0;
0A52  0E0F      	MOVLW HIGH(gbl_uep0+D'0')
0A54  0101      	MOVLB 0x01
0A56  6F1E      	MOVWF CompTempVar708, 1
0A58  0E70      	MOVLW LOW(gbl_uep0+D'0')
0A5A  0100      	MOVLB 0x00
0A5C  6FFA      	MOVWF Process_Re_0000D_1_UEPArray, 1
0A5E  0101      	MOVLB 0x01
0A60  511E      	MOVF CompTempVar708, W, 1
0A62  0100      	MOVLB 0x00
0A64  6FFB      	MOVWF Process_Re_0000D_1_UEPArray+D'1', 1

				    Endpoint = BufferCopy.wIndex & 0x0F;
0A66  0E0F      	MOVLW 0x0F
0A68  15C3      	ANDWF gbl_BufferCopy+D'4', W, 1
0A6A  6FFD      	MOVWF Process_Re_0000D_1_Endpoint, 1

                    OutBuffer = (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie << 8));
0A6C  0104      	MOVLB 0x04
0A6E  5106      	MOVF gbl_bd0adrlie, W, 1
0A70  0101      	MOVLB 0x01
0A72  6F1E      	MOVWF CompTempVar709, 1
0A74  6B21      	CLRF CompTempVar711+D'1', 1
0A76  6B22      	CLRF CompTempVar712, 1
0A78  0104      	MOVLB 0x04
0A7A  5107      	MOVF gbl_bd0adrhie, W, 1
0A7C  0101      	MOVLB 0x01
0A7E  6F1F      	MOVWF CompTempVar710, 1
0A80  5122      	MOVF CompTempVar712, W, 1
0A82  271E      	ADDWF CompTempVar709, F, 1
0A84  5121      	MOVF CompTempVar711+D'1', W, 1
0A86  231F      	ADDWFC CompTempVar710, F, 1
0A88  511E      	MOVF CompTempVar709, W, 1
0A8A  0100      	MOVLB 0x00
0A8C  6FF8      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0A8E  0101      	MOVLB 0x01
0A90  511F      	MOVF CompTempVar710, W, 1
0A92  0100      	MOVLB 0x00
0A94  6FF9      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

		            //		OutBuffer = (unsigned char * ) bd0adrlie;
				    OutBuffer[1] = 0;
0A96  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0A98  6EEA      	MOVWF FSR0H
0A9A  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0A9C  6EE9      	MOVWF FSR0L
0A9E  0E01      	MOVLW 0x01
0AA0  26E9      	ADDWF FSR0L, F
0AA2  0E00      	MOVLW 0x00
0AA4  6EEF      	MOVWF INDF0

				    bd0cntie = 2;
0AA6  0E02      	MOVLW 0x02
0AA8  0104      	MOVLB 0x04
0AAA  6F05      	MOVWF gbl_bd0cntie, 1


				    if (Endpoint < 3) {
0AAC  0E03      	MOVLW 0x03
0AAE  0100      	MOVLB 0x00
0AB0  61FD      	CPFSLT Process_Re_0000D_1_Endpoint, 1
0AB2  D018      	BRA	label83
0AE4            label83

					    OutBuffer[0] = UEPArray [Endpoint] & 0x01;
0AB4  51FB      	MOVF Process_Re_0000D_1_UEPArray+D'1', W, 1
0AB6  6EEA      	MOVWF FSR0H
0AB8  51FA      	MOVF Process_Re_0000D_1_UEPArray, W, 1
0ABA  25FD      	ADDWF Process_Re_0000D_1_Endpoint, W, 1
0ABC  6EE9      	MOVWF FSR0L
0ABE  0E01      	MOVLW 0x01
0AC0  14EF      	ANDWF INDF0, W
0AC2  0101      	MOVLB 0x01
0AC4  6F1F      	MOVWF CompTempVar720, 1
0AC6  0100      	MOVLB 0x00
0AC8  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0ACA  6EEA      	MOVWF FSR0H
0ACC  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0ACE  6EE9      	MOVWF FSR0L
0AD0  0101      	MOVLB 0x01
0AD2  6B1E      	CLRF CompTempVar716, 1
0AD4  511E      	MOVF CompTempVar716, W, 1
0AD6  26E9      	ADDWF FSR0L, F
0AD8  511F      	MOVF CompTempVar720, W, 1
0ADA  6EEF      	MOVWF INDF0

					    bd0statie = 0xc8;
0ADC  0EC8      	MOVLW 0xC8
0ADE  0104      	MOVLB 0x04
0AE0  6F04      	MOVWF gbl_bd0statie, 1

				    } else {
					    STALL_EP0;
0AE4  8070      	BSF gbl_uep0,0

                    }
			    }
			    break;
            // Seventh bmRequestType (others) ************************************	
		    default:
0AE8            label84

		        if (BufferCopy.bmRequestType & 0x20) {
0AE8  ABBF      	BTFSS gbl_BufferCopy,5, 1

	                OutBuffer =  (unsigned char *) ((unsigned int)bd0adrlie + (unsigned int)(bd0adrhie <<8));						
0AEC  0104      	MOVLB 0x04
0AEE  5106      	MOVF gbl_bd0adrlie, W, 1
0AF0  0101      	MOVLB 0x01
0AF2  6F1E      	MOVWF CompTempVar721, 1
0AF4  6B21      	CLRF CompTempVar723+D'1', 1
0AF6  6B22      	CLRF CompTempVar724, 1
0AF8  0104      	MOVLB 0x04
0AFA  5107      	MOVF gbl_bd0adrhie, W, 1
0AFC  0101      	MOVLB 0x01
0AFE  6F1F      	MOVWF CompTempVar722, 1
0B00  5122      	MOVF CompTempVar724, W, 1
0B02  271E      	ADDWF CompTempVar721, F, 1
0B04  5121      	MOVF CompTempVar723+D'1', W, 1
0B06  231F      	ADDWFC CompTempVar722, F, 1
0B08  511E      	MOVF CompTempVar721, W, 1
0B0A  0100      	MOVLB 0x00
0B0C  6FF8      	MOVWF Process_Re_0000D_1_OutBuffer, 1
0B0E  0101      	MOVLB 0x01
0B10  511F      	MOVF CompTempVar722, W, 1
0B12  0100      	MOVLB 0x00
0B14  6FF9      	MOVWF Process_Re_0000D_1_OutBuffer+D'1', 1

				    switch (BufferCopy.bmRequestType) {
				        case 0x21:	
0B16  0E21      	MOVLW 0x21
0B18  63BF      	CPFSEQ gbl_BufferCopy, 1
0B1A  D001      	BRA	label85
0B1C  D014      	BRA	label90
0B1E            label85
0B46            label90

                            /* Host to Device HID request */
					        switch (BufferCopy.bRequest) {
					            case HID_SET_PROTOCOL:	
0B46  0E0B      	MOVLW 0x0B
0B48  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
0B4A  D001      	BRA	label91
0B4C  D008      	BRA	label93
0B4E            label91
0B5E            label93

                                    /* Set Protocol */
						            USB_protocol = BufferCopy.wValue;
0B5E  51C1      	MOVF gbl_BufferCopy+D'2', W, 1
0B60  6FEE      	MOVWF gbl_USB_protocol, 1

						            Send_0Len_pkt;	
0B62  0104      	MOVLB 0x04
0B64  6B05      	CLRF gbl_bd0cntie, 1
0B66  0EC8      	MOVLW 0xC8
0B68  6F04      	MOVWF gbl_bd0statie, 1
0B6A  0100      	MOVLB 0x00
0B6C  6BEB      	CLRF gbl_USB_dev_req, 1

						            break;
					            case HID_SET_REPORT:
0B4E  0E09      	MOVLW 0x09
0B50  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
0B52  D001      	BRA	label92
0B56            label92

                                    /* Set HID Report */
	                                // Add Set_Report Function above for OUT TOKEN and uncomment following two lines
					                //	USB_dev_req = HID_SET_REPORT;
						            break;
					            case HID_SET_IDLE:
0B56  0E0A      	MOVLW 0x0A
0B58  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
0B5A  D00C      	BRA	label95
0B70            label94

                                    /* Set Idle */
					                STALL_EP0;
0B70  8070      	BSF gbl_uep0,0

					                break;
					            default:
0B74            label95

					                STALL_EP0;
0B74  8070      	BSF gbl_uep0,0

					        }
					        break;
				    case 0xA1:
0B1E  0EA1      	MOVLW 0xA1
0B20  63BF      	CPFSEQ gbl_BufferCopy, 1
0B22  D001      	BRA	label86
0B24  D029      	BRA	label96
0B26            label86
0B78            label96

                        /* Dev2HostHIDRequest */
						switch (BufferCopy.bRequest) {
					        case HID_GET_PROTOCOL:	/* Get Protocol */
0B78  0E03      	MOVLW 0x03
0B7A  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
0B7C  D001      	BRA	label97
0B7E  D007      	BRA	label98
0B80            label97
0B8E            label98

						        OutBuffer[0] = USB_protocol;
0B8E  51F9      	MOVF Process_Re_0000D_1_OutBuffer+D'1', W, 1
0B90  6EEA      	MOVWF FSR0H
0B92  51F8      	MOVF Process_Re_0000D_1_OutBuffer, W, 1
0B94  6EE9      	MOVWF FSR0L
0B96  0101      	MOVLB 0x01
0B98  6B1E      	CLRF CompTempVar727, 1
0B9A  511E      	MOVF CompTempVar727, W, 1
0B9C  26E9      	ADDWF FSR0L, F
0B9E  0100      	MOVLB 0x00
0BA0  51EE      	MOVF gbl_USB_protocol, W, 1
0BA2  6EEF      	MOVWF INDF0

						        bd0cntie = 1;
0BA4  0E01      	MOVLW 0x01
0BA6  0104      	MOVLB 0x04
0BA8  6F05      	MOVWF gbl_bd0cntie, 1

						        bd0statie = 0xC8;
0BAA  0EC8      	MOVLW 0xC8
0BAC  6F04      	MOVWF gbl_bd0statie, 1

						        break;
					        case HID_GET_REPORT: /* Get HID Report */
0B80  05C0      	DECF gbl_BufferCopy+D'1', W, 1
0B82  B4D8      	BTFSC STATUS,Z

	                            // Add Get_Report Function here and uncomment following two lines
			    		        //	BD0IST = 0xc8;	// Turn over BDT to SIE
						        break;
					        case HID_GET_IDLE:
0B86  0E02      	MOVLW 0x02
0B88  63C0      	CPFSEQ gbl_BufferCopy+D'1', 1
0B8A  D014      	BRA	label100
0BB0            label99

                                /* Get Idle */
					            STALL_EP0;
0BB0  8070      	BSF gbl_uep0,0

					            break;
					        default:
0BB4            label100

                                // device does not support get idle, just stall
					            STALL_EP0;
0BB4  8070      	BSF gbl_uep0,0

					    }
					    break;
				    case 0x22:
0B26  0E22      	MOVLW 0x22
0B28  63BF      	CPFSEQ gbl_BufferCopy, 1
0B2A  D001      	BRA	label87
0B2C  D045      	BRA	label101
0B2E            label87
0BB8            label101

                        /* Host2DevReportRequest */
					    STALL_EP0;
0BB8  8070      	BSF gbl_uep0,0

					    break;				
				    case 0x23:
0B2E  0E23      	MOVLW 0x23
0B30  63BF      	CPFSEQ gbl_BufferCopy, 1
0B32  D001      	BRA	label88
0B34  D043      	BRA	label102
0B36            label88
0BBC            label102

                        /* Host2DevPhysicalRequest */
					    STALL_EP0;
0BBC  8070      	BSF gbl_uep0,0

					    break;				
				    case 0xA2:
0B36  0EA2      	MOVLW 0xA2
0B38  63BF      	CPFSEQ gbl_BufferCopy, 1
0B3A  D001      	BRA	label89
0B3C  D041      	BRA	label103
0B3E            label89
0BC0            label103

                        /* Dev2HostReportRequest */
					    STALL_EP0;
0BC0  8070      	BSF gbl_uep0,0

					    break;				
				    case 0xA3:
0B3E  0EA3      	MOVLW 0xA3
0B40  63BF      	CPFSEQ gbl_BufferCopy, 1
0B42  D042      	BRA	label105
0BC4            label104

                        /* Dev2HostPhysicalRequest */
					    STALL_EP0;
0BC4  8070      	BSF gbl_uep0,0

					    break;				
				    default:
0BC8            label105

    				    STALL_EP0;
0BC8  8070      	BSF gbl_uep0,0

				}
			}
    	}
    }
}
0206  0012      	RETURN
020C  0012      	RETURN
0212  0012      	RETURN
0214  0012      	RETURN
0228  0012      	RETURN
022E  0012      	RETURN
0230  0012      	RETURN
023C  0012      	RETURN
0328  0012      	RETURN
032C  0012      	RETURN
0350  0012      	RETURN
0354  0012      	RETURN
0374  0012      	RETURN
0378  0012      	RETURN
03AE  0012      	RETURN
03B2  0012      	RETURN
03EC  0012      	RETURN
03F0  0012      	RETURN
03F4  0012      	RETURN
0444  0012      	RETURN
0476  0012      	RETURN
047A  0012      	RETURN
047E  0012      	RETURN
04CE  0012      	RETURN
0500  0012      	RETURN
0504  0012      	RETURN
0508  0012      	RETURN
050C  0012      	RETURN
0524  0012      	RETURN
056C  0012      	RETURN
05EE  0012      	RETURN
066E  0012      	RETURN
070A  0012      	RETURN
077E  0012      	RETURN
07F2  0012      	RETURN
07FA  0012      	RETURN
0802  0012      	RETURN
0848  0012      	RETURN
085A  0012      	RETURN
08BA  0012      	RETURN
08BE  0012      	RETURN
092E  0012      	RETURN
096C  0012      	RETURN
0970  0012      	RETURN
09D8  0012      	RETURN
09DC  0012      	RETURN
0A42  0012      	RETURN
0A46  0012      	RETURN
0A4A  0012      	RETURN
0A50  0012      	RETURN
0AE2  0012      	RETURN
0AE6  0012      	RETURN
0AEA  0012      	RETURN
0B54  0012      	RETURN
0B6E  0012      	RETURN
0B72  0012      	RETURN
0B76  0012      	RETURN
0B84  0012      	RETURN
0BAE  0012      	RETURN
0BB2  0012      	RETURN
0BB6  0012      	RETURN
0BBA  0012      	RETURN
0BBE  0012      	RETURN
0BC2  0012      	RETURN
0BC6  0012      	RETURN
0BCA  0012      	RETURN


/***********************************************************************************
 Branch off and service the USB interrupt flags
***********************************************************************************/
void ServiceUSB() {

	if (uir.TRNIF)
0C58  B668      	BTFSC gbl_uir,3

		Process_Req();
0C5A  ECACF000  	CALL Process_Re_0000D

	
    if (uir.STALLIF)
0C5E  BA68      	BTFSC gbl_uir,5

		USBStall();
0C60  ECA3F000  	CALL USBStall_00000

	
    if (uir.UERRIF)
0C64  B268      	BTFSC gbl_uir,1

	    Count_Error();
0C66  ECE6F005  	CALL Count_Erro_0000C

	
    if (uie.IDLEIE)	
0C6A  B869      	BTFSC gbl_uie,4

		USBSleep();
0C6C  ECA5F000  	CALL USBSleep_00000

}
0C70  0012      	RETURN


/***********************************************************************************
 Interrupt service routine. Branch off to different interrupts
***********************************************************************************/
void interrupt(void) {

    if (pie2.USBIE && pir2.USBIF) {
111C  CFEAF001  	MOVFF FSR0H,  Int1Context
1120  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
1124  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
1128  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
112C  AAA0      	BTFSS gbl_pie2,5
112E  D026      	BRA	label128
1130  AAA1      	BTFSS gbl_pir2,5
1132  D024      	BRA	label128
117C            label128

		if (uir.ACTVIF && uie.ACTVIE) // WAS IT AN ACTIVITY WAKEUP?
1134  A468      	BTFSS gbl_uir,2
1136  D004      	BRA	label123
1138  A469      	BTFSS gbl_uie,2
113A  D002      	BRA	label123
1140            label123

			USBActivity();
113C  EC53F000  	CALL USBActivit_0000A

		
        if (uir.URSTIF && uie.URSTIE) // USB reset must be serviced immediately
1140  A068      	BTFSS gbl_uir,0
1142  D004      	BRA	label124
1144  A069      	BTFSS gbl_uie,0
1146  D002      	BRA	label124
114C            label124

			USBReset();
1148  EC3AF000  	CALL USBReset_00000

		
        if (uir.TRNIF && uie.TRNIE) { // WAS IT A TOKEN DONE 
114C  A668      	BTFSS gbl_uir,3
114E  D015      	BRA	label127
1150  A669      	BTFSS gbl_uie,3
1152  D013      	BRA	label127
117A            label127

			if (USB_dev_req == SET_ADDRESS)	{
1154  0E05      	MOVLW 0x05
1156  0100      	MOVLB 0x00
1158  63EB      	CPFSEQ gbl_USB_dev_req, 1
115A  D00E      	BRA	label126

                // Finish Set Address
				USB_dev_req = NULL;
115C  6BEB      	CLRF gbl_USB_dev_req, 1

				USB_Curr_Config = 0;
115E  6BE9      	CLRF gbl_USB_Curr_Config, 1

				uaddr = USB_address_pending;
1160  51EA      	MOVF gbl_USB_address_pending, W, 1
1162  6E6E      	MOVWF gbl_uaddr

				uie = 00000001b;		// enable just the reset interrupt
1164  0E01      	MOVLW 0x01
1166  6E69      	MOVWF gbl_uie

 				if (USB_address_pending > 0)
1168  0E00      	MOVLW 0x00
116A  65EA      	CPFSGT gbl_USB_address_pending, 1
116C  D003      	BRA	label125
1174            label125

					USWSTAT= ADDRESS_STATE;
116E  0E02      	MOVLW 0x02
1170  6FEF      	MOVWF gbl_USWSTAT, 1

				else
1172  D002      	BRA	label126
1178            label126

					USWSTAT= DEFAULT_STATE;
1174  0E01      	MOVLW 0x01
1176  6FEF      	MOVWF gbl_USWSTAT, 1

			}
			uir.TRNIF = 0; // clear Token Done flag
1178  9668      	BCF gbl_uir,3

		}
		pir2.USBIF = 0;	 // Clear USB interrupt flag
117A  9AA1      	BCF gbl_pir2,5

	}
}
117C  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1180  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1184  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
1188  C001FFEA  	MOVFF Int1Context,  FSR0H
118C  0011      	RETFIE 1


char read_button() {

	if (!BUTTON)
0134  B481      	BTFSC gbl_portb,2
0136  D004      	BRA	label7
0140            label7

		return 1;
0138  0E01      	MOVLW 0x01
013A  0100      	MOVLB 0x00
013C  6FFA      	MOVWF CompTempVarRet728, 1

	else
		return 0;
0140  0100      	MOVLB 0x00
0142  6BFA      	CLRF CompTempVarRet728, 1

}
013E  0012      	RETURN
0144  0012      	RETURN


char testButton() {

    static char button_history = 0;
0C26  0100      	MOVLB 0x00
0C28  B3E5      	BTFSC CompGblVar48,1, 1
0C2A  D002      	BRA	label112
0C2C  6BF1      	CLRF testButton_00000_1_button__00010, 1
0C2E  83E5      	BSF CompGblVar48,1, 1
0C30            label112
0E26  0100      	MOVLB 0x00
0E28  93E5      	BCF CompGblVar48,1, 1

    char pressed = 0;    
0C30  6BF8      	CLRF testButton_00000_1_pressed, 1

 
    button_history = button_history << 1;
0C32  53F1      	MOVF testButton_00000_1_button__00010, F, 1
0C34  90D8      	BCF STATUS,C
0C36  37F1      	RLCF testButton_00000_1_button__00010, F, 1

    button_history |= read_button();
0C38  EC9AF000  	CALL read_butto_0000F
0C3C  51FA      	MOVF CompTempVarRet728, W, 1
0C3E  13F1      	IORWF testButton_00000_1_button__00010, F, 1

    if ((button_history & 0b11000111) == 0b00000111) { 
0C40  0EC7      	MOVLW 0xC7
0C42  15F1      	ANDWF testButton_00000_1_button__00010, W, 1
0C44  6FF9      	MOVWF CompTempVar730, 1
0C46  0E07      	MOVLW 0x07
0C48  63F9      	CPFSEQ CompTempVar730, 1
0C4A  D003      	BRA	label113
0C52            label113

        pressed = 1;
0C4C  0E01      	MOVLW 0x01
0C4E  6FF8      	MOVWF testButton_00000_1_pressed, 1

        button_history = 0b11111111;
0C50  69F1      	SETF testButton_00000_1_button__00010, 1

    }
    return pressed;
0C52  51F8      	MOVF testButton_00000_1_pressed, W, 1
0C54  6FFA      	MOVWF CompTempVarRet729, 1

}
0C56  0012      	RETURN


/***********************************************************************************
 THE MAIN PROGRAM
***********************************************************************************/
void main() {


    // IO ports setup
    trisa = 0x00; // all ouptuts
0D36  6A92      	CLRF gbl_trisa

    porta = 0x00; // set to off
0D38  6A80      	CLRF gbl_porta

    trisb = 0x04; // RB2 input
0D3A  0E04      	MOVLW 0x04
0D3C  6E93      	MOVWF gbl_trisb

    portb = 0x00; // set to off
0D3E  6A81      	CLRF gbl_portb

    trisc = 0x00; // all ouptuts
0D40  6A94      	CLRF gbl_trisc

    portc = 0x00; // set to off
0D42  6A82      	CLRF gbl_portc


    intcon2.RBPU = 0; // Port B pull-ups enabled
0D44  9EF1      	BCF gbl_intcon2,7


    // ADC setup
    adcon0 = 0x00; //  ADC off
0D46  6AC2      	CLRF gbl_adcon0

    adcon1 = 0x0F; // All digital I/O
0D48  0E0F      	MOVLW 0x0F
0D4A  6EC1      	MOVWF gbl_adcon1


	unsigned char i;
	unsigned short j;
	signed char buffer[3];
    const signed char tablex [] = {-1, -1, -1, 1, 1, 1,  1,  1, 1, -1,  -1, -1};
0D4C  0101      	MOVLB 0x01
0D4E  6900      	SETF main_1_tablex, 1
0D50  6901      	SETF main_1_tablex+D'1', 1
0D52  6902      	SETF main_1_tablex+D'2', 1
0D54  0E01      	MOVLW 0x01
0D56  6F03      	MOVWF main_1_tablex+D'3', 1
0D58  6F04      	MOVWF main_1_tablex+D'4', 1
0D5A  6F05      	MOVWF main_1_tablex+D'5', 1
0D5C  6F06      	MOVWF main_1_tablex+D'6', 1
0D5E  6F07      	MOVWF main_1_tablex+D'7', 1
0D60  6F08      	MOVWF main_1_tablex+D'8', 1
0D62  6909      	SETF main_1_tablex+D'9', 1
0D64  690A      	SETF main_1_tablex+D'10', 1
0D66  690B      	SETF main_1_tablex+D'11', 1

    const signed char tabley [] = {-1, 0, 1,  1,  0, -1, -1, 0,  1, 1, 0, -1 };
0D68  690C      	SETF main_1_tabley, 1
0D6A  6B0D      	CLRF main_1_tabley+D'1', 1
0D6C  0E01      	MOVLW 0x01
0D6E  6F0E      	MOVWF main_1_tabley+D'2', 1
0D70  6F0F      	MOVWF main_1_tabley+D'3', 1
0D72  6B10      	CLRF main_1_tabley+D'4', 1
0D74  6911      	SETF main_1_tabley+D'5', 1
0D76  6912      	SETF main_1_tabley+D'6', 1
0D78  6B13      	CLRF main_1_tabley+D'7', 1
0D7A  0E01      	MOVLW 0x01
0D7C  6F14      	MOVWF main_1_tabley+D'8', 1
0D7E  6F15      	MOVWF main_1_tabley+D'9', 1
0D80  6B16      	CLRF main_1_tabley+D'10', 1
0D82  6917      	SETF main_1_tabley+D'11', 1

	// The table array contains the directional data for simulated mouse movement to 
	// form the infinity symbol (i.e. figure 8). Movements are relative to the 
	// previous position. 
	ddrb = 0;
0D84  6A93      	CLRF gbl_ddrb

	delay_ms(14);
0D86  0E0E      	MOVLW 0x0E
0D88  0100      	MOVLB 0x00
0D8A  6FF8      	MOVWF delay_ms_00000_arg_del, 1
0D8C  EC06F000  	CALL delay_ms_00000


	InitUSB(); // allow SIE to come online before beginning USB initialization
0D90  EC7DF006  	CALL InitUSB_00000

	buffer[0] = 0;	//we won't be simulating mouse buttons		
0D94  6BF5      	CLRF main_1_buffer, 1

	i = 10;
0D96  0E0A      	MOVLW 0x0A
0D98  6FF2      	MOVWF main_1_i, 1

	j = 0;
0D9A  6BF3      	CLRF main_1_j, 1
0D9C  6BF4      	CLRF main_1_j+D'1', 1

    
    //set up timer0 as 8 bit timer with prescaler of 256 and enable
    // 4/24* 10^6 * 256 * 256 = 10.9 msec timer overflow
    t0con = 11000111b; 
0D9E  0EC7      	MOVLW 0xC7
0DA0  6ED5      	MOVWF gbl_t0con

    
    while (1) {
0DA2            label117
0E24  D7BE      	BRA	label117

		// Poll all functions every 10.9ms
		if (intcon.TMR0IF) { 
0DA2  A4F2      	BTFSS gbl_intcon,2
0DA4  D02C      	BRA	label121

			if (testButton()) {
0DA6  EC13F006  	CALL testButton_00000
0DAA  53FA      	MOVF CompTempVarRet729, F, 1
0DAC  E007      	BZ	label119

				if (!isJiggling) {
0DAE  B1E5      	BTFSC gbl_isJiggling,0, 1
0DB0  D003      	BRA	label118
0DB8            label118

                    isJiggling = 1;
0DB2  81E5      	BSF gbl_isJiggling,0, 1

                    LED = 1;
0DB4  8281      	BSF gbl_portb,1

                } else {
0DB6  D002      	BRA	label119
0DBC            label119

                    isJiggling = 0;
0DB8  91E5      	BCF gbl_isJiggling,0, 1

                    LED = 0;
0DBA  9281      	BCF gbl_portb,1

                }
            }
			
			intcon.TMR0IF = 0;   // clear the timer flag
0DBC  94F2      	BCF gbl_intcon,2

			ServiceUSB();	// Service USB functions
0DBE  EC2CF006  	CALL ServiceUSB_00000

			if (isJiggling) {
0DC2  0100      	MOVLB 0x00
0DC4  A1E5      	BTFSS gbl_isJiggling,0, 1
0DC6  D01B      	BRA	label121
0DFE            label121

                // send same data 10 times (100 msec)
                if (i > 9) {
0DC8  0E09      	MOVLW 0x09
0DCA  65F2      	CPFSGT main_1_i, 1
0DCC  D00A      	BRA	label120

                    i = 0;
0DCE  6BF2      	CLRF main_1_i, 1

                    j++;
0DD0  4BF3      	INFSNZ main_1_j, F, 1
0DD2  2BF4      	INCF main_1_j+D'1', F, 1

                    // (limit to length of table array)
                    if (j == 12)
0DD4  0E0C      	MOVLW 0x0C
0DD6  63F3      	CPFSEQ main_1_j, 1
0DD8  D004      	BRA	label120
0DDA  51F4      	MOVF main_1_j+D'1', W, 1
0DDC  E102      	BNZ	label120
0DE2            label120

                        j = 0;
0DDE  6BF3      	CLRF main_1_j, 1
0DE0  6BF4      	CLRF main_1_j+D'1', 1

                }
                // Increment infinity vectors
                buffer[1] = tablex[j];	// X vector 
0DE2  EE01F000  	LFSR 0x00,  main_1_tablex
0DE6  50E9      	MOVF FSR0L, W
0DE8  51F3      	MOVF main_1_j, W, 1
0DEA  26E9      	ADDWF FSR0L, F
0DEC  50EF      	MOVF INDF0, W
0DEE  6FF6      	MOVWF main_1_buffer+D'1', 1

                buffer[2] = tabley[j];	// Y vector
0DF0  EE01F00C  	LFSR 0x00,  main_1_tabley
0DF4  50E9      	MOVF FSR0L, W
0DF6  51F3      	MOVF main_1_j, W, 1
0DF8  26E9      	ADDWF FSR0L, F
0DFA  50EF      	MOVF INDF0, W
0DFC  6FF7      	MOVWF main_1_buffer+D'2', 1

            }
        }
        if (ConfiguredUSB()) {
0DFE  0E03      	MOVLW 0x03
0E00  15EF      	ANDWF gbl_USWSTAT, W, 1
0E02  6FF8      	MOVWF CompTempVar737, 1
0E04  0E03      	MOVLW 0x03
0E06  63F8      	CPFSEQ CompTempVar737, 1
0E08  D7CC      	BRA	label117

            // Wait until device is configured before using EP1.  If Endpoints 1 or 2 are used before
			//   the device is configured, errors will occur.
		    if (isJiggling) {
0E0A  A1E5      	BTFSS gbl_isJiggling,0, 1
0E0C  D7CA      	BRA	label117

				if (PutEP1(3, buffer)) {
0E0E  0E03      	MOVLW 0x03
0E10  6FF8      	MOVWF PutEP1_00000_arg_bytes, 1
0E12  0E00      	MOVLW HIGH(main_1_buffer+D'0')
0E14  6FFA      	MOVWF PutEP1_00000_arg_buffer+D'1', 1
0E16  0EF5      	MOVLW LOW(main_1_buffer+D'0')
0E18  6FF9      	MOVWF PutEP1_00000_arg_buffer, 1
0E1A  EC39F006  	CALL PutEP1_00000
0E1E  53FF      	MOVF CompTempVarRet570, F, 1
0E20  A4D8      	BTFSS STATUS,Z

					// Increment i if EP1 IN buffer is accessible to the PIC.
					// If not accessible, try again next time.
					i++;
0E22  2BF2      	INCF main_1_i, F, 1

				}
			}
		}
	}
}

}
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF13F007  	GOTO	_startup

0008  EF8EF008  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53F8      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF9      	MOVLW 0xF9
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0FFF      	ADDLW 0xFF
0040  A4D8      	BTFSS STATUS,Z
0042  D7E9      	BRA	label2
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  0000      	NOP
0062  0000      	NOP
0064  0000      	NOP
0066  0000      	NOP
0068  0000      	NOP
006A  0000      	NOP
006C  0000      	NOP
006E  2FF8      	DECFSZ delay_ms_00000_arg_del, F, 1
0070  D7D1      	BRA	label1
0072  0012      	RETURN
0074            ; } delay_ms function end
































0E26            _startup

1118  EF9BF006  	GOTO	main

300000  0E30      	DW 0x0E30
300002  1E3E      	DW 0x1E3E
300004  00FF      	DW 0x00FF
300006  FF80      	DW 0xFF80
300008  C00F      	DW 0xC00F
30000A  E00F      	DW 0xE00F
30000C  400F      	DW 0x400F
