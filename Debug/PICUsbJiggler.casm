;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PICUSBJIGGLER_H_
#define _PICUSBJIGGLER_H_

#define LED (portb.1) // LED pin
#define BUTTON (portb.0) // Button (switch) pin

bit isJiggling = 0; // When 0, device does nothing
106A  0100      	MOVLB 0x00
106C  91CE      	BCF gbl_isJiggling,0, 1


#endif //_PICUSBJIGGLER_H_

/*
 
 \file pic_tick.h
 
 Timer helper routines

 Ian Harris 2008
 imharris [at] gmail.com

 Released under the "do whatever you like with this
 but it breaks, you get to keep both pieces" license.

*/
#ifndef __pic_tick_h
#define __pic_tick_h

#include "pic_utils.h"

/** Global tick counter */
static uns16 tick = 0;
106E  6A5E      	CLRF gbl_20_tick
1070  6A5F      	CLRF gbl_20_tick+D'1'


/**
	\brief Return current tick count
	
	Returns the current tick count. Thread and interrupt safe.
*/
uns16 tick_get_count();
/**
	\brief Calculate the tick time difference between two values
	
	Calculates how many ticks have elapsed between two tick values. Covers
	cases where the tick count wraps beyond its 16 bit value.
*/
uns16 tick_calc_diff(uns16 a, uns16 b);

/**
	\brief Call this routine to increment tick count
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine.
*/
void handle_tick();

/**
	\brief Call this routine to increment tick count - inline version
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine. Inline version so you
	don't use up one stack level
*/
inline void handle_tick_inline() {
   tick++;	// we assume that interrupts are off at this point
}   		

#endif   
#endif   
#include <system.h>
#include "PICUsbJiggler.h"

/* 
Requires http://embeddedadventures.blogspot.com/2009/01/picpack-20-released.html
*/

// Pic Pack includes
#include "pic_pack_lib/pic_utils.h"
#include "pic_pack_lib/pic_serial.h"
#include "pic_pack_lib/pic_usb.h"
#include "pic_pack_lib/pic_tick.h"
#include "pic_pack_lib/pic_timer.h"


// Configuration registers
// FOSC3:FOSC0 = HSPLL PLLDIV2:PLLDIV0 = 0, CPUDIV1:CPUDIV0 = 10 (/4)
#pragma DATA    _CONFIG1L, 00110000b // USBDIV on, CPU divide by 4, PLL direct
#pragma DATA    _CONFIG1H, 00001110b // disable oscillator switchover, disable failsafe clock monitor, HSPLL
#pragma DATA    _CONFIG2L, 00111110b // USB voltage regulator enabled, brownout set for 2.1 volts, hardware brownout only, PWRT enabled
#pragma DATA    _CONFIG2H, 00011110b // Watchdog timer disabled
#pragma DATA    _CONFIG3H, 00000000b // MCLR disabled, RB4:RB0 digital on POR
#pragma DATA    _CONFIG4L, 10000000b // Debug off, extended instructions disabled, LVP disabled, disable stack full/underflow reset
#pragma DATA    _CONFIG5L, 00001111b // Read code protection off
#pragma DATA    _CONFIG5H, 11000000b // Read EEPROM and boot block protection off
#pragma DATA    _CONFIG6L, 00001111b // Write code protection off
#pragma DATA    _CONFIG6H, 11100000b // Write EEPROM, boot block and config register protection off
#pragma DATA    _CONFIG7L, 00001111b // Table read protection off
#pragma DATA    _CONFIG7H, 01000000b // Boot block table read protection off

// 4 MHz crystal but the system clock is 24MHz due to CPUDIV configuration
#pragma CLOCK_FREQ 24000000

// See if we need to do a task
uns8 do_task = 0;
1072  6BCF      	CLRF gbl_do_task, 1


// Flag if we received something
bit receive = 0;
1074  93CE      	BCF gbl_receive,1, 1


// Dummy variable to show we can set it 
uns8 send_to = 0;
1076  6BD0      	CLRF gbl_send_to, 1


/******************************************************
  Function called once only to initialise variables and
  setup the PIC registers
*******************************************************/
void initialise() {

    // IO ports setup
    trisa = 0x00; // all ouptuts
1020  6A92      	CLRF gbl_trisa

    porta = 0x00; // set to off
1022  6A80      	CLRF gbl_porta

    trisb = 0x01; // RB0 input
1024  0E01      	MOVLW 0x01
1026  6E93      	MOVWF gbl_trisb

    portb = 0x00; // set to off
1028  6A81      	CLRF gbl_portb

    trisc = 0x00; // all ouptuts
102A  6A94      	CLRF gbl_trisc

    portc = 0x00; // set to off
102C  6A82      	CLRF gbl_portc


    // ADC setup
    adcon0 = 0x00; //  ADC off
102E  6AC2      	CLRF gbl_adcon0

    adcon1 = 0x0F; // All digital I/O
1030  0E0F      	MOVLW 0x0F
1032  6EC1      	MOVWF gbl_adcon1

    
    // USB setup
    ucon.USBEN = 1; // USB on
1034  866D      	BSF gbl_ucon,3


    intcon2.RBPU = 0; // Port B pull-ups enabled
1036  9EF1      	BCF gbl_intcon2,7


    intcon.PEIE = 1; // Enables all unmasked peripheral interrupts
1038  8CF2      	BSF gbl_intcon,6

    
    LED = 1; // Standby LED
103A  8281      	BSF gbl_portb,1


    intcon.GIE = 1;
103C  8EF2      	BSF gbl_intcon,7

}
103E  0012      	RETURN


// Interrupt routine - - - - - - - - - -
void timer_0_callback() {

	handle_tick();
101A  ECF6F007  	CALL handle_tic_00032

}	
101E  0012      	RETURN


//------------------------------------------------------------------------------
// Interrupt handler
//------------------------------------------------------------------------------
void interrupt(void) {

	usb_handle_isr();
12E6  CFEAF001  	MOVFF FSR0H,  Int1Context
12EA  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
12EE  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
12F2  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
12F6  ECFAF007  	CALL usb_handle_0001D

	timer_handle_0_isr();
12FA  A4F2      	BTFSS gbl_intcon,2
12FC  D011      	BRA	label93
12FE  0100      	MOVLB 0x00
1300  6BE0      	CLRF interrupt_6_start_value+D'1', 1
1302  51C0      	MOVF gbl_timer_0_start_value, W, 1
1304  24D6      	ADDWF gbl_tmr0l, W
1306  6FDF      	MOVWF interrupt_6_start_value, 1
1308  51C1      	MOVF gbl_timer_0_start_value+D'1', W, 1
130A  23E0      	ADDWFC interrupt_6_start_value+D'1', F, 1
130C  2BDF      	INCF interrupt_6_start_value, F, 1
130E  B4D8      	BTFSC STATUS,Z
1310  2BE0      	INCF interrupt_6_start_value+D'1', F, 1
1312  51E0      	MOVF interrupt_6_start_value+D'1', W, 1
1314  6ED7      	MOVWF gbl_tmr0h
1316  51DF      	MOVF interrupt_6_start_value, W, 1
1318  6ED6      	MOVWF gbl_tmr0l
131A  94F2      	BCF gbl_intcon,2
131C  EC0DF008  	CALL timer_0_ca_00038
1320            label93

}
1320  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
1324  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
1328  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
132C  C001FFEA  	MOVFF Int1Context,  FSR0H
1330  0011      	RETFIE 1


//-----------------------------------------------------------------------------
// MAIN PROGRAM
//------------------------------------------------------------------------------
void main() {

    initialise();
1040  EC10F008  	CALL initialise_00000

    
    while (1) {
1044            label89
1068  D7ED      	BRA	label89

        if (isJiggling) {
1044  0100      	MOVLB 0x00
1046  A1CE      	BTFSS gbl_isJiggling,0, 1
1048  D000      	BRA	label90
104A            label90

			// Emit random movement
			
        }
        // Check for button press
        if(BUTTON) {
104A  A081      	BTFSS gbl_portb,0
104C  D7FB      	BRA	label89

			delay_ms(100);
104E  0E64      	MOVLW 0x64
1050  6FDE      	MOVWF delay_ms_00000_arg_del, 1
1052  EC06F000  	CALL delay_ms_00000

			if(BUTTON) {
1056  A081      	BTFSS gbl_portb,0
1058  D7F5      	BRA	label89

				if (isJiggling) {
105A  A1CE      	BTFSS gbl_isJiggling,0, 1
105C  D003      	BRA	label91
1064            label91

					isJiggling = 1;
105E  81CE      	BSF gbl_isJiggling,0, 1

					LED = 1;
1060  8281      	BSF gbl_portb,1

				} else {
1062  D7F0      	BRA	label89

					isJiggling = 0;
1064  91CE      	BCF gbl_isJiggling,0, 1

					LED = 0;
1066  9281      	BCF gbl_portb,1

				}
			}
        }
    }
} 


/*
 
 pic_serial.c
 ------------
 
 Interrupt driven fifo serial routines

 Ian Harris 2008
 imharris [at] gmail.com

 Released under the "do whatever you like with this
 but if it breaks, you get to keep both pieces" license.

*/

#include "config.h"
#include "pic_utils.h"
#include "pic_serial.h"
#include <string.h>
#include <stdlib.h>

/** Transmit fifo  */
uns8 tx_buffer[SERIAL_TX_BUFFER_SIZE];
/** Transmit fifo start point */
uns8 tx_start=0;
1078  6BD1      	CLRF gbl_tx_start, 1

/** Transmit fifo end point */
uns8 tx_end=0;
107A  6BD2      	CLRF gbl_tx_end, 1


/** Receive fifo */
uns8 rx_buffer[SERIAL_RX_BUFFER_SIZE];
/** Receive fifo start point */
uns8 rx_start = 0;
107C  6BD3      	CLRF gbl_rx_start, 1

/** Receive fifo end point */
uns8 rx_end = 0;
107E  6BD4      	CLRF gbl_rx_end, 1


#ifdef SERIAL_DEBUG
uns8 rx_soft_overflow = 0;
uns8 rx_hard_overflow = 0;
uns8 rx_framing_error = 0;
#endif


// Returns ASCII Decimal and Hex values
inline uns8 bin2Hex(uns8 x)
{
   if (x < 10) {
   	 return '0' + x;
   } else {
     return 'A' -10 +  x;
   }
}


void serial_setup(bit req_brgh, uns8 req_spbrg)
{
#ifdef _PIC16F88
    set_bit(trisb, 5);
    set_bit(trisb, 2);
	#define TRIS_SET
#endif
#ifdef _PIC16F876A
    set_bit(trisc,6);
    set_bit(trisc,7);
	#define TRIS_SET
#endif
#ifdef _PIC18F2620
    set_bit(trisc,6);
    set_bit(trisc,7);
	#define TRIS_SET
#endif
#ifdef _PIC18F4520
    set_bit(trisc,6);
    set_bit(trisc,7);
	#define TRIS_SET
#endif
#ifdef _PIC18F4550
    set_bit(trisc,6);
    set_bit(trisc,7);
	#define TRIS_SET
#endif
#ifdef _PIC18F2550
    set_bit(trisc,6);
    set_bit(trisc,7);
	#define TRIS_SET
#endif

#ifndef TRIS_SET
	#warning "You must set tris bits for serial use yourself, I don't know your pic"
	#warning "Please send your tris bits in so they can be included in the library"
#endif

    txsta.BRGH = req_brgh;	// set baud rate generator (high/low speed)

    spbrg = req_spbrg;	// set serial port baud rate generator value

    clear_bit(txsta, SYNC);	// turn off syncronous reception
    set_bit(rcsta, SPEN);	// enable serial port

	// Configure tx
	
	kill_interrupts();
   
    clear_bit(txsta, TX9);	// Turn off 9 bit receiption
    clear_bit(txsta, TX9D);	// Clear 9th bit data

    set_bit(txsta, TXEN);	// enable sending of serial data 

	// configure rx
	
	clear_bit(rcsta, RX9);	// disable 9 bit receiption
	clear_bit(rcsta, FERR);	// clear any framing errors

	_asm	{	// clear rcreg buffer
		MOVF	_rcreg,W
		MOVF	_rcreg,W
		MOVF	_rcreg,W
	}

	clear_bit(rcsta, CREN);	
    set_bit(rcsta, CREN);	// pulse low to clear any errors	

    set_bit(pie1, RCIE);	// enable receive interrupt
    
}




void serial_putc(uns8 c)

{
uns8 tx_next;
bit  my_store_gie;
#ifdef SERIAL_IDE_DEBUG
return;
#endif

    if ((tx_end == tx_start) &&  // Nothing in the fifo
00AE  51D1      	MOVF gbl_tx_start, W, 1
00B0  63D2      	CPFSEQ gbl_tx_end, 1
00B2  D005      	BRA	label6
00BE            label6

        test_bit(pir1, TXIF)) {  // And txreg is empty
00B4  A89E      	BTFSS gbl_pir1,4
00B6  D003      	BRA	label6

		txreg = c;               // then no need for fifo, just send straight out 
00B8  51FE      	MOVF serial_put_00010_arg_c, W, 1
00BA  6EAD      	MOVWF gbl_txreg

    } else { // else put it in the fifo	 
        tx_next = tx_end + 1;	// get next buffer position
00BE  29D2      	INCF gbl_tx_end, W, 1
00C0  6FFF      	MOVWF serial_put_00010_1_tx_next, 1

		if (tx_next == SERIAL_TX_BUFFER_SIZE) {	// if we're at the end
00C2  0EFE      	MOVLW 0xFE
00C4  63FF      	CPFSEQ serial_put_00010_1_tx_next, 1
00C6  D001      	BRA	label7
00CA            label7

			tx_next = 0;	// wrap to the beginning
00C8  6BFF      	CLRF serial_put_00010_1_tx_next, 1

        }
        #ifdef SERIAL_DISCARD_ON_TX_FULL_DURING_INT
			if ((!intcon.GIE) && (tx_next == tx_start)) {
				return;
			}
		#endif	
        while (tx_next == tx_start) { // wait for clearing
00CA  51D1      	MOVF gbl_tx_start, W, 1
00CC  63FF      	CPFSEQ serial_put_00010_1_tx_next, 1
00CE  D006      	BRA	label8
00DA  D7F7      	BRA	label7
00DC            label8

									 // Note, if buffer is full
									 // this will wait for ever
									 // if interrupts are disabled!
			#ifndef SERIAL_DISCARD_ON_TX_FULL_DURING_INT
				if (!intcon.GIE) {	// we're in an interrupt
00D0  BEF2      	BTFSC gbl_intcon,7
00D2  D7FB      	BRA	label7

					serial_handle_tx_isr();	// so handle it ourselves
00D4  B89E      	BTFSC gbl_pir1,4
00D6  EC3AF000  	CALL serial_tx__0000D

				}
			#endif	
		}		
		my_store_gie = intcon.GIE;	// store interrupt state
00DC  0101      	MOVLB 0x01
00DE  91FE      	BCF serial_put_00010_1_my_store_gie,0, 1
00E0  BEF2      	BTFSC gbl_intcon,7
00E2  81FE      	BSF serial_put_00010_1_my_store_gie,0, 1
00E4            label9

		kill_interrupts();	// turn off global interrupts
00E4  9EF2      	BCF gbl_intcon,7
00E6  BEF2      	BTFSC gbl_intcon,7
00E8  D7FD      	BRA	label9

        
        tx_buffer[tx_end] = c; // put it in
00EA  EE01F000  	LFSR 0x00,  gbl_tx_buffer
00EE  50E9      	MOVF FSR0L, W
00F0  0100      	MOVLB 0x00
00F2  51D2      	MOVF gbl_tx_end, W, 1
00F4  26E9      	ADDWF FSR0L, F
00F6  51FE      	MOVF serial_put_00010_arg_c, W, 1
00F8  6EEF      	MOVWF INDF0

        tx_end = tx_next;  // move pointer along
00FA  51FF      	MOVF serial_put_00010_1_tx_next, W, 1
00FC  6FD2      	MOVWF gbl_tx_end, 1

		
		set_bit(pie1, TXIE); // turn on interrupt for transmitting
00FE  889D      	BSF gbl_pie1,4

		intcon.GIE = my_store_gie;	// restore interrupt state
0100  0101      	MOVLB 0x01
0102  B1FE      	BTFSC serial_put_00010_1_my_store_gie,0, 1
0104  8EF2      	BSF gbl_intcon,7
0106  A1FE      	BTFSS serial_put_00010_1_my_store_gie,0, 1
0108  9EF2      	BCF gbl_intcon,7

	} // -- else put it in the fifo
} 
00BC  0012      	RETURN
010A  0012      	RETURN




void serial_tx_isr()	

{
uns8 tx_next;

	if (tx_end == tx_start) { // anything in the fifo?
0074  0100      	MOVLB 0x00
0076  51D1      	MOVF gbl_tx_start, W, 1
0078  63D2      	CPFSEQ gbl_tx_end, 1
007A  D001      	BRA	label3
007E            label3

	   return; // nope
	}
	tx_next = tx_start + 1;	// get next position
007E  29D1      	INCF gbl_tx_start, W, 1
0080  0101      	MOVLB 0x01
0082  6FFF      	MOVWF serial_tx__0000D_1_tx_next, 1

	if (tx_next == SERIAL_TX_BUFFER_SIZE) {	// if we're at the end of the buffer
0084  0EFE      	MOVLW 0xFE
0086  63FF      	CPFSEQ serial_tx__0000D_1_tx_next, 1
0088  D001      	BRA	label4
008C            label4

		tx_next = 0;	// wrap to the beginning
008A  6BFF      	CLRF serial_tx__0000D_1_tx_next, 1

	}
	if (tx_end == tx_next) {	// if we've only got one character to send
008C  51FF      	MOVF serial_tx__0000D_1_tx_next, W, 1
008E  0100      	MOVLB 0x00
0090  63D2      	CPFSEQ gbl_tx_end, 1
0092  D001      	BRA	label5
0096            label5

		clear_bit(pie1, TXIE);	// then turn off interrupts
0094  989D      	BCF gbl_pie1,4

	}		
	txreg = tx_buffer[tx_start];	// transmit the character
0096  EE01F000  	LFSR 0x00,  gbl_tx_buffer
009A  50E9      	MOVF FSR0L, W
009C  51D1      	MOVF gbl_tx_start, W, 1
009E  26E9      	ADDWF FSR0L, F
00A0  50EF      	MOVF INDF0, W
00A2  6EAD      	MOVWF gbl_txreg

	tx_start = tx_next;	// move start position of fifo
00A4  0101      	MOVLB 0x01
00A6  51FF      	MOVF serial_tx__0000D_1_tx_next, W, 1
00A8  0100      	MOVLB 0x00
00AA  6FD1      	MOVWF gbl_tx_start, 1


}	/* \ \  */
007C  0012      	RETURN
00AC  0012      	RETURN



void serial_rx_isr() 
{
   uns8 rx_next;
	

	if (test_bit(rcsta, OERR)) {	// overrun error?
		clear_bit(rcsta, CREN);	// clear error
		_asm	{	
			MOVF	_rcreg,W	// clear any received characters
			MOVF	_rcreg,W
			MOVF	_rcreg,W
		}
		#ifdef SERIAL_DEBUG
		rx_hard_overflow++;	// increment error count if in debug mode
		#endif
		set_bit(rcsta, CREN);	// reset error indicator
	} else {
		if (test_bit(rcsta, FERR)) {	// framing error?
			#ifdef SERIAL_DEBUG
			rx_framing_error++;	// increment error count if in debug mode
			#endif
		}	
		rx_next = rx_end + 1;	// get next buffer position	
		if (rx_next == SERIAL_RX_BUFFER_SIZE) {	// if we're at the end
			rx_next = 0;	// then wrap to the beginning
		}
		if (rx_next != rx_start) { // if space in the fifo
			rx_buffer[rx_end] = rcreg; // put it in
			rx_end = rx_next;  // and move pointer along
		} else {	// else, there isn't space
			_asm MOVF	_rcreg,W // and just clear it, we've lost it
			#ifdef SERIAL_DEBUG
			rx_soft_overflow++;	// increment error count if in debug mode
			#endif
		}	// -- no space in the fifo
	}	// -- no overrun error
}	// -- serial_load_rx



uns8 serial_getc(void)
{
	uns8 rx_char, rx_next;
	
	while(rx_end == rx_start);	// wait until there is something received

	start_crit_sec();	// make sure nobody else can muck with the buffer
	
	rx_char = rx_buffer[rx_start];	// get character from the front of the buffer
	rx_start++;	// increment fifo start
	if (rx_start == SERIAL_RX_BUFFER_SIZE) {	// if we're at the end
		rx_start = 0;	// then wrap to the beginning
	}
    
    end_crit_sec();	// now they can muck with the buffer
    
    return (rx_char);	// return the result we first thought of

}	// -- getc    



void serial_print_str(char *str) {


uns8 count;

	for(count = 0 ; str[count] != 0; count++)
010C  6BFD      	CLRF serial_pri_00012_1_count, 1
010E            label10
010E  51FC      	MOVF serial_pri_00012_arg_str+D'1', W, 1
0110  6EEA      	MOVWF FSR0H
0112  51FB      	MOVF serial_pri_00012_arg_str, W, 1
0114  25FD      	ADDWF serial_pri_00012_1_count, W, 1
0116  6EE9      	MOVWF FSR0L
0118  52EF      	MOVF INDF0, F
011A  B4D8      	BTFSC STATUS,Z
0130  0100      	MOVLB 0x00
0132  2BFD      	INCF serial_pri_00012_1_count, F, 1
0134  D7EC      	BRA	label10

    {
        serial_putc(str[count]);
011E  51FC      	MOVF serial_pri_00012_arg_str+D'1', W, 1
0120  6EEA      	MOVWF FSR0H
0122  51FB      	MOVF serial_pri_00012_arg_str, W, 1
0124  25FD      	ADDWF serial_pri_00012_1_count, W, 1
0126  6EE9      	MOVWF FSR0L
0128  50EF      	MOVF INDF0, W
012A  6FFE      	MOVWF serial_put_00010_arg_c, 1
012C  EC57F000  	CALL serial_put_00010

    }
}    
011C  0012      	RETURN




void serial_print_str(rom char *str) {

uns8 count;

	for(count = 0 ; str[count] != 0; count++)
    {
        serial_putc(str[count]);
    }
}    



void serial_print_int(uns16 i) {


char buffer[6];	// up to 5 characters plus \0
uns8 count = 5;
02C0  0E05      	MOVLW 0x05
02C2  6FFD      	MOVWF serial_pri_00014_1_count, 1

	buffer[5] = '\0';
02C4  0102      	MOVLB 0x02
02C6  6B05      	CLRF serial_pri_00014_1_buffer+D'5', 1

	do {
02C8            label23

		count--;
02C8  0100      	MOVLB 0x00
02CA  07FD      	DECF serial_pri_00014_1_count, F, 1

		buffer[count] = '0' + i % 10;
02CC  51FB      	MOVF serial_pri_00014_arg_i, W, 1
02CE  6FFE      	MOVWF __rem_16_1_00006_arg_a, 1
02D0  51FC      	MOVF serial_pri_00014_arg_i+D'1', W, 1
02D2  6FFF      	MOVWF __rem_16_1_00006_arg_a+D'1', 1
02D4  0E0A      	MOVLW 0x0A
02D6  0101      	MOVLB 0x01
02D8  6FFE      	MOVWF __rem_16_1_00006_arg_b, 1
02DA  6BFF      	CLRF __rem_16_1_00006_arg_b+D'1', 1
02DC  EC9BF000  	CALL __rem_16_1_00006
02E0  510D      	MOVF CompTempVarRet350, W, 1
02E2  6F06      	MOVWF CompTempVar817, 1
02E4  510E      	MOVF CompTempVarRet350+D'1', W, 1
02E6  6F07      	MOVWF CompTempVar818, 1
02E8  5106      	MOVF CompTempVar817, W, 1
02EA  0F30      	ADDLW 0x30
02EC  6F08      	MOVWF CompTempVar819, 1
02EE  EE02F000  	LFSR 0x00,  serial_pri_00014_1_buffer
02F2  50E9      	MOVF FSR0L, W
02F4  0100      	MOVLB 0x00
02F6  51FD      	MOVF serial_pri_00014_1_count, W, 1
02F8  26E9      	ADDWF FSR0L, F
02FA  0102      	MOVLB 0x02
02FC  5108      	MOVF CompTempVar819, W, 1
02FE  6EEF      	MOVWF INDF0

		i = i / 10;
0300  0100      	MOVLB 0x00
0302  51FB      	MOVF serial_pri_00014_arg_i, W, 1
0304  6FFE      	MOVWF __div_16_1_00005_arg_a, 1
0306  51FC      	MOVF serial_pri_00014_arg_i+D'1', W, 1
0308  6FFF      	MOVWF __div_16_1_00005_arg_a+D'1', 1
030A  0E0A      	MOVLW 0x0A
030C  0101      	MOVLB 0x01
030E  6FFE      	MOVWF __div_16_1_00005_arg_b, 1
0310  6BFF      	CLRF __div_16_1_00005_arg_b+D'1', 1
0312  ECC4F000  	CALL __div_16_1_00005
0316  510A      	MOVF CompTempVarRet347, W, 1
0318  0100      	MOVLB 0x00
031A  6FFB      	MOVWF serial_pri_00014_arg_i, 1
031C  0102      	MOVLB 0x02
031E  510B      	MOVF CompTempVarRet347+D'1', W, 1
0320  0100      	MOVLB 0x00
0322  6FFC      	MOVWF serial_pri_00014_arg_i+D'1', 1

	} while (i > 0);	
0324  0E00      	MOVLW 0x00
0326  65FB      	CPFSGT serial_pri_00014_arg_i, 1
0328  67FC      	TSTFSZ serial_pri_00014_arg_i+D'1', 1
032A  D7CE      	BRA	label23
032C            label24

	while (buffer[count]) {
032C  EE02F000  	LFSR 0x00,  serial_pri_00014_1_buffer
0330  50E9      	MOVF FSR0L, W
0332  51FD      	MOVF serial_pri_00014_1_count, W, 1
0334  26E9      	ADDWF FSR0L, F
0336  52EF      	MOVF INDF0, F
0338  B4D8      	BTFSC STATUS,Z
0352  D7EC      	BRA	label24

        serial_putc(buffer[count]);
033C  EE02F000  	LFSR 0x00,  serial_pri_00014_1_buffer
0340  50E9      	MOVF FSR0L, W
0342  51FD      	MOVF serial_pri_00014_1_count, W, 1
0344  26E9      	ADDWF FSR0L, F
0346  50EF      	MOVF INDF0, W
0348  6FFE      	MOVWF serial_put_00010_arg_c, 1
034A  EC57F000  	CALL serial_put_00010

        count++;
034E  0100      	MOVLB 0x00
0350  2BFD      	INCF serial_pri_00014_1_count, F, 1

    }  
	//serial_print_str(&buffer[count]);	//	print it out 
//	for(count = 0 ; str[count] != 0; count++)
 //   {
 //   }

}	
033A  0012      	RETURN


void serial_print_int_hex(uns8 i) {


	serial_putc(bin2Hex(i >> 4));
066C  39F1      	SWAPF serial_pri_00015_arg_i, W, 1
066E  0B0F      	ANDLW 0x0F
0670  6FF2      	MOVWF serial_pri_00015_5_x, 1
0672  0E0A      	MOVLW 0x0A
0674  61F2      	CPFSLT serial_pri_00015_5_x, 1
0676  D004      	BRA	label38
0678  51F2      	MOVF serial_pri_00015_5_x, W, 1
067A  0F30      	ADDLW 0x30
067C  6FFE      	MOVWF serial_put_00010_arg_c, 1
067E  D003      	BRA	label39
0680            label38
0680  51F2      	MOVF serial_pri_00015_5_x, W, 1
0682  0F37      	ADDLW 0x37
0684  6FFE      	MOVWF serial_put_00010_arg_c, 1
0686  EC57F000  	CALL serial_put_00010

	serial_putc(bin2Hex((i & 0x0f)));
068A  0E0F      	MOVLW 0x0F
068C  0100      	MOVLB 0x00
068E  15F1      	ANDWF serial_pri_00015_arg_i, W, 1
0690  6FF2      	MOVWF serial_pri_00015_15_x, 1
0692  0E0A      	MOVLW 0x0A
0694  61F2      	CPFSLT serial_pri_00015_15_x, 1
0696  D004      	BRA	label40
0698  51F2      	MOVF serial_pri_00015_15_x, W, 1
069A  0F30      	ADDLW 0x30
069C  6FFE      	MOVWF serial_put_00010_arg_c, 1
069E  D003      	BRA	label41
06A0            label40
06A0  51F2      	MOVF serial_pri_00015_15_x, W, 1
06A2  0F37      	ADDLW 0x37
06A4  6FFE      	MOVWF serial_put_00010_arg_c, 1
06A6  EC57F000  	CALL serial_put_00010

	
}	
06AA  0012      	RETURN


void serial_print_int_hex_16bit(uns16 i) {
	serial_print_int_hex(i >> 8);
	serial_print_int_hex(i & 0xff);
}	


void serial_print_spc() {

		serial_putc(' ');
02B4  0E20      	MOVLW 0x20
02B6  0100      	MOVLB 0x00
02B8  6FFE      	MOVWF serial_put_00010_arg_c, 1
02BA  EC57F000  	CALL serial_put_00010

}
02BE  0012      	RETURN



void serial_print_nl() {
		serial_putc('\n');
}		



uns8 serial_rx_avail() { return rx_start != rx_end; }
uns8 serial_tx_empty() { return tx_start == tx_end; }


/*
 
 \file pic_tick.h
 
 Timer helper routines

 Ian Harris 2008
 imharris [at] gmail.com

 Released under the "do whatever you like with this
 but it breaks, you get to keep both pieces" license.

*/
#ifndef __pic_tick_h
#define __pic_tick_h

#include "pic_utils.h"

/** Global tick counter */
static uns16 tick = 0;
1080  6BBE      	CLRF gbl_22_tick, 1
1082  6BBF      	CLRF gbl_22_tick+D'1', 1


/**
	\brief Return current tick count
	
	Returns the current tick count. Thread and interrupt safe.
*/
uns16 tick_get_count();
/**
	\brief Calculate the tick time difference between two values
	
	Calculates how many ticks have elapsed between two tick values. Covers
	cases where the tick count wraps beyond its 16 bit value.
*/
uns16 tick_calc_diff(uns16 a, uns16 b);

/**
	\brief Call this routine to increment tick count
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine.
*/
void handle_tick();

/**
	\brief Call this routine to increment tick count - inline version
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine. Inline version so you
	don't use up one stack level
*/
inline void handle_tick_inline() {
   tick++;	// we assume that interrupts are off at this point
}   		

#endif   
#endif   
/*
 
 pic_tick.c
 ----------
 
 Timer helper routines

 Ian Harris 2008
 imharris [at] gmail.com

 Released under the "do whatever you like with this
 but if you use it send me an email" license. Oh, and
 if it breaks, you get to keep both pieces.

*/
#include "pic_tick.h"

uns16 tick_get_count() {

bit my_store_gie;
uns16 result;

	my_store_gie = intcon.GIE;	// save global interrupt       
	kill_interrupts();	// turn them off

	result = tick;	// Grab a copy
			
	intcon.GIE = my_store_gie;	// interrupts back to normal
	return result;	// return the result
}	
	
uns16 tick_calc_diff(uns16 a, uns16 b) {
	if (a <= b) {	// simple case
		return b-a;
	} else {
		return 65535 - a + b + 1;	// more complex case
	}
}

void handle_tick() {

   tick++;	// we assume that interrupts are off at this point
0FEC  0100      	MOVLB 0x00
0FEE  4BBE      	INFSNZ gbl_22_tick, F, 1
0FF0  2BBF      	INCF gbl_22_tick+D'1', F, 1

}   		
0FF2  0012      	RETURN

		
		
		
/*! \file pic_timer.h
    \brief Pic timer routines

	It's the way cool interrupt driven timer library

	Ian Harris 2007
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if you use it send me an email" license. Oh, and
	if it breaks, you get to keep both pieces.
    
   
*/

#include "pic_timer.h"

#ifdef _PIC18
	uns16 timer_0_start_value = 0;
1084  6BC0      	CLRF gbl_timer_0_start_value, 1
1086  6BC1      	CLRF gbl_timer_0_start_value+D'1', 1

#endif
#ifdef _PIC16
	uns8 timer_0_start_value = 0;
#endif;	

#ifdef _PIC18
void timer_setup_0(bit mode_8_bit, uns8 prescaler_setting, uns16 timer_start_value) {

	clear_bit(t0con, TMR0ON);	// turn off timer if it was on so we can get it set up
	if (mode_8_bit) {
		set_bit(t0con, T08BIT); 	// enable 8 bit mode 
	} else {
		clear_bit(t0con, T08BIT);
	}	
	clear_bit(t0con, T0CS);	// Internal instruction cycle clock
	// T0SE -- don't care
	if (prescaler_setting == TIMER_PRESCALER_OFF) {
		set_bit(t0con, PSA);
	} else {
		clear_bit(t0con, PSA);
		t0con &= 0b11111000;
		t0con |= prescaler_setting;
	}
	timer_0_start_value = timer_start_value;
	set_bit(intcon, TMR0IE); 	// Turn on timer 0 interrupts
}		
#endif

#ifdef _PIC16

void timer_setup_0(bit mode_8_bit, uns8 prescaler_setting, uns16 timer_start_value) {

	clear_bit( option_reg, T0CS ); // configure timer0 as a timer
	// T0SE -- don't care
	if (prescaler_setting == TIMER_PRESCALER_OFF) {
		set_bit(option_reg, PSA);	// Asign it to watchdog timer (ie, not us)
	} else {
		clear_bit(option_reg, PSA);	// prescaler assigned to us
		option_reg &= 0b11111000;
		option_reg |= prescaler_setting;
	}
	timer_0_start_value = timer_start_value;
}		
#endif

#ifdef _PIC18
void timer_start_0() {
	tmr0h = timer_0_start_value >> 8;
	tmr0l = timer_0_start_value & 0xff;
	set_bit(t0con, TMR0ON);
}
#endif

#ifdef _PIC16
void timer_start_0() {
	tmr0 = timer_0_start_value;
	// There's no "on" for timer 0
	set_bit(intcon, TMR0IE); 	// Turn on timer 0 interrupts
}
#endif

#ifdef _PIC18
void timer_stop_0() {
	clear_bit(t0con, TMR0ON);
}
#endif
#ifdef _PIC16
void timer_stop_0() {
	clear_bit(intcon, TMR0IE); 	// turn off timer 0 interrupts
}
#endif


/*! \file pic_usb.c
    \brief Pic USB routines

	It's the way cool interrupt driven usb library

	Ian Harris 2008
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if it breaks, you get to keep both pieces" license
    
   
*/

#include "pic_usb.h"
#include "memory.h"
#include "config.h"
#include "pic_usb_buffer_mgt.h"

#ifdef USB_DEBUG
	#include "pic_serial.h"
#endif


// globally accessable variables

usb_state_type usb_state = st_POWERED;
1088  6BD5      	CLRF gbl_usb_state, 1


setup_data_packet usb_sdp;

uns8 usb_address;
control_mode_type control_mode;
uns16 delivery_bytes_to_send,
	  delivery_bytes_max_send,
		delivery_bytes_sent;
uns8 *delivery_ptr;	
uns8 delivery_buffer_size;
uns8 *delivery_buffer;
buffer_descriptor *delivery_bd;

usb_status_type usb_status;

void usb_configure_endpoints() {

	
#ifdef USB_DEBUG
	serial_print_str("Config eps ");
0614  0E20      	MOVLW 0x20
0616  0102      	MOVLB 0x02
0618  6F06      	MOVWF CompTempVar936+D'6', 1
061A  6F0A      	MOVWF CompTempVar936+D'10', 1
061C  0E43      	MOVLW 0x43
061E  6F00      	MOVWF CompTempVar936, 1
0620  0E65      	MOVLW 0x65
0622  6F07      	MOVWF CompTempVar936+D'7', 1
0624  0E66      	MOVLW 0x66
0626  6F03      	MOVWF CompTempVar936+D'3', 1
0628  0E67      	MOVLW 0x67
062A  6F05      	MOVWF CompTempVar936+D'5', 1
062C  0E69      	MOVLW 0x69
062E  6F04      	MOVWF CompTempVar936+D'4', 1
0630  0E6E      	MOVLW 0x6E
0632  6F02      	MOVWF CompTempVar936+D'2', 1
0634  0E6F      	MOVLW 0x6F
0636  6F01      	MOVWF CompTempVar936+D'1', 1
0638  0E70      	MOVLW 0x70
063A  6F08      	MOVWF CompTempVar936+D'8', 1
063C  0E73      	MOVLW 0x73
063E  6F09      	MOVWF CompTempVar936+D'9', 1
0640  6B0B      	CLRF CompTempVar936+D'11', 1
0642  0E02      	MOVLW HIGH(CompTempVar936+D'0')
0644  0100      	MOVLB 0x00
0646  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0648  0E00      	MOVLW LOW(CompTempVar936+D'0')
064A  6FFB      	MOVWF serial_pri_00012_arg_str, 1
064C  EC86F000  	CALL serial_pri_00012

#endif	
#ifdef USB_EP1
	set_bit  (uep1, EPHSHK);	// EP handshaking on
0650  8871      	BSF gbl_uep1,4

	#ifdef USB_EP1_OUT_SIZE
		set_bit(uep1, EPOUTEN);	// EP OUT enabled
	#else
		clear_bit(uep1, EPOUTEN);	// EP OUT disabled
0652  9471      	BCF gbl_uep1,2

	#endif
	#ifdef USB_EP1_IN_SIZE
		set_bit(uep1, EPINEN);	// EP IN enabled
0654  8271      	BSF gbl_uep1,1

	#else
		clear_bit(uep1, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep1, EPCONDIS);	// control transfers off
0656  8671      	BSF gbl_uep1,3

	
	// for IN
	#ifdef USB_EP1_IN_SIZE
		set_bit(bd1in.stat, DTS);	// turn on data togle sync TOGGLE
0658  0104      	MOVLB 0x04
065A  8D0C      	BSF gbl_bd1in,6, 1

		clear_bit(bd1in.stat, KEN);	// clear the keep bit
065C  9B0C      	BCF gbl_bd1in,5, 1

		clear_bit(bd1in.stat, INCDIS);	// clear the increment disable
065E  990C      	BCF gbl_bd1in,4, 1

		clear_bit(bd1in.stat, DTSEN);
0660  970C      	BCF gbl_bd1in,3, 1

		clear_bit(bd1in.stat, BSTALL);	// clear stall bit
0662  950C      	BCF gbl_bd1in,2, 1

		clear_bit(bd1in.stat, BC9);
0664  930C      	BCF gbl_bd1in,1, 1

		clear_bit(bd1in.stat, BC8);
0666  910C      	BCF gbl_bd1in,0, 1

	
		clear_bit(bd1in.stat, UOWN);	// uC owns the buffer
0668  9F0C      	BCF gbl_bd1in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP1_OUT_SIZE
		bd1out.count = USB_EP1_OUT_SIZE;
		bd1out.addr  = USB_EP1_OUT_ADDR;
		
		clear_bit(bd1out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd1out.stat, KEN);	// clear the keep bit
		clear_bit(bd1out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd1out.stat, DTSEN);
		clear_bit(bd1out.stat, BSTALL);	// clear stall bit
		clear_bit(bd1out.stat, BC9);
		clear_bit(bd1out.stat, BC8);
		set_bit  (bd1out.stat, UOWN);	// SIE owns the buffer
		
	#endif
	

#endif

#ifdef USB_EP2
	set_bit  (uep2, EPHSHK);	// EP handshaking on
	#ifdef USB_EP2_OUT_SIZE
		set_bit(uep2, EPOUTEN);	// EP OUT enabled
	#else
		clear_bit(uep2, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP2_IN_SIZE
		set_bit(uep2, EPINEN);	// EP IN enabled
	#else
		clear_bit(uep2, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep2, EPCONDIS);	// control transfers off

	// for IN
	#ifdef USB_EP2_IN_SIZE
	
		set_bit(bd2in.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd2in.stat, KEN);	// clear the keep bit
		clear_bit(bd2in.stat, INCDIS);	// clear the increment disable
		clear_bit(bd2in.stat, DTSEN);
		clear_bit(bd2in.stat, BSTALL);	// clear stall bit
		clear_bit(bd2in.stat, BC9);
		clear_bit(bd2in.stat, BC8);
	
		clear_bit(bd2in.stat, UOWN);	// uC owns the buffer
	#endif
	// for OUT
	#ifdef USB_EP2_OUT_SIZE
		bd2out.count = USB_EP2_OUT_SIZE;
		bd2out.addr  = USB_EP2_OUT_ADDR;

		clear_bit(bd2out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd2out.stat, KEN);	// clear the keep bit
		clear_bit(bd2out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd2out.stat, DTSEN);
		clear_bit(bd2out.stat, BSTALL);	// clear stall bit
		clear_bit(bd2out.stat, BC9);
		clear_bit(bd2out.stat, BC8);
		set_bit  (bd2out.stat, UOWN);	// SIE owns the buffer
	#endif
#endif

#ifdef USB_EP3
	set_bit  (uep3, EPHSHK);	// EP handshaking on
	#ifdef USB_EP3_OUT_SIZE
		set_bit(uep3, EPOUTEN);	// EP OUT enabled
	#else
		clear_bit(uep3, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP3_IN_SIZE
		set_bit(uep3, EPINEN);	// EP IN enabled
	#else
		clear_bit(uep3, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep3, EPCONDIS);	// control transfers off
	// for IN
	#ifdef USB_EP3_IN_SIZE
		set_bit(bd3in.stat, DTS);	// ready for toggle
		clear_bit(bd3in.stat, KEN);	// clear the keep bit
		clear_bit(bd3in.stat, INCDIS);	// clear the increment disable
		clear_bit(bd3in.stat, DTSEN);
		clear_bit(bd3in.stat, BSTALL);	// clear stall bit
		clear_bit(bd3in.stat, BC9);
		clear_bit(bd3in.stat, BC8);
	
		clear_bit(bd3in.stat, UOWN);	// uC owns the buffer
	#endif
	// for OUT
	#ifdef USB_EP3_OUT_SIZE
		bd3out.count = USB_EP3_OUT_SIZE;
		bd3out.addr  = USB_EP3_OUT_ADDR;

		clear_bit(bd3out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd3out.stat, KEN);	// clear the keep bit
		clear_bit(bd3out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd3out.stat, DTSEN);
		clear_bit(bd3out.stat, BSTALL);	// clear stall bit
		clear_bit(bd3out.stat, BC9);
		clear_bit(bd3out.stat, BC8);
		set_bit  (bd3out.stat, UOWN);	// SIE owns the buffer
	#endif

#endif
	
}
066A  0012      	RETURN


void usb_stall_ep0() {

	set_bit(bd0in.stat, BSTALL);	// stall
0354  0104      	MOVLB 0x04
0356  8504      	BSF gbl_bd0in,2, 1

	set_bit(bd0in.stat, UOWN);	// SIE owns the buffer
0358  8F04      	BSF gbl_bd0in,7, 1

	set_bit(bd0out.stat, BSTALL);	// stall
035A  8500      	BSF gbl_bd0out,2, 1

	set_bit(bd0out.stat, UOWN);	// SIE owns the buffer
035C  8F00      	BSF gbl_bd0out,7, 1

	//set_bit(uep0,EPSTALL);
}
035E  0012      	RETURN


void usb_send_data(uns8 ep, uns8 *data, uns8 send_count, bit first) {
uns8 count;
buffer_descriptor *bd;
uns8 *buffer;

	// this is going to be an IN transaction
	
	// need to grab buffer descriptor
	buffer = ep_in_buffer_location[ep];
	
	bd = ep_in_bd_location[ep];
	
	if (test_bit(bd->stat, UOWN)) {
	#ifdef USB_DEBUG
		serial_print_str(" !don't own it! ");
	#endif
		return;
	}
	
	count = 0;	
	while ((count < send_count)) {
	    buffer[count] = data[count];
	    count++;
	}       	
	

	bd->count = count;
	bd->addr = (uns16)buffer;
	if (first) {
		clear_bit(bd->stat, DTS);	// So when it flips, will end up set 
	}

	toggle_bit(bd->stat, DTS);	// flip the DTS bit
	clear_bit(bd->stat, KEN);	// clear the keep bit
	clear_bit(bd->stat, INCDIS);	// clear the increment disable
	set_bit  (bd->stat, DTSEN);
	clear_bit(bd->stat, BSTALL);	// clear stall bit
	clear_bit(bd->stat, BC9);
	clear_bit(bd->stat, BC8);

	set_bit  (bd->stat, UOWN);	// SIE owns the buffer
}	



void usb_send_data_chunk() {

	
uns8 count;

	if (test_bit(bd0in.stat, UOWN)) {
01DA  0104      	MOVLB 0x04
01DC  AF04      	BTFSS gbl_bd0in,7, 1
01DE  D023      	BRA	label15
0226            label15

	#ifdef USB_DEBUG
		serial_print_str(" !don't own it! ");
01E0  0E20      	MOVLW 0x20
01E2  0102      	MOVLB 0x02
01E4  6F00      	MOVWF CompTempVar930, 1
01E6  6F07      	MOVWF CompTempVar930+D'7', 1
01E8  6F0B      	MOVWF CompTempVar930+D'11', 1
01EA  6F0F      	MOVWF CompTempVar930+D'15', 1
01EC  0E21      	MOVLW 0x21
01EE  6F01      	MOVWF CompTempVar930+D'1', 1
01F0  6F0E      	MOVWF CompTempVar930+D'14', 1
01F2  0E27      	MOVLW 0x27
01F4  6F05      	MOVWF CompTempVar930+D'5', 1
01F6  0E64      	MOVLW 0x64
01F8  6F02      	MOVWF CompTempVar930+D'2', 1
01FA  0E69      	MOVLW 0x69
01FC  6F0C      	MOVWF CompTempVar930+D'12', 1
01FE  0E6E      	MOVLW 0x6E
0200  6F04      	MOVWF CompTempVar930+D'4', 1
0202  6F0A      	MOVWF CompTempVar930+D'10', 1
0204  0E6F      	MOVLW 0x6F
0206  6F03      	MOVWF CompTempVar930+D'3', 1
0208  6F08      	MOVWF CompTempVar930+D'8', 1
020A  0E74      	MOVLW 0x74
020C  6F06      	MOVWF CompTempVar930+D'6', 1
020E  6F0D      	MOVWF CompTempVar930+D'13', 1
0210  0E77      	MOVLW 0x77
0212  6F09      	MOVWF CompTempVar930+D'9', 1
0214  6B10      	CLRF CompTempVar930+D'16', 1
0216  0E02      	MOVLW HIGH(CompTempVar930+D'0')
0218  0100      	MOVLB 0x00
021A  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
021C  0E00      	MOVLW LOW(CompTempVar930+D'0')
021E  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0220  EC86F000  	CALL serial_pri_00012

	#endif
		return;
	}

	count = 0;
0226  0100      	MOVLB 0x00
0228  6BF2      	CLRF usb_send_d_0003D_1_count, 1

	while ((count < delivery_buffer_size) &&
022A            label16
022A  51D8      	MOVF gbl_delivery_buffer_size, W, 1
022C  61F2      	CPFSLT usb_send_d_0003D_1_count, 1
022E  D01F      	BRA	label19
026C  D7DE      	BRA	label16
026E            label19

	       (delivery_bytes_sent < delivery_bytes_to_send) && 
0230  51C3      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
0232  5DC7      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0234  E102      	BNZ	label17
0236  51C2      	MOVF gbl_delivery_bytes_to_send, W, 1
0238  5DC6      	SUBWF gbl_delivery_bytes_sent, W, 1
023A            label17
023A  E219      	BC	label19

	       (delivery_bytes_sent < delivery_bytes_max_send)) {
023C  51C5      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
023E  5DC7      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0240  E102      	BNZ	label18
0242  51C4      	MOVF gbl_delivery_bytes_max_send, W, 1
0244  5DC6      	SUBWF gbl_delivery_bytes_sent, W, 1
0246            label18
0246  E213      	BC	label19

	    delivery_buffer[count] = *delivery_ptr;
0248  51C9      	MOVF gbl_delivery_ptr+D'1', W, 1
024A  6EEA      	MOVWF FSR0H
024C  51C8      	MOVF gbl_delivery_ptr, W, 1
024E  6EE9      	MOVWF FSR0L
0250  50EF      	MOVF INDF0, W
0252  6FF3      	MOVWF CompTempVar933, 1
0254  51CB      	MOVF gbl_delivery_buffer+D'1', W, 1
0256  6EEA      	MOVWF FSR0H
0258  51CA      	MOVF gbl_delivery_buffer, W, 1
025A  25F2      	ADDWF usb_send_d_0003D_1_count, W, 1
025C  6EE9      	MOVWF FSR0L
025E  51F3      	MOVF CompTempVar933, W, 1
0260  6EEF      	MOVWF INDF0

	    delivery_ptr++;
0262  4BC8      	INFSNZ gbl_delivery_ptr, F, 1
0264  2BC9      	INCF gbl_delivery_ptr+D'1', F, 1

	    delivery_bytes_sent++;
0266  4BC6      	INFSNZ gbl_delivery_bytes_sent, F, 1
0268  2BC7      	INCF gbl_delivery_bytes_sent+D'1', F, 1

	    count++;
026A  2BF2      	INCF usb_send_d_0003D_1_count, F, 1

	}       	
	
	if ((count < delivery_buffer_size) && 
026E  51D8      	MOVF gbl_delivery_buffer_size, W, 1
0270  61F2      	CPFSLT usb_send_d_0003D_1_count, 1
0272  D00F      	BRA	label22
0292            label22

	    ((delivery_bytes_sent == delivery_bytes_max_send) ||
0274  51C4      	MOVF gbl_delivery_bytes_max_send, W, 1
0276  63C6      	CPFSEQ gbl_delivery_bytes_sent, 1
0278  D004      	BRA	label20
027A  51C5      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
027C  63C7      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
027E  D001      	BRA	label20
0280  D006      	BRA	label21
0282            label20

	    (delivery_bytes_sent == delivery_bytes_to_send)))  {
0282  51C2      	MOVF gbl_delivery_bytes_to_send, W, 1
0284  63C6      	CPFSEQ gbl_delivery_bytes_sent, 1
0286  D005      	BRA	label22
0288  51C3      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
028A  63C7      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
028C  D002      	BRA	label22
028E            label21

		control_mode = cm_CTRL_READ_AWAITING_STATUS;	// we're done with data stage
028E  0E05      	MOVLW 0x05
0290  6FD7      	MOVWF gbl_control_mode, 1

	}	

	
	bd0in.count = count;
0292  51F2      	MOVF usb_send_d_0003D_1_count, W, 1
0294  0104      	MOVLB 0x04
0296  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in.addr = (uns16)&buffer_0_in;
0298  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
029A  6F07      	MOVWF gbl_bd0in+D'3', 1
029C  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
029E  6F06      	MOVWF gbl_bd0in+D'2', 1

	toggle_bit(bd0in.stat, DTS);
02A0  0E40      	MOVLW 0x40
02A2  1B04      	XORWF gbl_bd0in, F, 1

	clear_bit(bd0in.stat, KEN);	// clear the keep bit
02A4  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in.stat, INCDIS);	// clear the increment disable
02A6  9904      	BCF gbl_bd0in,4, 1

	set_bit  (bd0in.stat, DTSEN);
02A8  8704      	BSF gbl_bd0in,3, 1

	clear_bit(bd0in.stat, BSTALL);	// clear stall bit
02AA  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in.stat, BC9);
02AC  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in.stat, BC8);
02AE  9104      	BCF gbl_bd0in,0, 1


	set_bit  (bd0in.stat, UOWN);	// SIE owns the buffer
02B0  8F04      	BSF gbl_bd0in,7, 1

	/*
	delivery_bd->count = count;
	delivery_bd->addr = (uns16)delivery_buffer;
	toggle_bit(delivery_bd->stat, DTS);
	clear_bit(delivery_bd->stat, KEN);	// clear the keep bit
	clear_bit(delivery_bd->stat, INCDIS);	// clear the increment disable
	set_bit  (delivery_bd->stat, DTSEN);
	clear_bit(delivery_bd->stat, BSTALL);	// clear stall bit
	clear_bit(delivery_bd->stat, BC9);
	clear_bit(delivery_bd->stat, BC8);

	set_bit  (delivery_bd->stat, UOWN);	// SIE owns the buffer
	*/
}
0224  0012      	RETURN
02B2  0012      	RETURN



void usb_send_empty_data_pkt() {

	delivery_buffer_size = USB_EP0_IN_SIZE;
0398  0E08      	MOVLW 0x08
039A  0100      	MOVLB 0x00
039C  6FD8      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bd = &bd0in;	
039E  0E04      	MOVLW HIGH(gbl_bd0in+D'0')
03A0  6FCD      	MOVWF gbl_delivery_bd+D'1', 1
03A2  0E04      	MOVLW LOW(gbl_bd0in+D'0')
03A4  6FCC      	MOVWF gbl_delivery_bd, 1

	delivery_buffer = &buffer_0_in;	
03A6  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
03A8  6FCB      	MOVWF gbl_delivery_buffer+D'1', 1
03AA  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
03AC  6FCA      	MOVWF gbl_delivery_buffer, 1

	delivery_bytes_sent = 0;
03AE  6BC6      	CLRF gbl_delivery_bytes_sent, 1
03B0  6BC7      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 0;
03B2  6BC2      	CLRF gbl_delivery_bytes_to_send, 1
03B4  6BC3      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
03B6  6BC4      	CLRF gbl_delivery_bytes_max_send, 1
03B8  6BC5      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	delivery_ptr = (uns8 *) 0;
03BA  6BC8      	CLRF gbl_delivery_ptr, 1
03BC  6BC9      	CLRF gbl_delivery_ptr+D'1', 1

	clear_bit(bd0in.stat, DTS);	// ready to get toggled 
03BE  0104      	MOVLB 0x04
03C0  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
03C2  ECEDF000  	CALL usb_send_d_0003D

}
03C6  0012      	RETURN


uns8 buffer_byte;

void usb_send_one_byte(uns8 data) {

	delivery_buffer_size = USB_EP0_IN_SIZE;
0360  0E08      	MOVLW 0x08
0362  6FD8      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bytes_sent = 0;
0364  6BC6      	CLRF gbl_delivery_bytes_sent, 1
0366  6BC7      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 1;
0368  0E01      	MOVLW 0x01
036A  6FC2      	MOVWF gbl_delivery_bytes_to_send, 1
036C  6BC3      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
036E  6BC4      	CLRF gbl_delivery_bytes_max_send, 1
0370  6BC5      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	buffer_byte = data;
0372  51F1      	MOVF usb_send_o_0003F_arg_data, W, 1
0374  6FDA      	MOVWF gbl_buffer_byte, 1

	delivery_ptr = (uns8 *) &buffer_byte;
0376  0E00      	MOVLW HIGH(gbl_buffer_byte+D'0')
0378  6FC9      	MOVWF gbl_delivery_ptr+D'1', 1
037A  0EDA      	MOVLW LOW(gbl_buffer_byte+D'0')
037C  6FC8      	MOVWF gbl_delivery_ptr, 1

	delivery_bd = &bd0in;
037E  0E04      	MOVLW HIGH(gbl_bd0in+D'0')
0380  6FCD      	MOVWF gbl_delivery_bd+D'1', 1
0382  0E04      	MOVLW LOW(gbl_bd0in+D'0')
0384  6FCC      	MOVWF gbl_delivery_bd, 1

	delivery_buffer = &buffer_0_in;
0386  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
0388  6FCB      	MOVWF gbl_delivery_buffer+D'1', 1
038A  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
038C  6FCA      	MOVWF gbl_delivery_buffer, 1

	
	clear_bit(bd0in.stat, DTS);	// ready to get toggled
038E  0104      	MOVLB 0x04
0390  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
0392  ECEDF000  	CALL usb_send_d_0003D

}
0396  0012      	RETURN


void usb_prime_ep0_out() {

	#ifdef USB_DEBUG
		serial_putc('P');
06AC  0E50      	MOVLW 0x50
06AE  0100      	MOVLB 0x00
06B0  6FFE      	MOVWF serial_put_00010_arg_c, 1
06B2  EC57F000  	CALL serial_put_00010

	#endif
	bd0out.count = USB_EP0_OUT_SIZE;
06B6  0E08      	MOVLW 0x08
06B8  0104      	MOVLB 0x04
06BA  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out.addr = USB_EP0_OUT_ADDR;
06BC  6B02      	CLRF gbl_bd0out+D'2', 1
06BE  0E05      	MOVLW 0x05
06C0  6F03      	MOVWF gbl_bd0out+D'3', 1

	//changed from clear to set
	set_bit(bd0out.stat, DTS);	// turn on data togle sync TOGGLE
06C2  8D00      	BSF gbl_bd0out,6, 1

	clear_bit(bd0out.stat, KEN);	// clear the keep bit
06C4  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out.stat, INCDIS);	// clear the increment disable
06C6  9900      	BCF gbl_bd0out,4, 1

	// !! changed here to not be dtsen....
	set_bit  (bd0out.stat, DTSEN);
06C8  8700      	BSF gbl_bd0out,3, 1

	clear_bit(bd0out.stat, BSTALL);	// clear stall bit
06CA  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out.stat, BC9);
06CC  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out.stat, BC8);
06CE  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out.stat, UOWN);	// SIE owns the buffer
06D0  8F00      	BSF gbl_bd0out,7, 1

}						  
06D2  0012      	RETURN


void usb_handle_standard_request(setup_data_packet sdp) {


	switch (sdp.bRequest) {

		case req_Get_Descriptor:
06D4  0E06      	MOVLW 0x06
06D6  63E8      	CPFSEQ usb_handle_00041_arg_sdp+D'1', 1
06D8  D001      	BRA	label42
06DA  D010      	BRA	label46
06DC            label42
06FC            label46

			#ifdef USB_DEBUG
				serial_print_str(" GD: ");
06FC  0E20      	MOVLW 0x20
06FE  6FF3      	MOVWF CompTempVar941, 1
0700  6FF7      	MOVWF CompTempVar941+D'4', 1
0702  0E3A      	MOVLW 0x3A
0704  6FF6      	MOVWF CompTempVar941+D'3', 1
0706  0E44      	MOVLW 0x44
0708  6FF5      	MOVWF CompTempVar941+D'2', 1
070A  0E47      	MOVLW 0x47
070C  6FF4      	MOVWF CompTempVar941+D'1', 1
070E  6BF8      	CLRF CompTempVar941+D'5', 1
0710  0E00      	MOVLW HIGH(CompTempVar941+D'0')
0712  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0714  0EF3      	MOVLW LOW(CompTempVar941+D'0')
0716  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0718  EC86F000  	CALL serial_pri_00012

			#endif
			uns8 descriptor_type = sdp.wValue >> 8; // high byte is descriptor
071C  51EA      	MOVF usb_handle_00041_arg_sdp+D'3', W, 1
071E  6FEF      	MOVWF usb_handle_00041_1_descrip_00042, 1

			uns8 descriptor_num  = sdp.wValue & 0xff; // low byte is particular descriptor
0720  51E9      	MOVF usb_handle_00041_arg_sdp+D'2', W, 1
0722  6FF0      	MOVWF usb_handle_00041_1_descrip_00043, 1

			#ifdef USB_DEBUG
				serial_print_int(descriptor_type);
0724  51EF      	MOVF usb_handle_00041_1_descrip_00042, W, 1
0726  6FFB      	MOVWF serial_pri_00014_arg_i, 1
0728  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
072A  EC60F001  	CALL serial_pri_00014

			#endif
			usb_get_descriptor_callback(descriptor_type, descriptor_num, &delivery_ptr, &delivery_bytes_to_send);
072E  51EF      	MOVF usb_handle_00041_1_descrip_00042, W, 1
0730  6FF1      	MOVWF usb_get_de_00025_arg_descr_00026, 1
0732  51F0      	MOVF usb_handle_00041_1_descrip_00043, W, 1
0734  6FF2      	MOVWF usb_get_de_00025_arg_descr_00027, 1
0736  0E00      	MOVLW HIGH(gbl_delivery_ptr+D'0')
0738  6FF4      	MOVWF usb_get_de_00025_arg_rtn_d_00028+D'1', 1
073A  0EC8      	MOVLW LOW(gbl_delivery_ptr+D'0')
073C  6FF3      	MOVWF usb_get_de_00025_arg_rtn_d_00028, 1
073E  0E00      	MOVLW HIGH(gbl_delivery_bytes_to_send+D'0')
0740  6FF6      	MOVWF usb_get_de_00025_arg_rtn_d_00029+D'1', 1
0742  0EC2      	MOVLW LOW(gbl_delivery_bytes_to_send+D'0')
0744  6FF5      	MOVWF usb_get_de_00025_arg_rtn_d_00029, 1
0746  ECE4F001  	CALL usb_get_de_00025

			if (delivery_ptr != 0) {	// we've got something
074A  53C8      	MOVF gbl_delivery_ptr, F, 1
074C  E102      	BNZ	label47
074E  53C9      	MOVF gbl_delivery_ptr+D'1', F, 1
0750  E017      	BZ	label48
0752            label47
0780            label48

				control_mode = cm_CTRL_READ_DATA_STAGE;
0752  0E03      	MOVLW 0x03
0754  6FD7      	MOVWF gbl_control_mode, 1

				delivery_bytes_max_send = sdp.wLength;	// maximum host wants
0756  51ED      	MOVF usb_handle_00041_arg_sdp+D'6', W, 1
0758  6FC4      	MOVWF gbl_delivery_bytes_max_send, 1
075A  51EE      	MOVF usb_handle_00041_arg_sdp+D'7', W, 1
075C  6FC5      	MOVWF gbl_delivery_bytes_max_send+D'1', 1

				delivery_bytes_sent = 0;	// clear our sent countr
075E  6BC6      	CLRF gbl_delivery_bytes_sent, 1
0760  6BC7      	CLRF gbl_delivery_bytes_sent+D'1', 1

				delivery_buffer_size = USB_EP0_IN_SIZE;
0762  0E08      	MOVLW 0x08
0764  6FD8      	MOVWF gbl_delivery_buffer_size, 1

				delivery_bd = &bd0in;
0766  0E04      	MOVLW HIGH(gbl_bd0in+D'0')
0768  6FCD      	MOVWF gbl_delivery_bd+D'1', 1
076A  0E04      	MOVLW LOW(gbl_bd0in+D'0')
076C  6FCC      	MOVWF gbl_delivery_bd, 1

				delivery_buffer = (uns8 *)USB_EP0_IN_ADDR;
076E  0E08      	MOVLW 0x08
0770  6FCA      	MOVWF gbl_delivery_buffer, 1
0772  0E05      	MOVLW 0x05
0774  6FCB      	MOVWF gbl_delivery_buffer+D'1', 1

				clear_bit(bd0in.stat, DTS);	// ready to get toggled
0776  0104      	MOVLB 0x04
0778  9D04      	BCF gbl_bd0in,6, 1

				usb_send_data_chunk();
077A  ECEDF000  	CALL usb_send_d_0003D

			} else {
				#ifdef USB_DEBUG
					serial_print_str(" <stall> ");
0780  0E20      	MOVLW 0x20
0782  6FF1      	MOVWF CompTempVar946, 1
0784  6FF9      	MOVWF CompTempVar946+D'8', 1
0786  0E3C      	MOVLW 0x3C
0788  6FF2      	MOVWF CompTempVar946+D'1', 1
078A  0E3E      	MOVLW 0x3E
078C  6FF8      	MOVWF CompTempVar946+D'7', 1
078E  0E61      	MOVLW 0x61
0790  6FF5      	MOVWF CompTempVar946+D'4', 1
0792  0E6C      	MOVLW 0x6C
0794  6FF6      	MOVWF CompTempVar946+D'5', 1
0796  6FF7      	MOVWF CompTempVar946+D'6', 1
0798  0E73      	MOVLW 0x73
079A  6FF3      	MOVWF CompTempVar946+D'2', 1
079C  0E74      	MOVLW 0x74
079E  6FF4      	MOVWF CompTempVar946+D'3', 1
07A0  6BFA      	CLRF CompTempVar946+D'9', 1
07A2  0E00      	MOVLW HIGH(CompTempVar946+D'0')
07A4  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
07A6  0EF1      	MOVLW LOW(CompTempVar946+D'0')
07A8  6FFB      	MOVWF serial_pri_00012_arg_str, 1
07AA  EC86F000  	CALL serial_pri_00012

				#endif
				usb_stall_ep0();
07AE  ECAAF001  	CALL usb_stall__00020

			}
		
			break;
		case req_Set_Address:
06DC  0E05      	MOVLW 0x05
06DE  63E8      	CPFSEQ usb_handle_00041_arg_sdp+D'1', 1
06E0  D001      	BRA	label43
06E2  D068      	BRA	label49
06E4            label43
07B4            label49

			usb_address = sdp.wValue & 0xff;
07B4  51E9      	MOVF usb_handle_00041_arg_sdp+D'2', W, 1
07B6  6FD6      	MOVWF gbl_usb_address, 1

			#ifdef USB_DEBUG
				serial_print_str(" SA:");
07B8  0E20      	MOVLW 0x20
07BA  6FF1      	MOVWF CompTempVar948, 1
07BC  0E53      	MOVLW 0x53
07BE  6FF2      	MOVWF CompTempVar948+D'1', 1
07C0  0E41      	MOVLW 0x41
07C2  6FF3      	MOVWF CompTempVar948+D'2', 1
07C4  0E3A      	MOVLW 0x3A
07C6  6FF4      	MOVWF CompTempVar948+D'3', 1
07C8  6BF5      	CLRF CompTempVar948+D'4', 1
07CA  0E00      	MOVLW HIGH(CompTempVar948+D'0')
07CC  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
07CE  0EF1      	MOVLW LOW(CompTempVar948+D'0')
07D0  6FFB      	MOVWF serial_pri_00012_arg_str, 1
07D2  EC86F000  	CALL serial_pri_00012

				serial_print_int_hex(usb_address);
07D6  51D6      	MOVF gbl_usb_address, W, 1
07D8  6FF1      	MOVWF serial_pri_00015_arg_i, 1
07DA  EC36F003  	CALL serial_pri_00015

			#endif 				
			usb_status = us_SET_ADDRESS;
07DE  0E01      	MOVLW 0x01
07E0  0100      	MOVLB 0x00
07E2  6FD9      	MOVWF gbl_usb_status, 1

			
			// Send a status ack - when we confirm that, THEN change address
			usb_send_status_ack();
07E4  ECCCF001  	CALL usb_send_e_0001F

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
07E8  0E06      	MOVLW 0x06
07EA  0100      	MOVLB 0x00
07EC  6FD7      	MOVWF gbl_control_mode, 1

			break;
		case req_Set_Configuration:
06E4  0E09      	MOVLW 0x09
06E6  63E8      	CPFSEQ usb_handle_00041_arg_sdp+D'1', 1
06E8  D001      	BRA	label44
06EA  D082      	BRA	label50
06EC            label44
07F0            label50

			#ifdef USB_DEBUG
				serial_print_str(" SC: ");
07F0  0E20      	MOVLW 0x20
07F2  6FF1      	MOVWF CompTempVar950, 1
07F4  6FF5      	MOVWF CompTempVar950+D'4', 1
07F6  0E3A      	MOVLW 0x3A
07F8  6FF4      	MOVWF CompTempVar950+D'3', 1
07FA  0E43      	MOVLW 0x43
07FC  6FF3      	MOVWF CompTempVar950+D'2', 1
07FE  0E53      	MOVLW 0x53
0800  6FF2      	MOVWF CompTempVar950+D'1', 1
0802  6BF6      	CLRF CompTempVar950+D'5', 1
0804  0E00      	MOVLW HIGH(CompTempVar950+D'0')
0806  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0808  0EF1      	MOVLW LOW(CompTempVar950+D'0')
080A  6FFB      	MOVWF serial_pri_00012_arg_str, 1
080C  EC86F000  	CALL serial_pri_00012

			#endif 			

			//sdp.wValue & 0xff; // MORE WORK see p136
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
0810  0E06      	MOVLW 0x06
0812  6FD7      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
0814  ECCCF001  	CALL usb_send_e_0001F

			
			usb_state = st_CONFIGURED;
0818  0E03      	MOVLW 0x03
081A  0100      	MOVLB 0x00
081C  6FD5      	MOVWF gbl_usb_state, 1

			
			// device is up - so now get the endpoints happy
			usb_configure_endpoints();
081E  EC0AF003  	CALL usb_config_0003E

			// and do a call back to let the app know we're ready
			#ifdef USB_CALLBACK_ON_DEVICE_CONFIGURED
				usb_device_configured_callback();
			#endif	
			break;
		case req_Get_Interface:
06EC  0E0A      	MOVLW 0x0A
06EE  63E8      	CPFSEQ usb_handle_00041_arg_sdp+D'1', 1
06F0  D001      	BRA	label45
06F2  D098      	BRA	label51
06F4            label45
0824            label51

				#ifdef USB_DEBUG
					serial_print_str(" GI ");
0824  0E20      	MOVLW 0x20
0826  6FF1      	MOVWF CompTempVar952, 1
0828  6FF4      	MOVWF CompTempVar952+D'3', 1
082A  0E47      	MOVLW 0x47
082C  6FF2      	MOVWF CompTempVar952+D'1', 1
082E  0E49      	MOVLW 0x49
0830  6FF3      	MOVWF CompTempVar952+D'2', 1
0832  6BF5      	CLRF CompTempVar952+D'4', 1
0834  0E00      	MOVLW HIGH(CompTempVar952+D'0')
0836  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0838  0EF1      	MOVLW LOW(CompTempVar952+D'0')
083A  6FFB      	MOVWF serial_pri_00012_arg_str, 1
083C  EC86F000  	CALL serial_pri_00012

				#endif	
				control_mode = cm_CTRL_READ_DATA_STAGE;
0840  0E03      	MOVLW 0x03
0842  6FD7      	MOVWF gbl_control_mode, 1

				usb_send_one_byte(1);
0844  0E01      	MOVLW 0x01
0846  6FF1      	MOVWF usb_send_o_0003F_arg_data, 1
0848  ECB0F001  	CALL usb_send_o_0003F

		case req_Get_Status:
06F4  53E8      	MOVF usb_handle_00041_arg_sdp+D'1', F, 1
06F6  B4D8      	BTFSC STATUS,Z
06F8  D0A9      	BRA	label52
084C            label52

				// this is wrong - needs to send two bytes !!
				#ifdef USB_DEBUG				
					serial_print_str(" GS ");
084C  0E20      	MOVLW 0x20
084E  0100      	MOVLB 0x00
0850  6FF1      	MOVWF CompTempVar954, 1
0852  6FF4      	MOVWF CompTempVar954+D'3', 1
0854  0E47      	MOVLW 0x47
0856  6FF2      	MOVWF CompTempVar954+D'1', 1
0858  0E53      	MOVLW 0x53
085A  6FF3      	MOVWF CompTempVar954+D'2', 1
085C  6BF5      	CLRF CompTempVar954+D'4', 1
085E  0E00      	MOVLW HIGH(CompTempVar954+D'0')
0860  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0862  0EF1      	MOVLW LOW(CompTempVar954+D'0')
0864  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0866  EC86F000  	CALL serial_pri_00012

				#endif

				#ifdef USB_SELF_POWERED
					usb_send_one_byte(1);
				#else
					usb_send_one_byte(0);	// bus powered
086A  6BF1      	CLRF usb_send_o_0003F_arg_data, 1
086C  ECB0F001  	CALL usb_send_o_0003F

				#endif
				break;	
		default:
06FA  D0BB      	BRA	label53
0872            label53

			#ifdef USB_DEBUG
				serial_print_str(" ??SR ");		
0872  0E20      	MOVLW 0x20
0874  6FF1      	MOVWF CompTempVar956, 1
0876  6FF6      	MOVWF CompTempVar956+D'5', 1
0878  0E3F      	MOVLW 0x3F
087A  6FF2      	MOVWF CompTempVar956+D'1', 1
087C  6FF3      	MOVWF CompTempVar956+D'2', 1
087E  0E52      	MOVLW 0x52
0880  6FF5      	MOVWF CompTempVar956+D'4', 1
0882  0E53      	MOVLW 0x53
0884  6FF4      	MOVWF CompTempVar956+D'3', 1
0886  6BF7      	CLRF CompTempVar956+D'6', 1
0888  0E00      	MOVLW HIGH(CompTempVar956+D'0')
088A  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
088C  0EF1      	MOVLW LOW(CompTempVar956+D'0')
088E  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0890  EC86F000  	CALL serial_pri_00012

				serial_print_int(sdp.bRequest);
0894  51E8      	MOVF usb_handle_00041_arg_sdp+D'1', W, 1
0896  6FFB      	MOVWF serial_pri_00014_arg_i, 1
0898  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
089A  EC60F001  	CALL serial_pri_00014

			#endif
			break;
			
	}	
}	
077E  0012      	RETURN
07B2  0012      	RETURN
07EE  0012      	RETURN
0822  0012      	RETURN
0870  0012      	RETURN
089E  0012      	RETURN



void usb_handle_transaction() {


uns8 end_point, pid;

	end_point = ustat >> 3;
0A3E  306C      	RRCF gbl_ustat, W
0A40  0100      	MOVLB 0x00
0A42  6FDF      	MOVWF usb_handle_0003A_1_end_point, 1
0A44  33DF      	RRCF usb_handle_0003A_1_end_point, F, 1
0A46  33DF      	RRCF usb_handle_0003A_1_end_point, F, 1
0A48  0E1F      	MOVLW 0x1F
0A4A  17DF      	ANDWF usb_handle_0003A_1_end_point, F, 1

	
	if (test_bit(ustat, DIR)) {
0A4C  A46C      	BTFSS gbl_ustat,2
0A4E  D019      	BRA	label61
0A82            label61

		#ifdef USB_DEBUG			
			serial_print_str("\nDI ");
0A50  0E0A      	MOVLW 0x0A
0A52  6FE1      	MOVWF CompTempVar851, 1
0A54  0E44      	MOVLW 0x44
0A56  6FE2      	MOVWF CompTempVar851+D'1', 1
0A58  0E49      	MOVLW 0x49
0A5A  6FE3      	MOVWF CompTempVar851+D'2', 1
0A5C  0E20      	MOVLW 0x20
0A5E  6FE4      	MOVWF CompTempVar851+D'3', 1
0A60  6BE5      	CLRF CompTempVar851+D'4', 1
0A62  0E00      	MOVLW HIGH(CompTempVar851+D'0')
0A64  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0A66  0EE1      	MOVLW LOW(CompTempVar851+D'0')
0A68  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0A6A  EC86F000  	CALL serial_pri_00012

		#endif			
		pid = (bd0in.stat >> 2) & 0x0f;	// mask out pid
0A6E  0104      	MOVLB 0x04
0A70  3104      	RRCF gbl_bd0in, W, 1
0A72  0100      	MOVLB 0x00
0A74  6FE0      	MOVWF usb_handle_0003A_1_pid, 1
0A76  33E0      	RRCF usb_handle_0003A_1_pid, F, 1
0A78  0E3F      	MOVLW 0x3F
0A7A  17E0      	ANDWF usb_handle_0003A_1_pid, F, 1
0A7C  0E0F      	MOVLW 0x0F
0A7E  17E0      	ANDWF usb_handle_0003A_1_pid, F, 1


	} else {
0A80  D019      	BRA	label62
0AB4            label62

		pid = (bd0out.stat >> 2) & 0x0f;	// mask out pid
0A82  0104      	MOVLB 0x04
0A84  3100      	RRCF gbl_bd0out, W, 1
0A86  0100      	MOVLB 0x00
0A88  6FE1      	MOVWF CompTempVar854, 1
0A8A  33E1      	RRCF CompTempVar854, F, 1
0A8C  0E3F      	MOVLW 0x3F
0A8E  17E1      	ANDWF CompTempVar854, F, 1
0A90  0E0F      	MOVLW 0x0F
0A92  15E1      	ANDWF CompTempVar854, W, 1
0A94  6FE0      	MOVWF usb_handle_0003A_1_pid, 1

		#ifdef USB_DEBUG			
			serial_print_str("\nDO ");
0A96  0E0A      	MOVLW 0x0A
0A98  6FE1      	MOVWF CompTempVar855, 1
0A9A  0E44      	MOVLW 0x44
0A9C  6FE2      	MOVWF CompTempVar855+D'1', 1
0A9E  0E4F      	MOVLW 0x4F
0AA0  6FE3      	MOVWF CompTempVar855+D'2', 1
0AA2  0E20      	MOVLW 0x20
0AA4  6FE4      	MOVWF CompTempVar855+D'3', 1
0AA6  6BE5      	CLRF CompTempVar855+D'4', 1
0AA8  0E00      	MOVLW HIGH(CompTempVar855+D'0')
0AAA  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0AAC  0EE1      	MOVLW LOW(CompTempVar855+D'0')
0AAE  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0AB0  EC86F000  	CALL serial_pri_00012

		#endif
		#ifdef USB_DEBUG_HIGH
			serial_print_int(bd0out.count);
			serial_print_spc();
		#endif	
	
	}
	#ifdef USB_DEBUG
		if (end_point != 0) {
0AB4  53DF      	MOVF usb_handle_0003A_1_end_point, F, 1
0AB6  E00B      	BZ	label63
0ACE            label63

			serial_putc('E');
0AB8  0E45      	MOVLW 0x45
0ABA  6FFE      	MOVWF serial_put_00010_arg_c, 1
0ABC  EC57F000  	CALL serial_put_00010

			serial_print_int_hex(end_point);
0AC0  0100      	MOVLB 0x00
0AC2  51DF      	MOVF usb_handle_0003A_1_end_point, W, 1
0AC4  6FF1      	MOVWF serial_pri_00015_arg_i, 1
0AC6  EC36F003  	CALL serial_pri_00015

			serial_print_spc();
0ACA  EC5AF001  	CALL serial_pri_00018

		}
	#endif		
	
	if (end_point == 0) {
0ACE  0100      	MOVLB 0x00
0AD0  53DF      	MOVF usb_handle_0003A_1_end_point, F, 1
0AD2  A4D8      	BTFSS STATUS,Z
0AD4  D25E      	BRA	label85
0F92            label85

		#ifdef USB_DEBUG_HIGH
			serial_print_str(" bytes: ");
			serial_print_int(bd0out.count);
		#endif
		if (pid == pid_SETUP) {
0AD6  0E0D      	MOVLW 0x0D
0AD8  63E0      	CPFSEQ usb_handle_0003A_1_pid, 1
0ADA  D107      	BRA	label70
0CEA            label70

			memcpy(/*dst*/ (void*)&usb_sdp, /*src*/ (void *)&buffer_0_out, 8);
0ADC  0E00      	MOVLW HIGH(gbl_usb_sdp+D'0')
0ADE  6FE5      	MOVWF memcpy8_00000_arg_dst+D'1', 1
0AE0  0E9E      	MOVLW LOW(gbl_usb_sdp+D'0')
0AE2  6FE4      	MOVWF memcpy8_00000_arg_dst, 1
0AE4  0E05      	MOVLW HIGH(gbl_buffer_0_out+D'0')
0AE6  6FE7      	MOVWF memcpy8_00000_arg_src+D'1', 1
0AE8  0E00      	MOVLW LOW(gbl_buffer_0_out+D'0')
0AEA  6FE6      	MOVWF memcpy8_00000_arg_src, 1
0AEC  0E08      	MOVLW 0x08
0AEE  6FE8      	MOVWF memcpy8_00000_arg_len, 1
0AF0  ECAFF004  	CALL memcpy8_00000

			usb_prime_ep0_out();
0AF4  EC56F003  	CALL usb_prime__00040

			#ifdef USB_DEBUG
				serial_print_str(" Setup ");
0AF8  0E20      	MOVLW 0x20
0AFA  0100      	MOVLB 0x00
0AFC  6FE4      	MOVWF CompTempVar865, 1
0AFE  6FEA      	MOVWF CompTempVar865+D'6', 1
0B00  0E53      	MOVLW 0x53
0B02  6FE5      	MOVWF CompTempVar865+D'1', 1
0B04  0E65      	MOVLW 0x65
0B06  6FE6      	MOVWF CompTempVar865+D'2', 1
0B08  0E70      	MOVLW 0x70
0B0A  6FE9      	MOVWF CompTempVar865+D'5', 1
0B0C  0E74      	MOVLW 0x74
0B0E  6FE7      	MOVWF CompTempVar865+D'3', 1
0B10  0E75      	MOVLW 0x75
0B12  6FE8      	MOVWF CompTempVar865+D'4', 1
0B14  6BEB      	CLRF CompTempVar865+D'7', 1
0B16  0E00      	MOVLW HIGH(CompTempVar865+D'0')
0B18  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0B1A  0EE4      	MOVLW LOW(CompTempVar865+D'0')
0B1C  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0B1E  EC86F000  	CALL serial_pri_00012

				serial_print_int_hex(usb_sdp.bmRequestType);
0B22  519E      	MOVF gbl_usb_sdp, W, 1
0B24  6FF1      	MOVWF serial_pri_00015_arg_i, 1
0B26  EC36F003  	CALL serial_pri_00015

				serial_putc(' ');
0B2A  0E20      	MOVLW 0x20
0B2C  0100      	MOVLB 0x00
0B2E  6FFE      	MOVWF serial_put_00010_arg_c, 1
0B30  EC57F000  	CALL serial_put_00010

				if (test_bit(usb_sdp.bmRequestType, DATA_STAGE_DIR)) {
0B34  0100      	MOVLB 0x00
0B36  AF9E      	BTFSS gbl_usb_sdp,7, 1
0B38  D023      	BRA	label64
0B80            label64

					serial_print_str(" Data stage=IN ");
0B3A  0E20      	MOVLW 0x20
0B3C  0102      	MOVLB 0x02
0B3E  6F00      	MOVWF CompTempVar867, 1
0B40  6F05      	MOVWF CompTempVar867+D'5', 1
0B42  6F0E      	MOVWF CompTempVar867+D'14', 1
0B44  0E3D      	MOVLW 0x3D
0B46  6F0B      	MOVWF CompTempVar867+D'11', 1
0B48  0E44      	MOVLW 0x44
0B4A  6F01      	MOVWF CompTempVar867+D'1', 1
0B4C  0E49      	MOVLW 0x49
0B4E  6F0C      	MOVWF CompTempVar867+D'12', 1
0B50  0E4E      	MOVLW 0x4E
0B52  6F0D      	MOVWF CompTempVar867+D'13', 1
0B54  0E61      	MOVLW 0x61
0B56  6F02      	MOVWF CompTempVar867+D'2', 1
0B58  6F04      	MOVWF CompTempVar867+D'4', 1
0B5A  6F08      	MOVWF CompTempVar867+D'8', 1
0B5C  0E65      	MOVLW 0x65
0B5E  6F0A      	MOVWF CompTempVar867+D'10', 1
0B60  0E67      	MOVLW 0x67
0B62  6F09      	MOVWF CompTempVar867+D'9', 1
0B64  0E73      	MOVLW 0x73
0B66  6F06      	MOVWF CompTempVar867+D'6', 1
0B68  0E74      	MOVLW 0x74
0B6A  6F03      	MOVWF CompTempVar867+D'3', 1
0B6C  6F07      	MOVWF CompTempVar867+D'7', 1
0B6E  6B0F      	CLRF CompTempVar867+D'15', 1
0B70  0E02      	MOVLW HIGH(CompTempVar867+D'0')
0B72  0100      	MOVLB 0x00
0B74  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0B76  0E00      	MOVLW LOW(CompTempVar867+D'0')
0B78  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0B7A  EC86F000  	CALL serial_pri_00012

				} else {
0B7E  D029      	BRA	label65
0BD2            label65

					serial_print_str(" Data stage=OUT/NO ");
0B80  0E20      	MOVLW 0x20
0B82  0102      	MOVLB 0x02
0B84  6F00      	MOVWF CompTempVar869, 1
0B86  6F05      	MOVWF CompTempVar869+D'5', 1
0B88  6F12      	MOVWF CompTempVar869+D'18', 1
0B8A  0E2F      	MOVLW 0x2F
0B8C  6F0F      	MOVWF CompTempVar869+D'15', 1
0B8E  0E3D      	MOVLW 0x3D
0B90  6F0B      	MOVWF CompTempVar869+D'11', 1
0B92  0E44      	MOVLW 0x44
0B94  6F01      	MOVWF CompTempVar869+D'1', 1
0B96  0E4E      	MOVLW 0x4E
0B98  6F10      	MOVWF CompTempVar869+D'16', 1
0B9A  0E4F      	MOVLW 0x4F
0B9C  6F0C      	MOVWF CompTempVar869+D'12', 1
0B9E  6F11      	MOVWF CompTempVar869+D'17', 1
0BA0  0E54      	MOVLW 0x54
0BA2  6F0E      	MOVWF CompTempVar869+D'14', 1
0BA4  0E55      	MOVLW 0x55
0BA6  6F0D      	MOVWF CompTempVar869+D'13', 1
0BA8  0E61      	MOVLW 0x61
0BAA  6F02      	MOVWF CompTempVar869+D'2', 1
0BAC  6F04      	MOVWF CompTempVar869+D'4', 1
0BAE  6F08      	MOVWF CompTempVar869+D'8', 1
0BB0  0E65      	MOVLW 0x65
0BB2  6F0A      	MOVWF CompTempVar869+D'10', 1
0BB4  0E67      	MOVLW 0x67
0BB6  6F09      	MOVWF CompTempVar869+D'9', 1
0BB8  0E73      	MOVLW 0x73
0BBA  6F06      	MOVWF CompTempVar869+D'6', 1
0BBC  0E74      	MOVLW 0x74
0BBE  6F03      	MOVWF CompTempVar869+D'3', 1
0BC0  6F07      	MOVWF CompTempVar869+D'7', 1
0BC2  6B13      	CLRF CompTempVar869+D'19', 1
0BC4  0E02      	MOVLW HIGH(CompTempVar869+D'0')
0BC6  0100      	MOVLB 0x00
0BC8  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0BCA  0E00      	MOVLW LOW(CompTempVar869+D'0')
0BCC  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0BCE  EC86F000  	CALL serial_pri_00012

				}
			#endif
			//serial_print_str(" len: ");
			//serial_print_int(usb_sdp.wLength);	
			// Is it a standard request?
			//serial_putc('\\');
			
			if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // std request
0BD2  0E40      	MOVLW 0x40
0BD4  159E      	ANDWF gbl_usb_sdp, W, 1
0BD6  6FE1      	MOVWF CompTempVar859, 1
0BD8  67E1      	TSTFSZ CompTempVar859, 1
0BDA  D038      	BRA	label67
0C4C            label67

			    !test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
0BDC  0E20      	MOVLW 0x20
0BDE  159E      	ANDWF gbl_usb_sdp, W, 1
0BE0  6FE2      	MOVWF CompTempVar860, 1
0BE2  67E2      	TSTFSZ CompTempVar860, 1
0BE4  D033      	BRA	label67

				//serial_print_str(" Std req ");
				if ((usb_sdp.bmRequestType & 0b00011111) == 0) {
0BE6  0E1F      	MOVLW 0x1F
0BE8  159E      	ANDWF gbl_usb_sdp, W, 1
0BEA  6FE4      	MOVWF CompTempVar871, 1
0BEC  53E4      	MOVF CompTempVar871, F, 1
0BEE  E00B      	BZ	label66

					//serial_print_str(" 2dev ");
				} else if ((usb_sdp.bmRequestType & 0b00011111) == 1) {	
0BF0  0E1F      	MOVLW 0x1F
0BF2  159E      	ANDWF gbl_usb_sdp, W, 1
0BF4  6FE5      	MOVWF CompTempVar872, 1
0BF6  05E5      	DECF CompTempVar872, W, 1
0BF8  E006      	BZ	label66

					//serial_print_str(" 2int ");
				} else if ((usb_sdp.bmRequestType & 0b00011111) == 0b00011) {	
0BFA  0E1F      	MOVLW 0x1F
0BFC  159E      	ANDWF gbl_usb_sdp, W, 1
0BFE  6FE6      	MOVWF CompTempVar873, 1
0C00  0E03      	MOVLW 0x03
0C02  63E6      	CPFSEQ CompTempVar873, 1
0C04  D000      	BRA	label66
0C06            label66

					//serial_print_str(" 2oth ");
				}
				#ifdef USB_DEBUG
					serial_print_str(" std ");
0C06  0E20      	MOVLW 0x20
0C08  6FE7      	MOVWF CompTempVar874, 1
0C0A  6FEB      	MOVWF CompTempVar874+D'4', 1
0C0C  0E64      	MOVLW 0x64
0C0E  6FEA      	MOVWF CompTempVar874+D'3', 1
0C10  0E73      	MOVLW 0x73
0C12  6FE8      	MOVWF CompTempVar874+D'1', 1
0C14  0E74      	MOVLW 0x74
0C16  6FE9      	MOVWF CompTempVar874+D'2', 1
0C18  6BEC      	CLRF CompTempVar874+D'5', 1
0C1A  0E00      	MOVLW HIGH(CompTempVar874+D'0')
0C1C  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0C1E  0EE7      	MOVLW LOW(CompTempVar874+D'0')
0C20  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0C22  EC86F000  	CALL serial_pri_00012

				#endif	
				usb_handle_standard_request(usb_sdp);	
0C26  51A5      	MOVF gbl_usb_sdp+D'7', W, 1
0C28  6FEE      	MOVWF usb_handle_00041_arg_sdp+D'7', 1
0C2A  51A4      	MOVF gbl_usb_sdp+D'6', W, 1
0C2C  6FED      	MOVWF usb_handle_00041_arg_sdp+D'6', 1
0C2E  51A3      	MOVF gbl_usb_sdp+D'5', W, 1
0C30  6FEC      	MOVWF usb_handle_00041_arg_sdp+D'5', 1
0C32  51A2      	MOVF gbl_usb_sdp+D'4', W, 1
0C34  6FEB      	MOVWF usb_handle_00041_arg_sdp+D'4', 1
0C36  51A1      	MOVF gbl_usb_sdp+D'3', W, 1
0C38  6FEA      	MOVWF usb_handle_00041_arg_sdp+D'3', 1
0C3A  51A0      	MOVF gbl_usb_sdp+D'2', W, 1
0C3C  6FE9      	MOVWF usb_handle_00041_arg_sdp+D'2', 1
0C3E  519F      	MOVF gbl_usb_sdp+D'1', W, 1
0C40  6FE8      	MOVWF usb_handle_00041_arg_sdp+D'1', 1
0C42  519E      	MOVF gbl_usb_sdp, W, 1
0C44  6FE7      	MOVWF usb_handle_00041_arg_sdp, 1
0C46  EC6AF003  	CALL usb_handle_00041

			} else if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // class request
0C4A  D04D      	BRA	label69
0C4C  0E40      	MOVLW 0x40
0C4E  159E      	ANDWF gbl_usb_sdp, W, 1
0C50  6FE3      	MOVWF CompTempVar862, 1
0C52  67E3      	TSTFSZ CompTempVar862, 1
0C54  D028      	BRA	label68
0CA6            label68

					test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
0C56  AB9E      	BTFSS gbl_usb_sdp,5, 1
0C58  D026      	BRA	label68

					#ifdef USB_DEBUG
						serial_print_str(" class ");
0C5A  0E20      	MOVLW 0x20
0C5C  6FE4      	MOVWF CompTempVar876, 1
0C5E  6FEA      	MOVWF CompTempVar876+D'6', 1
0C60  0E61      	MOVLW 0x61
0C62  6FE7      	MOVWF CompTempVar876+D'3', 1
0C64  0E63      	MOVLW 0x63
0C66  6FE5      	MOVWF CompTempVar876+D'1', 1
0C68  0E6C      	MOVLW 0x6C
0C6A  6FE6      	MOVWF CompTempVar876+D'2', 1
0C6C  0E73      	MOVLW 0x73
0C6E  6FE8      	MOVWF CompTempVar876+D'4', 1
0C70  6FE9      	MOVWF CompTempVar876+D'5', 1
0C72  6BEB      	CLRF CompTempVar876+D'7', 1
0C74  0E00      	MOVLW HIGH(CompTempVar876+D'0')
0C76  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0C78  0EE4      	MOVLW LOW(CompTempVar876+D'0')
0C7A  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0C7C  EC86F000  	CALL serial_pri_00012

					#endif
				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_request_callback(usb_sdp);
0C80  51A5      	MOVF gbl_usb_sdp+D'7', W, 1
0C82  6FEB      	MOVWF usb_handle_00022_arg_sdp+D'7', 1
0C84  51A4      	MOVF gbl_usb_sdp+D'6', W, 1
0C86  6FEA      	MOVWF usb_handle_00022_arg_sdp+D'6', 1
0C88  51A3      	MOVF gbl_usb_sdp+D'5', W, 1
0C8A  6FE9      	MOVWF usb_handle_00022_arg_sdp+D'5', 1
0C8C  51A2      	MOVF gbl_usb_sdp+D'4', W, 1
0C8E  6FE8      	MOVWF usb_handle_00022_arg_sdp+D'4', 1
0C90  51A1      	MOVF gbl_usb_sdp+D'3', W, 1
0C92  6FE7      	MOVWF usb_handle_00022_arg_sdp+D'3', 1
0C94  51A0      	MOVF gbl_usb_sdp+D'2', W, 1
0C96  6FE6      	MOVWF usb_handle_00022_arg_sdp+D'2', 1
0C98  519F      	MOVF gbl_usb_sdp+D'1', W, 1
0C9A  6FE5      	MOVWF usb_handle_00022_arg_sdp+D'1', 1
0C9C  519E      	MOVF gbl_usb_sdp, W, 1
0C9E  6FE4      	MOVWF usb_handle_00022_arg_sdp, 1
0CA0  EC52F004  	CALL usb_handle_00022

				#endif	
			} else {
0CA4  D020      	BRA	label69
0CE6            label69

				//serial_print_str(" req no ");
				//serial_print_int(usb_sdp.bRequest);
				// serial_print_spc();
				#ifdef USB_DEBUG
					serial_print_str(" ??req t=");
0CA6  0E20      	MOVLW 0x20
0CA8  6FE4      	MOVWF CompTempVar878, 1
0CAA  6FEA      	MOVWF CompTempVar878+D'6', 1
0CAC  0E3D      	MOVLW 0x3D
0CAE  6FEC      	MOVWF CompTempVar878+D'8', 1
0CB0  0E3F      	MOVLW 0x3F
0CB2  6FE5      	MOVWF CompTempVar878+D'1', 1
0CB4  6FE6      	MOVWF CompTempVar878+D'2', 1
0CB6  0E65      	MOVLW 0x65
0CB8  6FE8      	MOVWF CompTempVar878+D'4', 1
0CBA  0E71      	MOVLW 0x71
0CBC  6FE9      	MOVWF CompTempVar878+D'5', 1
0CBE  0E72      	MOVLW 0x72
0CC0  6FE7      	MOVWF CompTempVar878+D'3', 1
0CC2  0E74      	MOVLW 0x74
0CC4  6FEB      	MOVWF CompTempVar878+D'7', 1
0CC6  6BED      	CLRF CompTempVar878+D'9', 1
0CC8  0E00      	MOVLW HIGH(CompTempVar878+D'0')
0CCA  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0CCC  0EE4      	MOVLW LOW(CompTempVar878+D'0')
0CCE  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0CD0  EC86F000  	CALL serial_pri_00012

					serial_print_int(usb_sdp.bmRequestType);
0CD4  519E      	MOVF gbl_usb_sdp, W, 1
0CD6  6FFB      	MOVWF serial_pri_00014_arg_i, 1
0CD8  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
0CDA  EC60F001  	CALL serial_pri_00014

					serial_putc(' ');
0CDE  0E20      	MOVLW 0x20
0CE0  6FFE      	MOVWF serial_put_00010_arg_c, 1
0CE2  EC57F000  	CALL serial_put_00010

				#endif	
			}
			clear_bit(ucon, PKTDIS);	// Trap for young players right there - and do it early!
0CE6  986D      	BCF gbl_ucon,4


		} else if (pid == pid_IN) {
0CEA  0E09      	MOVLW 0x09
0CEC  63E0      	CPFSEQ usb_handle_0003A_1_pid, 1
0CEE  D099      	BRA	label76
0E22            label76

			#ifdef USB_DEBUG
				serial_print_str(" IN ");
0CF0  0E20      	MOVLW 0x20
0CF2  6FE1      	MOVWF CompTempVar880, 1
0CF4  6FE4      	MOVWF CompTempVar880+D'3', 1
0CF6  0E49      	MOVLW 0x49
0CF8  6FE2      	MOVWF CompTempVar880+D'1', 1
0CFA  0E4E      	MOVLW 0x4E
0CFC  6FE3      	MOVWF CompTempVar880+D'2', 1
0CFE  6BE5      	CLRF CompTempVar880+D'4', 1
0D00  0E00      	MOVLW HIGH(CompTempVar880+D'0')
0D02  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0D04  0EE1      	MOVLW LOW(CompTempVar880+D'0')
0D06  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0D08  EC86F000  	CALL serial_pri_00012

			#endif
			if (control_mode == cm_CTRL_READ_DATA_STAGE) {
0D0C  0E03      	MOVLW 0x03
0D0E  63D7      	CPFSEQ gbl_control_mode, 1
0D10  D003      	BRA	label71
0D18            label71

				// it's ours, so send next chunk
				usb_send_data_chunk();
0D12  ECEDF000  	CALL usb_send_d_0003D

			} else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS) {
0D18  0E06      	MOVLW 0x06
0D1A  63D7      	CPFSEQ gbl_control_mode, 1
0D1C  D019      	BRA	label73
0D50            label73

				//serial_print_str("std ");
				control_mode = cm_IDLE;
0D1E  6BD7      	CLRF gbl_control_mode, 1

				if (usb_status == us_SET_ADDRESS) {
0D20  05D9      	DECF gbl_usb_status, W, 1
0D22  E105      	BNZ	label72
0D2E            label72

					//serial_print_str(" addr to ");
					usb_state = st_ADDRESS;
0D24  0E02      	MOVLW 0x02
0D26  6FD5      	MOVWF gbl_usb_state, 1

					uaddr = usb_address;
0D28  51D6      	MOVF gbl_usb_address, W, 1
0D2A  6E6E      	MOVWF gbl_uaddr

					//serial_print_int(uaddr);
					//serial_putc('!');
					usb_status = us_IDLE;
0D2C  6BD9      	CLRF gbl_usb_status, 1

				}
				#ifdef USB_DEBUG
					serial_print_str(" ----\n");
0D2E  0E20      	MOVLW 0x20
0D30  6FE1      	MOVWF CompTempVar882, 1
0D32  0E2D      	MOVLW 0x2D
0D34  6FE2      	MOVWF CompTempVar882+D'1', 1
0D36  6FE3      	MOVWF CompTempVar882+D'2', 1
0D38  6FE4      	MOVWF CompTempVar882+D'3', 1
0D3A  6FE5      	MOVWF CompTempVar882+D'4', 1
0D3C  0E0A      	MOVLW 0x0A
0D3E  6FE6      	MOVWF CompTempVar882+D'5', 1
0D40  6BE7      	CLRF CompTempVar882+D'6', 1
0D42  0E00      	MOVLW HIGH(CompTempVar882+D'0')
0D44  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0D46  0EE1      	MOVLW LOW(CompTempVar882+D'0')
0D48  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0D4A  EC86F000  	CALL serial_pri_00012

				#endif	
			} else if (control_mode == cm_CTRL_READ_AWAITING_STATUS) {
0D50  0E05      	MOVLW 0x05
0D52  63D7      	CPFSEQ gbl_control_mode, 1
0D54  D002      	BRA	label74
0D5A            label74

				// Must have been last IN of the read, so still waiting for status
				#ifdef USB_DEBUG
					//serial_print_str(" last read, waiting status");
				#endif	
				nop(); // boostc bug
0D56  0000      	NOP

			} else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS) {
0D5A  0E04      	MOVLW 0x04
0D5C  63D7      	CPFSEQ gbl_control_mode, 1
0D5E  D046      	BRA	label75
0DEC            label75

				#ifdef USB_DEBUG
					serial_print_str(" ctrl read data stage class - more to come? ");
0D60  0E20      	MOVLW 0x20
0D62  0102      	MOVLB 0x02
0D64  6F00      	MOVWF CompTempVar884, 1
0D66  6F05      	MOVWF CompTempVar884+D'5', 1
0D68  6F0A      	MOVWF CompTempVar884+D'10', 1
0D6A  6F0F      	MOVWF CompTempVar884+D'15', 1
0D6C  6F15      	MOVWF CompTempVar884+D'21', 1
0D6E  6F1B      	MOVWF CompTempVar884+D'27', 1
0D70  6F1D      	MOVWF CompTempVar884+D'29', 1
0D72  6F22      	MOVWF CompTempVar884+D'34', 1
0D74  6F25      	MOVWF CompTempVar884+D'37', 1
0D76  6F2B      	MOVWF CompTempVar884+D'43', 1
0D78  0E2D      	MOVLW 0x2D
0D7A  6F1C      	MOVWF CompTempVar884+D'28', 1
0D7C  0E3F      	MOVLW 0x3F
0D7E  6F2A      	MOVWF CompTempVar884+D'42', 1
0D80  0E61      	MOVLW 0x61
0D82  6F08      	MOVWF CompTempVar884+D'8', 1
0D84  6F0C      	MOVWF CompTempVar884+D'12', 1
0D86  6F0E      	MOVWF CompTempVar884+D'14', 1
0D88  6F12      	MOVWF CompTempVar884+D'18', 1
0D8A  6F18      	MOVWF CompTempVar884+D'24', 1
0D8C  0E63      	MOVLW 0x63
0D8E  6F01      	MOVWF CompTempVar884+D'1', 1
0D90  6F16      	MOVWF CompTempVar884+D'22', 1
0D92  6F26      	MOVWF CompTempVar884+D'38', 1
0D94  0E64      	MOVLW 0x64
0D96  6F09      	MOVWF CompTempVar884+D'9', 1
0D98  6F0B      	MOVWF CompTempVar884+D'11', 1
0D9A  0E65      	MOVLW 0x65
0D9C  6F07      	MOVWF CompTempVar884+D'7', 1
0D9E  6F14      	MOVWF CompTempVar884+D'20', 1
0DA0  6F21      	MOVWF CompTempVar884+D'33', 1
0DA2  6F29      	MOVWF CompTempVar884+D'41', 1
0DA4  0E67      	MOVLW 0x67
0DA6  6F13      	MOVWF CompTempVar884+D'19', 1
0DA8  0E6C      	MOVLW 0x6C
0DAA  6F04      	MOVWF CompTempVar884+D'4', 1
0DAC  6F17      	MOVWF CompTempVar884+D'23', 1
0DAE  0E6D      	MOVLW 0x6D
0DB0  6F1E      	MOVWF CompTempVar884+D'30', 1
0DB2  6F28      	MOVWF CompTempVar884+D'40', 1
0DB4  0E6F      	MOVLW 0x6F
0DB6  6F1F      	MOVWF CompTempVar884+D'31', 1
0DB8  6F24      	MOVWF CompTempVar884+D'36', 1
0DBA  6F27      	MOVWF CompTempVar884+D'39', 1
0DBC  0E72      	MOVLW 0x72
0DBE  6F03      	MOVWF CompTempVar884+D'3', 1
0DC0  6F06      	MOVWF CompTempVar884+D'6', 1
0DC2  6F20      	MOVWF CompTempVar884+D'32', 1
0DC4  0E73      	MOVLW 0x73
0DC6  6F10      	MOVWF CompTempVar884+D'16', 1
0DC8  6F19      	MOVWF CompTempVar884+D'25', 1
0DCA  6F1A      	MOVWF CompTempVar884+D'26', 1
0DCC  0E74      	MOVLW 0x74
0DCE  6F02      	MOVWF CompTempVar884+D'2', 1
0DD0  6F0D      	MOVWF CompTempVar884+D'13', 1
0DD2  6F11      	MOVWF CompTempVar884+D'17', 1
0DD4  6F23      	MOVWF CompTempVar884+D'35', 1
0DD6  6B2C      	CLRF CompTempVar884+D'44', 1
0DD8  0E02      	MOVLW HIGH(CompTempVar884+D'0')
0DDA  0100      	MOVLB 0x00
0DDC  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0DDE  0E00      	MOVLW LOW(CompTempVar884+D'0')
0DE0  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0DE2  EC86F000  	CALL serial_pri_00012

				#endif	
				// Must be more to come
				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_ctrl_read_callback();
0DE6  EC51F004  	CALL usb_handle_00023

				#else
					nop(); // otherwise boostc bug
				#endif	
			} else {
				#ifdef USB_DEBUG
					serial_print_str(" ?? cm=");
0DEC  0E20      	MOVLW 0x20
0DEE  6FE1      	MOVWF CompTempVar886, 1
0DF0  6FE4      	MOVWF CompTempVar886+D'3', 1
0DF2  0E3D      	MOVLW 0x3D
0DF4  6FE7      	MOVWF CompTempVar886+D'6', 1
0DF6  0E3F      	MOVLW 0x3F
0DF8  6FE2      	MOVWF CompTempVar886+D'1', 1
0DFA  6FE3      	MOVWF CompTempVar886+D'2', 1
0DFC  0E63      	MOVLW 0x63
0DFE  6FE5      	MOVWF CompTempVar886+D'4', 1
0E00  0E6D      	MOVLW 0x6D
0E02  6FE6      	MOVWF CompTempVar886+D'5', 1
0E04  6BE8      	CLRF CompTempVar886+D'7', 1
0E06  0E00      	MOVLW HIGH(CompTempVar886+D'0')
0E08  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0E0A  0EE1      	MOVLW LOW(CompTempVar886+D'0')
0E0C  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0E0E  EC86F000  	CALL serial_pri_00012

					serial_print_int((uns8)control_mode);
0E12  51D7      	MOVF gbl_control_mode, W, 1
0E14  6FFB      	MOVWF serial_pri_00014_arg_i, 1
0E16  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
0E18  EC60F001  	CALL serial_pri_00014

					serial_print_spc();
0E1C  EC5AF001  	CALL serial_pri_00018

				#else
					nop(); // boostc bug
				#endif	
					
			}
		} else if (pid == pid_ACK) {
0E22  0E02      	MOVLW 0x02
0E24  63E0      	CPFSEQ usb_handle_0003A_1_pid, 1
0E26  D044      	BRA	label79
0EB0            label79

			#ifdef USB_DEBUG
				serial_print_str("****A\n");
0E28  0E2A      	MOVLW 0x2A
0E2A  6FE1      	MOVWF CompTempVar888, 1
0E2C  6FE2      	MOVWF CompTempVar888+D'1', 1
0E2E  6FE3      	MOVWF CompTempVar888+D'2', 1
0E30  6FE4      	MOVWF CompTempVar888+D'3', 1
0E32  0E41      	MOVLW 0x41
0E34  6FE5      	MOVWF CompTempVar888+D'4', 1
0E36  0E0A      	MOVLW 0x0A
0E38  6FE6      	MOVWF CompTempVar888+D'5', 1
0E3A  6BE7      	CLRF CompTempVar888+D'6', 1
0E3C  0E00      	MOVLW HIGH(CompTempVar888+D'0')
0E3E  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0E40  0EE1      	MOVLW LOW(CompTempVar888+D'0')
0E42  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0E44  EC86F000  	CALL serial_pri_00012

			#endif
			if (control_mode == cm_CTRL_READ_DATA_STAGE) {	
0E48  0E03      	MOVLW 0x03
0E4A  63D7      	CPFSEQ gbl_control_mode, 1
0E4C  D011      	BRA	label77
0E70            label77

				#ifdef USB_DEBUG
					serial_print_str(" &2 ");
0E4E  0E20      	MOVLW 0x20
0E50  6FE1      	MOVWF CompTempVar890, 1
0E52  6FE4      	MOVWF CompTempVar890+D'3', 1
0E54  0E26      	MOVLW 0x26
0E56  6FE2      	MOVWF CompTempVar890+D'1', 1
0E58  0E32      	MOVLW 0x32
0E5A  6FE3      	MOVWF CompTempVar890+D'2', 1
0E5C  6BE5      	CLRF CompTempVar890+D'4', 1
0E5E  0E00      	MOVLW HIGH(CompTempVar890+D'0')
0E60  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0E62  0EE1      	MOVLW LOW(CompTempVar890+D'0')
0E64  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0E66  EC86F000  	CALL serial_pri_00012

				#endif
				usb_send_data_chunk();
0E6A  ECEDF000  	CALL usb_send_d_0003D

			} else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS) {
0E70  0E04      	MOVLW 0x04
0E72  63D7      	CPFSEQ gbl_control_mode, 1
0E74  D003      	BRA	label78
0E7C            label78

				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_ctrl_read_callback();
0E76  EC51F004  	CALL usb_handle_00023

				#else
					nop(); // boostc bug
				#endif	
			} else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS) {
0E7C  0E06      	MOVLW 0x06
0E7E  63D7      	CPFSEQ gbl_control_mode, 1

				#ifdef USB_DEBUG
					serial_print_str(" st sent ");
0E82  0E20      	MOVLW 0x20
0E84  6FE1      	MOVWF CompTempVar892, 1
0E86  6FE4      	MOVWF CompTempVar892+D'3', 1
0E88  6FE9      	MOVWF CompTempVar892+D'8', 1
0E8A  0E65      	MOVLW 0x65
0E8C  6FE6      	MOVWF CompTempVar892+D'5', 1
0E8E  0E6E      	MOVLW 0x6E
0E90  6FE7      	MOVWF CompTempVar892+D'6', 1
0E92  0E73      	MOVLW 0x73
0E94  6FE2      	MOVWF CompTempVar892+D'1', 1
0E96  6FE5      	MOVWF CompTempVar892+D'4', 1
0E98  0E74      	MOVLW 0x74
0E9A  6FE3      	MOVWF CompTempVar892+D'2', 1
0E9C  6FE8      	MOVWF CompTempVar892+D'7', 1
0E9E  6BEA      	CLRF CompTempVar892+D'9', 1
0EA0  0E00      	MOVLW HIGH(CompTempVar892+D'0')
0EA2  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0EA4  0EE1      	MOVLW LOW(CompTempVar892+D'0')
0EA6  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0EA8  EC86F000  	CALL serial_pri_00012

				#endif
				control_mode = cm_IDLE;
0EAC  6BD7      	CLRF gbl_control_mode, 1

			}	
	
		} else if (pid == pid_OUT) {
0EB0  05E0      	DECF usb_handle_0003A_1_pid, W, 1
0EB2  E152      	BNZ	label84
0F58            label84

			// We've done an out
			//serial_print_str(" OUT ");
			if (control_mode == cm_CTRL_READ_AWAITING_STATUS) {
0EB4  0E05      	MOVLW 0x05
0EB6  63D7      	CPFSEQ gbl_control_mode, 1
0EB8  D012      	BRA	label80
0EDE            label80

				#ifdef USB_DEBUG
					serial_print_str(" ----\n");
0EBA  0E20      	MOVLW 0x20
0EBC  6FE1      	MOVWF CompTempVar894, 1
0EBE  0E2D      	MOVLW 0x2D
0EC0  6FE2      	MOVWF CompTempVar894+D'1', 1
0EC2  6FE3      	MOVWF CompTempVar894+D'2', 1
0EC4  6FE4      	MOVWF CompTempVar894+D'3', 1
0EC6  6FE5      	MOVWF CompTempVar894+D'4', 1
0EC8  0E0A      	MOVLW 0x0A
0ECA  6FE6      	MOVWF CompTempVar894+D'5', 1
0ECC  6BE7      	CLRF CompTempVar894+D'6', 1
0ECE  0E00      	MOVLW HIGH(CompTempVar894+D'0')
0ED0  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0ED2  0EE1      	MOVLW LOW(CompTempVar894+D'0')
0ED4  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0ED6  EC86F000  	CALL serial_pri_00012

				#endif
				control_mode = cm_IDLE;
0EDA  6BD7      	CLRF gbl_control_mode, 1

			} else if (control_mode == cm_CTRL_WRITE_DATA_STAGE_CLASS) {
0EDC  D03A      	BRA	label83
0EDE  0E02      	MOVLW 0x02
0EE0  63D7      	CPFSEQ gbl_control_mode, 1
0EE2  D00C      	BRA	label81
0EFC            label81

				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_ctrl_write_callback((uns8 *)&buffer_0_out, bd0out.count);
0EE4  0E05      	MOVLW HIGH(gbl_buffer_0_out+D'0')
0EE6  6FE2      	MOVWF usb_handle_00024_arg_data+D'1', 1
0EE8  0E00      	MOVLW LOW(gbl_buffer_0_out+D'0')
0EEA  6FE1      	MOVWF usb_handle_00024_arg_data, 1
0EEC  0104      	MOVLB 0x04
0EEE  5101      	MOVF gbl_bd0out+D'1', W, 1
0EF0  0100      	MOVLB 0x00
0EF2  6FE3      	MOVWF usb_handle_00024_arg_count, 1
0EF4  6BE4      	CLRF usb_handle_00024_arg_count+D'1', 1
0EF6  EC50F004  	CALL usb_handle_00024

					// !! should include bc bits here for total count
					// this only works for 8 bit data packets
				#else
					nop(); // boostc bug
				#endif	
			} else if (control_mode == cm_CTRL_READ_DATA_STAGE) {
0EFA  D02B      	BRA	label83
0EFC  0E03      	MOVLW 0x03
0EFE  63D7      	CPFSEQ gbl_control_mode, 1
0F00  D002      	BRA	label82
0F06            label82

				//serial_print_str(" Status early ");
				control_mode = cm_IDLE;
0F02  6BD7      	CLRF gbl_control_mode, 1

			} else {
0F04  D026      	BRA	label83
0F52            label83

			
				#ifdef USB_DEBUG
					serial_print_str("??unk pid_OUT ");
0F06  0E20      	MOVLW 0x20
0F08  6FE6      	MOVWF CompTempVar897+D'5', 1
0F0A  6FEE      	MOVWF CompTempVar897+D'13', 1
0F0C  0E3F      	MOVLW 0x3F
0F0E  6FE1      	MOVWF CompTempVar897, 1
0F10  6FE2      	MOVWF CompTempVar897+D'1', 1
0F12  0E4F      	MOVLW 0x4F
0F14  6FEB      	MOVWF CompTempVar897+D'10', 1
0F16  0E54      	MOVLW 0x54
0F18  6FED      	MOVWF CompTempVar897+D'12', 1
0F1A  0E55      	MOVLW 0x55
0F1C  6FEC      	MOVWF CompTempVar897+D'11', 1
0F1E  0E5F      	MOVLW 0x5F
0F20  6FEA      	MOVWF CompTempVar897+D'9', 1
0F22  0E64      	MOVLW 0x64
0F24  6FE9      	MOVWF CompTempVar897+D'8', 1
0F26  0E69      	MOVLW 0x69
0F28  6FE8      	MOVWF CompTempVar897+D'7', 1
0F2A  0E6B      	MOVLW 0x6B
0F2C  6FE5      	MOVWF CompTempVar897+D'4', 1
0F2E  0E6E      	MOVLW 0x6E
0F30  6FE4      	MOVWF CompTempVar897+D'3', 1
0F32  0E70      	MOVLW 0x70
0F34  6FE7      	MOVWF CompTempVar897+D'6', 1
0F36  0E75      	MOVLW 0x75
0F38  6FE3      	MOVWF CompTempVar897+D'2', 1
0F3A  6BEF      	CLRF CompTempVar897+D'14', 1
0F3C  0E00      	MOVLW HIGH(CompTempVar897+D'0')
0F3E  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0F40  0EE1      	MOVLW LOW(CompTempVar897+D'0')
0F42  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0F44  EC86F000  	CALL serial_pri_00012

					serial_print_int((uns8)control_mode);
0F48  51D7      	MOVF gbl_control_mode, W, 1
0F4A  6FFB      	MOVWF serial_pri_00014_arg_i, 1
0F4C  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
0F4E  EC60F001  	CALL serial_pri_00014

				#endif	
			}
			usb_prime_ep0_out();
0F52  EC56F003  	CALL usb_prime__00040

				
		} else {
			#ifdef USB_DEBUG
				serial_print_str(" UKPID = ");
0F58  0E20      	MOVLW 0x20
0F5A  6FE1      	MOVWF CompTempVar899, 1
0F5C  6FE7      	MOVWF CompTempVar899+D'6', 1
0F5E  6FE9      	MOVWF CompTempVar899+D'8', 1
0F60  0E3D      	MOVLW 0x3D
0F62  6FE8      	MOVWF CompTempVar899+D'7', 1
0F64  0E44      	MOVLW 0x44
0F66  6FE6      	MOVWF CompTempVar899+D'5', 1
0F68  0E49      	MOVLW 0x49
0F6A  6FE5      	MOVWF CompTempVar899+D'4', 1
0F6C  0E4B      	MOVLW 0x4B
0F6E  6FE3      	MOVWF CompTempVar899+D'2', 1
0F70  0E50      	MOVLW 0x50
0F72  6FE4      	MOVWF CompTempVar899+D'3', 1
0F74  0E55      	MOVLW 0x55
0F76  6FE2      	MOVWF CompTempVar899+D'1', 1
0F78  6BEA      	CLRF CompTempVar899+D'9', 1
0F7A  0E00      	MOVLW HIGH(CompTempVar899+D'0')
0F7C  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0F7E  0EE1      	MOVLW LOW(CompTempVar899+D'0')
0F80  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0F82  EC86F000  	CALL serial_pri_00012

				serial_print_int(pid);
0F86  51E0      	MOVF usb_handle_0003A_1_pid, W, 1
0F88  6FFB      	MOVWF serial_pri_00014_arg_i, 1
0F8A  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
0F8C  EC60F001  	CALL serial_pri_00014

			#endif	
		}

	} else {	// Not endpoint 0
		buffer_descriptor *bd;
		if (test_bit(ustat, DIR)) {
0F92  A46C      	BTFSS gbl_ustat,2
0F94  D002      	BRA	label86
0F9A            label86

			// in
			#ifdef USB_EP_DATA_CALLBACK
				bd = ep_in_bd_location[end_point];
				usb_ep_data_in_callback(end_point, bd->count);
			#else
				nop();
0F96  0000      	NOP

			#endif	
		} else { // out

			bd = ep_out_bd_location[end_point];
0F9A  EE00F0A6  	LFSR 0x00,  gbl_ep_out_bd_location
0F9E  50E9      	MOVF FSR0L, W
0FA0  51DF      	MOVF usb_handle_0003A_1_end_point, W, 1
0FA2  6FE3      	MOVWF CompTempVar903, 1
0FA4  90D8      	BCF STATUS,C
0FA6  35E3      	RLCF CompTempVar903, W, 1
0FA8  26E9      	ADDWF FSR0L, F
0FAA  50EE      	MOVF POSTINC0, W
0FAC  6FE1      	MOVWF usb_handle_0003A_181_bd, 1
0FAE  50EF      	MOVF INDF0, W
0FB0  6FE2      	MOVWF usb_handle_0003A_181_bd+D'1', 1

			// issue callback
			#ifdef USB_EP_DATA_CALLBACK
				usb_ep_data_out_callback(end_point, ep_out_buffer_location[end_point],
									bd->count);
			#endif						
			// re-prime endpoint
			bd->count = ep_out_buffer_size[end_point];
0FB2  EE00F0B6  	LFSR 0x00,  gbl_ep_out_buffer_size
0FB6  50E9      	MOVF FSR0L, W
0FB8  51DF      	MOVF usb_handle_0003A_1_end_point, W, 1
0FBA  6FE3      	MOVWF CompTempVar906, 1
0FBC  90D8      	BCF STATUS,C
0FBE  37E3      	RLCF CompTempVar906, F, 1
0FC0  51E3      	MOVF CompTempVar906, W, 1
0FC2  26E9      	ADDWF FSR0L, F
0FC4  50EE      	MOVF POSTINC0, W
0FC6  6FE4      	MOVWF CompTempVar908, 1
0FC8  50EF      	MOVF INDF0, W
0FCA  6FE5      	MOVWF CompTempVar908+D'1', 1
0FCC  51E2      	MOVF usb_handle_0003A_181_bd+D'1', W, 1
0FCE  6EEA      	MOVWF FSR0H
0FD0  29E1      	INCF usb_handle_0003A_181_bd, W, 1
0FD2  6EE9      	MOVWF FSR0L
0FD4  51E4      	MOVF CompTempVar908, W, 1
0FD6  6EEF      	MOVWF INDF0

			
			// Address shouldn't change, so don't need to update it

			clear_bit(bd->stat, DTS);	// turn on data togle sync TOGGLE
0FD8  06E9      	DECF FSR0L, F
0FDA  9CEF      	BCF INDF0,6

			clear_bit(bd->stat, KEN);	// clear the keep bit
0FDC  9AEF      	BCF INDF0,5

			clear_bit(bd->stat, INCDIS);	// clear the increment disable
0FDE  98EF      	BCF INDF0,4

			clear_bit(bd->stat, DTSEN);
0FE0  96EF      	BCF INDF0,3

			clear_bit(bd->stat, BSTALL);	// clear stall bit
0FE2  94EF      	BCF INDF0,2

			clear_bit(bd->stat, BC9);
0FE4  92EF      	BCF INDF0,1

			clear_bit(bd->stat, BC8);
0FE6  90EF      	BCF INDF0,0

			set_bit  (bd->stat, UOWN);	// SIE owns the buffer
0FE8  8EEF      	BSF INDF0,7

						
				
		}   
	}	
}
0CE8  0012      	RETURN
0D16  0012      	RETURN
0D4E  0012      	RETURN
0D58  0012      	RETURN
0DEA  0012      	RETURN
0E20  0012      	RETURN
0E6E  0012      	RETURN
0E7A  0012      	RETURN
0E80  0012      	RETURN
0EAE  0012      	RETURN
0F56  0012      	RETURN
0F90  0012      	RETURN
0F98  0012      	RETURN
0FEA  0012      	RETURN


void usb_handle_reset() {

	usb_address = 0;
09D4  0100      	MOVLB 0x00
09D6  6BD6      	CLRF gbl_usb_address, 1

	//uaddr = 0;
	
	control_mode = cm_IDLE;
09D8  6BD7      	CLRF gbl_control_mode, 1

	usb_status   = us_IDLE;
09DA  6BD9      	CLRF gbl_usb_status, 1

	
	// clear fifo
	clear_bit(uir, TRNIF);
09DC  9668      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
09DE  9668      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
09E0  9668      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
09E2  9668      	BCF gbl_uir,3

	
	// init buffers

	
	// EP0 OUT
	bd0out.count = 8;	// 8 byte buffer
09E4  0E08      	MOVLW 0x08
09E6  0104      	MOVLB 0x04
09E8  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out.addr = 0x0500;
09EA  6B02      	CLRF gbl_bd0out+D'2', 1
09EC  0E05      	MOVLW 0x05
09EE  6F03      	MOVWF gbl_bd0out+D'3', 1

	
	clear_bit(bd0out.stat, DTS);	// turn on data togle sync TOGGLE
09F0  9D00      	BCF gbl_bd0out,6, 1

	clear_bit(bd0out.stat, KEN);	// clear the keep bit
09F2  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out.stat, INCDIS);	// clear the increment disable
09F4  9900      	BCF gbl_bd0out,4, 1

	clear_bit  (bd0out.stat, DTSEN);	// !!!!!!
09F6  9700      	BCF gbl_bd0out,3, 1

	clear_bit(bd0out.stat, BSTALL);	// clear stall bit
09F8  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out.stat, BC9);
09FA  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out.stat, BC8);
09FC  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out.stat, UOWN);	// SIE owns the buffer
09FE  8F00      	BSF gbl_bd0out,7, 1

								// since we expect frist transaction to be SETUP
								
	// EP0 IN
	bd0in.count = 8;	// 8 byte buffer
0A00  0E08      	MOVLW 0x08
0A02  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in.addr = 0x0508;
0A04  6F06      	MOVWF gbl_bd0in+D'2', 1
0A06  0E05      	MOVLW 0x05
0A08  6F07      	MOVWF gbl_bd0in+D'3', 1

	clear_bit(bd0in.stat, DTS);	// turn on data togle sync TOGGLE
0A0A  9D04      	BCF gbl_bd0in,6, 1

	clear_bit(bd0in.stat, KEN);	// clear the keep bit
0A0C  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in.stat, INCDIS);	// clear the increment disable
0A0E  9904      	BCF gbl_bd0in,4, 1

	clear_bit(bd0in.stat, BSTALL);	// clear stall bit
0A10  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in.stat, BC9);
0A12  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in.stat, BC8);
0A14  9104      	BCF gbl_bd0in,0, 1

	
	clear_bit(bd0in.stat, UOWN);	// uC owns the buffer
0A16  9F04      	BCF gbl_bd0in,7, 1


	#ifdef USB_DEBUG
		serial_print_str("\nR ");
0A18  0E0A      	MOVLW 0x0A
0A1A  0100      	MOVLB 0x00
0A1C  6FDF      	MOVWF CompTempVar909, 1
0A1E  0E52      	MOVLW 0x52
0A20  6FE0      	MOVWF CompTempVar909+D'1', 1
0A22  0E20      	MOVLW 0x20
0A24  6FE1      	MOVWF CompTempVar909+D'2', 1
0A26  6BE2      	CLRF CompTempVar909+D'3', 1
0A28  0E00      	MOVLW HIGH(CompTempVar909+D'0')
0A2A  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0A2C  0EDF      	MOVLW LOW(CompTempVar909+D'0')
0A2E  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0A30  EC86F000  	CALL serial_pri_00012

		serial_print_int_hex(uir);
0A34  5068      	MOVF gbl_uir, W
0A36  6FF1      	MOVWF serial_pri_00015_arg_i, 1
0A38  EC36F003  	CALL serial_pri_00015

	#endif
}
0A3C  0012      	RETURN

	
void usb_handle_stall() {

	#ifdef USB_DEBUG
		serial_print_str(" U:Stall ");
09A2  0E20      	MOVLW 0x20
09A4  0100      	MOVLB 0x00
09A6  6FDF      	MOVWF CompTempVar911, 1
09A8  6FE7      	MOVWF CompTempVar911+D'8', 1
09AA  0E3A      	MOVLW 0x3A
09AC  6FE1      	MOVWF CompTempVar911+D'2', 1
09AE  0E53      	MOVLW 0x53
09B0  6FE2      	MOVWF CompTempVar911+D'3', 1
09B2  0E55      	MOVLW 0x55
09B4  6FE0      	MOVWF CompTempVar911+D'1', 1
09B6  0E61      	MOVLW 0x61
09B8  6FE4      	MOVWF CompTempVar911+D'5', 1
09BA  0E6C      	MOVLW 0x6C
09BC  6FE5      	MOVWF CompTempVar911+D'6', 1
09BE  6FE6      	MOVWF CompTempVar911+D'7', 1
09C0  0E74      	MOVLW 0x74
09C2  6FE3      	MOVWF CompTempVar911+D'4', 1
09C4  6BE8      	CLRF CompTempVar911+D'9', 1
09C6  0E00      	MOVLW HIGH(CompTempVar911+D'0')
09C8  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
09CA  0EDF      	MOVLW LOW(CompTempVar911+D'0')
09CC  6FFB      	MOVWF serial_pri_00012_arg_str, 1
09CE  EC86F000  	CALL serial_pri_00012

	#endif
}
09D2  0012      	RETURN




void usb_handle_isr() {

	
	if (test_bit(pir2, USBIF)) {
0FF4  AAA1      	BTFSS gbl_pir2,5

		clear_bit(pir2, USBIF);
0FF8  9AA1      	BCF gbl_pir2,5

		
		if (test_bit(uir, TRNIF)) {
0FFA  A668      	BTFSS gbl_uir,3
0FFC  D003      	BRA	label87
1004            label87

			usb_handle_transaction();
0FFE  EC1FF005  	CALL usb_handle_0003A

			clear_bit(uir, TRNIF);
1002  9668      	BCF gbl_uir,3

		}
		
		if (test_bit(uir, URSTIF)) {
1004  A068      	BTFSS gbl_uir,0
1006  D003      	BRA	label88
100E            label88

			usb_handle_reset();
1008  ECEAF004  	CALL usb_handle_0003B

			clear_bit(uir, URSTIF);
100C  9068      	BCF gbl_uir,0

		}	
		
		if (test_bit(uir, STALLIF)) {
100E  AA68      	BTFSS gbl_uir,5

			usb_handle_stall();
1012  ECD1F004  	CALL usb_handle_0003C

			clear_bit(uir, STALLIF);
1016  9A68      	BCF gbl_uir,5

		}
		#ifdef USB_CALLBACK_ON_SOF
			if (test_bit(uir, SOFIF)) {
				usb_SOF_callback(ufrm);	// sourceboost defines this
				clear_bit(uir, SOFIF);
			}
		#endif
	}
}
0FF6  0012      	RETURN
1010  0012      	RETURN
1018  0012      	RETURN


void turn_usb_ints_on() {
	
	set_bit(uie,  STALLIE);	// interrupt on stall
	set_bit(uie,  TRNIE);	//   on transaction complete
	set_bit(uie,  URSTIE);	//   on reset 
	set_bit(pie2, USBIE);	// general USB interrupts
	#ifdef USB_CALLBACK_ON_SOF 
		set_bit(uie, SOFIE);
	#endif	
}

void usb_setup() {

	usb_state = st_POWERED;
	
	// init hardware
	clear_bit(ucfg, UTRDIS);	// enable internal tranceiver
	set_bit  (ucfg, FSEN);	// clear for low speed, set for high speed
	set_bit  (ucfg, UPUEN);	// enable on-chip pull-ups

	clear_bit(ucfg, PPB1);	// disable double buffering for now
	clear_bit(ucfg, PPB0);	

	// if using ping pong buffers, need to do this:
	// set_bit(ucon, PPBRST);	// reset ping pong buffers to even
	// clear_bit(ucon, PPBRST);

	// init endpoint 0
		
	set_bit(uep0,   EPHSHK);	// EP0 handshaking on
	set_bit(uep0,   EPOUTEN);	// EP0 OUT enable 
	set_bit(uep0,   EPINEN); 	// EP0 IN enable 
	clear_bit(uep0, EPCONDIS);	// EP0 control transfers on (and IN and OUT)
	
	// init interrupts
	// Config buffer descriptor table

	ep_out_bd_location[0] = &bd0out;
	#if USB_HIGHEST_EP >= 1
		ep_out_bd_location[1] = &bd1out;
	#endif
	#if USB_HIGHEST_EP >= 2
		ep_out_bd_location[2] = &bd2out;
	#endif
	#if USB_HIGHEST_EP >= 3
		ep_out_bd_location[3] = &bd3out;
	#endif
	#if USB_HIGHEST_EP >= 4
		ep_out_bd_location[4] = &bd4out;
	#endif
	
	ep_in_bd_location[0] = &bd0in;
	#if USB_HIGHEST_EP >= 1
		ep_in_bd_location[1] = &bd1in;
	#endif
	#if USB_HIGHEST_EP >= 2
		ep_in_bd_location[2] = &bd2in;
	#endif
	#if USB_HIGHEST_EP >= 3
		ep_in_bd_location[3] = &bd3in;
	#endif
	#if USB_HIGHEST_EP >= 4
		ep_in_bd_location[4] = &bd4in;
	#endif


}
	
// enable usb module
void usb_enable_module() {
	uir = 0;
	set_bit(ucon, USBEN);	// enable USB serial interface engine (SIE)
	usb_state = st_DEFAULT;
}

usb_state_type usb_get_state() {
	return usb_state;
}	
}	
/*! \file pic_usb_buffer_mgt.c
    \brief Pic USB buffer routines

	Declarations of the buffer data structures for USB transfers
	
	Ian Harris 2008
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if it breaks, you get to keep both pieces" license.
    
   
*/

#include "pic_usb_buffer_mgt.h"

buffer_descriptor bd0out@0x400;
buffer_descriptor bd0in @0x404;
buffer_descriptor bd1out@0x408;
buffer_descriptor bd1in @0x40C;
buffer_descriptor bd2out@0x410;
buffer_descriptor bd2in @0x414;
buffer_descriptor bd3out@0x418;
buffer_descriptor bd3in @0x41c;
buffer_descriptor bd4out@0x420;
buffer_descriptor bd4in @0x424;
buffer_descriptor bd5out@0x428;
buffer_descriptor bd5in @0x42C;
buffer_descriptor bd6out@0x430;
buffer_descriptor bd6in @0x434;
buffer_descriptor bd7out@0x438;
buffer_descriptor bd7in @0x43C;

uns8 buffer_0_out[USB_EP0_OUT_SIZE]@ USB_EP0_OUT_ADDR;
uns8 buffer_0_in [USB_EP0_IN_SIZE] @ USB_EP0_IN_ADDR;

#ifdef USB_EP1_IN_SIZE
	uns8 buffer_1_in [USB_EP1_IN_SIZE] @USB_EP1_IN_ADDR;
#endif
#ifdef USB_EP1_OUT_SIZE
	uns8 buffer_1_out [USB_EP1_OUT_SIZE] @ USB_EP1_OUT_ADDR;
#endif
#ifdef USB_EP2_IN_SIZE
	uns8 buffer_2_in [USB_EP2_IN_SIZE] @ USB_EP2_IN_ADDR;
#endif
#ifdef USB_EP2_OUT_SIZE
	uns8 buffer_2_out [USB_EP2_OUT_SIZE] @ USB_EP2_OUT_ADDR;
#endif
#ifdef USB_EP3_IN_SIZE
	uns8 buffer_3_in [USB_EP3_IN_SIZE] @ USB_EP3_IN_ADDR;
#endif
#ifdef USB_EP3_OUT_SIZE
	uns8 buffer_3_out [USB_EP3_OUT_SIZE] @ USB_EP3_OUT_ADDR;
#endif

buffer_descriptor * ep_in_bd_location[USB_HIGHEST_EP + 1];
buffer_descriptor * ep_out_bd_location[USB_HIGHEST_EP + 1];

uns8 * ep_in_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0
	
	&buffer_0_in,	// ep 0 in buffer location
108A  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
108C  6FDB      	MOVWF CompGblVar105, 1
108E  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
1090  6FAA      	MOVWF gbl_ep_in_buffer_location, 1
1092  51DB      	MOVF CompGblVar105, W, 1
1094  6FAB      	MOVWF gbl_ep_in_buffer_location+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			&buffer_1_in,	// ep 1 in buffer location
1096  0E05      	MOVLW HIGH(gbl_buffer_1_in+D'0')
1098  6FDC      	MOVWF CompGblVar106, 1
109A  0E10      	MOVLW LOW(gbl_buffer_1_in+D'0')
109C  6FAC      	MOVWF gbl_ep_in_buffer_location+D'2', 1
109E  51DC      	MOVF CompGblVar106, W, 1
10A0  6FAD      	MOVWF gbl_ep_in_buffer_location+D'3', 1

		#else
			0,
		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			&buffer_2_in,	// ep 2 in buffer location
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			&buffer_3_in,	// ep 3 in buffer location
		#else
			0,
		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_IN_SIZE
			&buffer_4_in,	// ep 4 in buffer location
		#else
			0,
		#endif
	#endif	
};	   

uns8 * ep_out_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0
	
	&buffer_0_out,	// ep 0 in buffer location
10A2  0E05      	MOVLW HIGH(gbl_buffer_0_out+D'0')
10A4  6FDD      	MOVWF CompGblVar107, 1
10A6  0E00      	MOVLW LOW(gbl_buffer_0_out+D'0')
10A8  6FAE      	MOVWF gbl_ep_out_buffer_location, 1
10AA  51DD      	MOVF CompGblVar107, W, 1
10AC  6FAF      	MOVWF gbl_ep_out_buffer_location+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			&buffer_1_out,	// ep 1 in buffer location
		#else
			0,
10AE  6BB0      	CLRF gbl_ep_out_buffer_location+D'2', 1
10B0  6BB1      	CLRF gbl_ep_out_buffer_location+D'3', 1

		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			&buffer_2_out,	// ep 2 in buffer location
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			&buffer_3_out,	// ep 3 in buffer location
		#else
			0,
		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_OUT_SIZE
			&buffer_4_out,	// ep 4 in buffer location
		#else
			0,
		#endif
	#endif	
};	   


uns16 ep_in_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_IN_SIZE,
10B2  0E08      	MOVLW 0x08
10B4  6FB2      	MOVWF gbl_ep_in_buffer_size, 1
10B6  6BB3      	CLRF gbl_ep_in_buffer_size+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			USB_EP1_IN_SIZE,
10B8  0E08      	MOVLW 0x08
10BA  6FB4      	MOVWF gbl_ep_in_buffer_size+D'2', 1
10BC  6BB5      	CLRF gbl_ep_in_buffer_size+D'3', 1

		#else
			0,
		#endif
	#endif		

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			USB_EP2_IN_SIZE,
		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			USB_EP3_IN_SIZE,
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_IN_SIZE
			USB_EP4_IN_SIZE,
		#else
			0,
		#endif
	#endif		
};	



uns16 ep_out_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_OUT_SIZE,
10BE  0E08      	MOVLW 0x08
10C0  6FB6      	MOVWF gbl_ep_out_buffer_size, 1
10C2  6BB7      	CLRF gbl_ep_out_buffer_size+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			USB_EP1_OUT_SIZE,
		#else
			0,
10C4  6BB8      	CLRF gbl_ep_out_buffer_size+D'2', 1
10C6  6BB9      	CLRF gbl_ep_out_buffer_size+D'3', 1

		#endif
	#endif		

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			USB_EP2_OUT_SIZE,
		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			USB_EP3_OUT_SIZE,
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_OUT_SIZE
			USB_EP4_OUT_SIZE,
		#else
			0,
		#endif
	#endif		
};	

#include "pic_utils.h"


// Use shadowed ports to prevent read-before-write problems

// This is the one place the port_shadow variable actually gets declared

#if NUMBER_PORTS == 2
uns8 port_shadow[NUMBER_PORTS] = {0, 0};
#endif

#if NUMBER_PORTS == 3
uns8 port_shadow[NUMBER_PORTS] = {0, 0, 0};
#endif

#if NUMBER_PORTS == 4
uns8 port_shadow[NUMBER_PORTS] = {0, 0, 0, 0};
#endif

#if NUMBER_PORTS == 5
uns8 port_shadow[NUMBER_PORTS] = {0, 0, 0, 0, 0};
10C8  6A59      	CLRF gbl_port_shadow
10CA  6A5A      	CLRF gbl_port_shadow+D'1'
10CC  6A5B      	CLRF gbl_port_shadow+D'2'
10CE  6A5C      	CLRF gbl_port_shadow+D'3'
10D0  6A5D      	CLRF gbl_port_shadow+D'4'

#endif


void set_pin_var(uns8 port, uns8 pin) {
	uns8 array_location = port - PORTA;
	set_bit(port_shadow[array_location], pin); 
	port_array[array_location] = port_shadow[array_location]; 
}	

void clear_pin_var(uns8 port, uns8 pin) {
	uns8 array_location = port - PORTA;
	clear_bit(port_shadow[array_location], pin);
	port_array[array_location] = port_shadow[array_location]; 
}
	
void toggle_pin_var(uns8 port, uns8 pin) {
	uns8 array_location = port - PORTA;
    port_shadow[array_location] ^= (1 << (pin));
    port_array[array_location] = port_shadow[array_location]; 
}


void change_pin_var(uns8 port, uns8 pin, bit value) {
	uns8 array_location = port - PORTA;
	if (value) {
		set_bit(port_shadow[array_location], pin); 
	} else {
		clear_bit(port_shadow[array_location], pin);
	}
    port_array[array_location] = port_shadow[array_location]; 
}

  

//-----------------------------------------------------
// Pic Pack library
// 
// usb_config_mouse.c
//
// All the mouse specific USB code lives here
//
// Ian Harris 2008
// imharris [at] gmail.com
//
// Released under the "do whatever you like with this
// but if it breaks, you get to keep both pieces" license.
//-----------------------------------------------------

#include "pic_utils.h"
#include "pic_usb.h"
#include "pic_serial.h"


device_descriptor my_device_descriptor = {
	sizeof(my_device_descriptor), 	// 18 bytes long
10D2  0E12      	MOVLW 0x12
10D4  6F8C      	MOVWF gbl_my_device_descriptor, 1

	dt_DEVICE, 	// DEVICE 01h
10D6  0E01      	MOVLW 0x01
10D8  6F8D      	MOVWF gbl_my_device_descriptor+D'1', 1

	0x0110,	// usb version 1.10
10DA  0E10      	MOVLW 0x10
10DC  6F8E      	MOVWF gbl_my_device_descriptor+D'2', 1
10DE  0E01      	MOVLW 0x01
10E0  6F8F      	MOVWF gbl_my_device_descriptor+D'3', 1

	0,		// class
10E2  6B90      	CLRF gbl_my_device_descriptor+D'4', 1

	0,		// subclass
10E4  6B91      	CLRF gbl_my_device_descriptor+D'5', 1

	0,		// protocol
10E6  6B92      	CLRF gbl_my_device_descriptor+D'6', 1

	8,		// max packet size for end point 0
10E8  0E08      	MOVLW 0x08
10EA  6F93      	MOVWF gbl_my_device_descriptor+D'7', 1

	0x04d8,	// Microchip's vendor
10EC  0ED8      	MOVLW 0xD8
10EE  6F94      	MOVWF gbl_my_device_descriptor+D'8', 1
10F0  0E04      	MOVLW 0x04
10F2  6F95      	MOVWF gbl_my_device_descriptor+D'9', 1

	0x000C,	// Microchip's product 
10F4  0E0C      	MOVLW 0x0C
10F6  6F96      	MOVWF gbl_my_device_descriptor+D'10', 1
10F8  6B97      	CLRF gbl_my_device_descriptor+D'11', 1

	0x0200, // version 2.0 of the product
10FA  6B98      	CLRF gbl_my_device_descriptor+D'12', 1
10FC  0E02      	MOVLW 0x02
10FE  6F99      	MOVWF gbl_my_device_descriptor+D'13', 1

	1,		// string 1 for manufacturer
1100  0E01      	MOVLW 0x01
1102  6F9A      	MOVWF gbl_my_device_descriptor+D'14', 1

	2,		// string 2 for product
1104  0E02      	MOVLW 0x02
1106  6F9B      	MOVWF gbl_my_device_descriptor+D'15', 1

	0,		// string 3 for serial number
1108  6B9C      	CLRF gbl_my_device_descriptor+D'16', 1

	1		// number of configurations
110A  0E01      	MOVLW 0x01
110C  6F9D      	MOVWF gbl_my_device_descriptor+D'17', 1

};

const char mouse_report_descriptor[] = {
   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
110E  0E05      	MOVLW 0x05
1110  6E05      	MOVWF gbl_mouse_report_descriptor
1112  0E01      	MOVLW 0x01
1114  6E06      	MOVWF gbl_mouse_report_descriptor+D'1'

   0x09, 0x02,                    //  USAGE (Mouse)
1116  0E09      	MOVLW 0x09
1118  6E07      	MOVWF gbl_mouse_report_descriptor+D'2'
111A  0E02      	MOVLW 0x02
111C  6E08      	MOVWF gbl_mouse_report_descriptor+D'3'

   0xa1, 0x01,                    //  COLLECTION (Application)
111E  0EA1      	MOVLW 0xA1
1120  6E09      	MOVWF gbl_mouse_report_descriptor+D'4'
1122  0E01      	MOVLW 0x01
1124  6E0A      	MOVWF gbl_mouse_report_descriptor+D'5'

   0x09, 0x01,                    //  USAGE (Pointer)
1126  0E09      	MOVLW 0x09
1128  6E0B      	MOVWF gbl_mouse_report_descriptor+D'6'
112A  0E01      	MOVLW 0x01
112C  6E0C      	MOVWF gbl_mouse_report_descriptor+D'7'

   0xa1, 0x00,                    //  COLLECTION (Physical)
112E  0EA1      	MOVLW 0xA1
1130  6E0D      	MOVWF gbl_mouse_report_descriptor+D'8'
1132  6A0E      	CLRF gbl_mouse_report_descriptor+D'9'

   0x05, 0x09,                    //  USAGE_PAGE (Button)
1134  0E05      	MOVLW 0x05
1136  6E0F      	MOVWF gbl_mouse_report_descriptor+D'10'
1138  0E09      	MOVLW 0x09
113A  6E10      	MOVWF gbl_mouse_report_descriptor+D'11'

   0x19, 0x01,                    //  USAGE_MINIMUM (Button 1)
113C  0E19      	MOVLW 0x19
113E  6E11      	MOVWF gbl_mouse_report_descriptor+D'12'
1140  0E01      	MOVLW 0x01
1142  6E12      	MOVWF gbl_mouse_report_descriptor+D'13'

   0x29, 0x03,                    //  USAGE_MAXIMUM (Button 3)
1144  0E29      	MOVLW 0x29
1146  6E13      	MOVWF gbl_mouse_report_descriptor+D'14'
1148  0E03      	MOVLW 0x03
114A  6E14      	MOVWF gbl_mouse_report_descriptor+D'15'

   0x15, 0x00,                    //  LOGICAL_MINIMUM (0)
114C  0E15      	MOVLW 0x15
114E  6E15      	MOVWF gbl_mouse_report_descriptor+D'16'
1150  6A16      	CLRF gbl_mouse_report_descriptor+D'17'

   0x25, 0x01,                    //  LOGICAL_MAXIMUM (1)
1152  0E25      	MOVLW 0x25
1154  6E17      	MOVWF gbl_mouse_report_descriptor+D'18'
1156  0E01      	MOVLW 0x01
1158  6E18      	MOVWF gbl_mouse_report_descriptor+D'19'

   0x95, 0x03,                    //  REPORT_COUNT (3)
115A  0E95      	MOVLW 0x95
115C  6E19      	MOVWF gbl_mouse_report_descriptor+D'20'
115E  0E03      	MOVLW 0x03
1160  6E1A      	MOVWF gbl_mouse_report_descriptor+D'21'

   0x75, 0x01,                    //  REPORT_SIZE (1)
1162  0E75      	MOVLW 0x75
1164  6E1B      	MOVWF gbl_mouse_report_descriptor+D'22'
1166  0E01      	MOVLW 0x01
1168  6E1C      	MOVWF gbl_mouse_report_descriptor+D'23'

   0x81, 0x02,                    //  INPUT (Data,Var,Abs)
116A  0E81      	MOVLW 0x81
116C  6E1D      	MOVWF gbl_mouse_report_descriptor+D'24'
116E  0E02      	MOVLW 0x02
1170  6E1E      	MOVWF gbl_mouse_report_descriptor+D'25'

   0x95, 0x01,                    //  REPORT_COUNT (1)
1172  0E95      	MOVLW 0x95
1174  6E1F      	MOVWF gbl_mouse_report_descriptor+D'26'
1176  0E01      	MOVLW 0x01
1178  6E20      	MOVWF gbl_mouse_report_descriptor+D'27'

   0x75, 0x05,                    //  REPORT_SIZE (5)
117A  0E75      	MOVLW 0x75
117C  6E21      	MOVWF gbl_mouse_report_descriptor+D'28'
117E  0E05      	MOVLW 0x05
1180  6E22      	MOVWF gbl_mouse_report_descriptor+D'29'

   0x81, 0x01,                    //  INPUT (Cnst,Ary,Abs)
1182  0E81      	MOVLW 0x81
1184  6E23      	MOVWF gbl_mouse_report_descriptor+D'30'
1186  0E01      	MOVLW 0x01
1188  6E24      	MOVWF gbl_mouse_report_descriptor+D'31'

   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
118A  0E05      	MOVLW 0x05
118C  6E25      	MOVWF gbl_mouse_report_descriptor+D'32'
118E  0E01      	MOVLW 0x01
1190  6E26      	MOVWF gbl_mouse_report_descriptor+D'33'

   0x09, 0x30,                    //  USAGE (X)
1192  0E09      	MOVLW 0x09
1194  6E27      	MOVWF gbl_mouse_report_descriptor+D'34'
1196  0E30      	MOVLW 0x30
1198  6E28      	MOVWF gbl_mouse_report_descriptor+D'35'

   0x09, 0x31,                    //  USAGE (Y)
119A  0E09      	MOVLW 0x09
119C  6E29      	MOVWF gbl_mouse_report_descriptor+D'36'
119E  0E31      	MOVLW 0x31
11A0  6E2A      	MOVWF gbl_mouse_report_descriptor+D'37'

   0x15, 0x81,                    //  LOGICAL_MINIMUM (-127)
11A2  0E15      	MOVLW 0x15
11A4  6E2B      	MOVWF gbl_mouse_report_descriptor+D'38'
11A6  0E81      	MOVLW 0x81
11A8  6E2C      	MOVWF gbl_mouse_report_descriptor+D'39'

   0x25, 0x7f,                    //  LOGICAL_MAXIMUM (127)
11AA  0E25      	MOVLW 0x25
11AC  6E2D      	MOVWF gbl_mouse_report_descriptor+D'40'
11AE  0E7F      	MOVLW 0x7F
11B0  6E2E      	MOVWF gbl_mouse_report_descriptor+D'41'

   0x75, 0x08,                    //  REPORT_SIZE (8)
11B2  0E75      	MOVLW 0x75
11B4  6E2F      	MOVWF gbl_mouse_report_descriptor+D'42'
11B6  0E08      	MOVLW 0x08
11B8  6E30      	MOVWF gbl_mouse_report_descriptor+D'43'

   0x95, 0x02,                    //  REPORT_COUNT (2)
11BA  0E95      	MOVLW 0x95
11BC  6E31      	MOVWF gbl_mouse_report_descriptor+D'44'
11BE  0E02      	MOVLW 0x02
11C0  6E32      	MOVWF gbl_mouse_report_descriptor+D'45'

   0x81, 0x06,                    //  INPUT (Data,Var,Rel)
11C2  0E81      	MOVLW 0x81
11C4  6E33      	MOVWF gbl_mouse_report_descriptor+D'46'
11C6  0E06      	MOVLW 0x06
11C8  6E34      	MOVWF gbl_mouse_report_descriptor+D'47'

   0xc0,                          //  END_COLLECTION
11CA  0EC0      	MOVLW 0xC0
11CC  6E35      	MOVWF gbl_mouse_report_descriptor+D'48'

   0xc0                           //  END_COLLECTION
11CE  0EC0      	MOVLW 0xC0
11D0  6E36      	MOVWF gbl_mouse_report_descriptor+D'49'

};


struct  {
	configuration_descriptor my_config;
	interface_descriptor my_interface;
	hid_descriptor my_hid;
	endpoint_descriptor my_ep;
} complete_mouse_configuration = {
	{	// configuration descriptor - - - - - - - - - - 
		0x09,	// length,
11D2  0E09      	MOVLW 0x09
11D4  6E37      	MOVWF gbl_complete_mouse_configuration

		dt_CONFIGURATION,	// descriptor_type,
11D6  0E02      	MOVLW 0x02
11D8  6E38      	MOVWF gbl_complete_mouse_configuration+D'1'

		sizeof(complete_mouse_configuration),	// total_length;
11DA  0E22      	MOVLW 0x22
11DC  6E39      	MOVWF gbl_complete_mouse_configuration+D'2'
11DE  6A3A      	CLRF gbl_complete_mouse_configuration+D'3'

		0x01,	// num_interfaces,
11E0  0E01      	MOVLW 0x01
11E2  6E3B      	MOVWF gbl_complete_mouse_configuration+D'4'

		0x01,	// configuration_value,
11E4  0E01      	MOVLW 0x01
11E6  6E3C      	MOVWF gbl_complete_mouse_configuration+D'5'

		0x00,	// configuration_string_id,
11E8  6A3D      	CLRF gbl_complete_mouse_configuration+D'6'

		0b10000000, // attributes (bus powered, no remote wake up)
11EA  0E80      	MOVLW 0x80
11EC  6E3E      	MOVWF gbl_complete_mouse_configuration+D'7'

		100,	// max_power; (200ma)
11EE  0E64      	MOVLW 0x64
11F0  6E3F      	MOVWF gbl_complete_mouse_configuration+D'8'

	},
	{	// interface descriptor - - - - - - - - - - - -
		0x09,	// length,
11F2  0E09      	MOVLW 0x09
11F4  6E40      	MOVWF gbl_complete_mouse_configuration+D'9'

		dt_INTERFACE,	// descriptor_type,
11F6  0E04      	MOVLW 0x04
11F8  6E41      	MOVWF gbl_complete_mouse_configuration+D'10'

		0x00,	// interface_number, (starts at zero)
11FA  6A42      	CLRF gbl_complete_mouse_configuration+D'11'

		0x00,	// alternate_setting, (no alternatives)
11FC  6A43      	CLRF gbl_complete_mouse_configuration+D'12'

		0x01,	// num_endpoints,
11FE  0E01      	MOVLW 0x01
1200  6E44      	MOVWF gbl_complete_mouse_configuration+D'13'

		0x03,	// interface_class, (HID)
1202  0E03      	MOVLW 0x03
1204  6E45      	MOVWF gbl_complete_mouse_configuration+D'14'

		0x01,	// interface_subclass, (boot - is this necessary?)
1206  0E01      	MOVLW 0x01
1208  6E46      	MOVWF gbl_complete_mouse_configuration+D'15'

		0x02,	// interface_protocol, (mouse)
120A  0E02      	MOVLW 0x02
120C  6E47      	MOVWF gbl_complete_mouse_configuration+D'16'

		0x00,	// interface_string_id;
120E  6A48      	CLRF gbl_complete_mouse_configuration+D'17'

	},
	{	// hid descriptor - - - - - - - - - - - - - - -
		0x09,	// length,
1210  0E09      	MOVLW 0x09
1212  6E49      	MOVWF gbl_complete_mouse_configuration+D'18'

		dt_HID,	// descriptor_type;
1214  0E21      	MOVLW 0x21
1216  6E4A      	MOVWF gbl_complete_mouse_configuration+D'19'

		0x0110,	// hid_spec in BCD (1.10)
1218  0E10      	MOVLW 0x10
121A  6E4B      	MOVWF gbl_complete_mouse_configuration+D'20'
121C  0E01      	MOVLW 0x01
121E  6E4C      	MOVWF gbl_complete_mouse_configuration+D'21'

		0x00,	// country_code, (0=not country specific)
1220  6A4D      	CLRF gbl_complete_mouse_configuration+D'22'

		0x01,	// num_class_descriptors, (1)
1222  0E01      	MOVLW 0x01
1224  6E4E      	MOVWF gbl_complete_mouse_configuration+D'23'

		0x22,	// class_descriptor_type; (0x22 = report)
1226  0E22      	MOVLW 0x22
1228  6E4F      	MOVWF gbl_complete_mouse_configuration+D'24'

		sizeof(mouse_report_descriptor)	// class_descriptor_length; (report descriptor length)
122A  0E32      	MOVLW 0x32
122C  6E50      	MOVWF gbl_complete_mouse_configuration+D'25'
122E  6A51      	CLRF gbl_complete_mouse_configuration+D'26'

	},
	{	// endpoint descriptor - - - - - - - - - - - - -
		0x07,	// length,
1230  0E07      	MOVLW 0x07
1232  6E52      	MOVWF gbl_complete_mouse_configuration+D'27'

		dt_ENDPOINT,	// descriptor_type,
1234  0E05      	MOVLW 0x05
1236  6E53      	MOVWF gbl_complete_mouse_configuration+D'28'

		0b10000001,	// endpoint_address, (Endpoint 1, IN)
1238  0E81      	MOVLW 0x81
123A  6E54      	MOVWF gbl_complete_mouse_configuration+D'29'

		0b00000011,	// attributes; (Interrupt)
123C  0E03      	MOVLW 0x03
123E  6E55      	MOVWF gbl_complete_mouse_configuration+D'30'

		3,	// max_packet_size;
1240  0E03      	MOVLW 0x03
1242  6E56      	MOVWF gbl_complete_mouse_configuration+D'31'
1244  6A57      	CLRF gbl_complete_mouse_configuration+D'32'

		10,	// interval (10ms)
1246  0E0A      	MOVLW 0x0A
1248  6E58      	MOVWF gbl_complete_mouse_configuration+D'33'

	}	
};	
uns8 string_00 [] = 
	{
		4,	// length,
124A  0E04      	MOVLW 0x04
124C  6FBA      	MOVWF gbl_string_00, 1

		dt_STRING,	// descriptor type
124E  0E03      	MOVLW 0x03
1250  6FBB      	MOVWF gbl_string_00+D'1', 1

		9,	// magic for US english
1252  0E09      	MOVLW 0x09
1254  6FBC      	MOVWF gbl_string_00+D'2', 1

		4
1256  0E04      	MOVLW 0x04
1258  6FBD      	MOVWF gbl_string_00+D'3', 1

	};
uns8 string_01[] =
	{
		// string 0 (1) - Manufacturer
		24,	// length,
125A  0E18      	MOVLW 0x18
125C  6F60      	MOVWF gbl_string_01, 1

		dt_STRING,	// descriptor_type;
125E  0E03      	MOVLW 0x03
1260  6F61      	MOVWF gbl_string_01+D'1', 1

		
		'P', 0, 
1262  0E50      	MOVLW 0x50
1264  6F62      	MOVWF gbl_string_01+D'2', 1
1266  6B63      	CLRF gbl_string_01+D'3', 1

		'i', 0,
1268  0E69      	MOVLW 0x69
126A  6F64      	MOVWF gbl_string_01+D'4', 1
126C  6B65      	CLRF gbl_string_01+D'5', 1

		'c', 0,
126E  0E63      	MOVLW 0x63
1270  6F66      	MOVWF gbl_string_01+D'6', 1
1272  6B67      	CLRF gbl_string_01+D'7', 1

		'P', 0,
1274  0E50      	MOVLW 0x50
1276  6F68      	MOVWF gbl_string_01+D'8', 1
1278  6B69      	CLRF gbl_string_01+D'9', 1

		'a', 0,
127A  0E61      	MOVLW 0x61
127C  6F6A      	MOVWF gbl_string_01+D'10', 1
127E  6B6B      	CLRF gbl_string_01+D'11', 1

		'c', 0,
1280  0E63      	MOVLW 0x63
1282  6F6C      	MOVWF gbl_string_01+D'12', 1
1284  6B6D      	CLRF gbl_string_01+D'13', 1

		'k', 0,
1286  0E6B      	MOVLW 0x6B
1288  6F6E      	MOVWF gbl_string_01+D'14', 1
128A  6B6F      	CLRF gbl_string_01+D'15', 1

		' ', 0,
128C  0E20      	MOVLW 0x20
128E  6F70      	MOVWF gbl_string_01+D'16', 1
1290  6B71      	CLRF gbl_string_01+D'17', 1

		'I', 0,
1292  0E49      	MOVLW 0x49
1294  6F72      	MOVWF gbl_string_01+D'18', 1
1296  6B73      	CLRF gbl_string_01+D'19', 1

		'n', 0,
1298  0E6E      	MOVLW 0x6E
129A  6F74      	MOVWF gbl_string_01+D'20', 1
129C  6B75      	CLRF gbl_string_01+D'21', 1

		'c', 0
129E  0E63      	MOVLW 0x63
12A0  6F76      	MOVWF gbl_string_01+D'22', 1
12A2  6B77      	CLRF gbl_string_01+D'23', 1

	};
uns8 string_02[] =
	{	
		20, // length	
12A4  0E14      	MOVLW 0x14
12A6  6F78      	MOVWF gbl_string_02, 1

		dt_STRING,	// descriptory_type;
12A8  0E03      	MOVLW 0x03
12AA  6F79      	MOVWF gbl_string_02+D'1', 1

		'J', 0,
12AC  0E4A      	MOVLW 0x4A
12AE  6F7A      	MOVWF gbl_string_02+D'2', 1
12B0  6B7B      	CLRF gbl_string_02+D'3', 1

		'o', 0,
12B2  0E6F      	MOVLW 0x6F
12B4  6F7C      	MOVWF gbl_string_02+D'4', 1
12B6  6B7D      	CLRF gbl_string_02+D'5', 1

		'y', 0,
12B8  0E79      	MOVLW 0x79
12BA  6F7E      	MOVWF gbl_string_02+D'6', 1
12BC  6B7F      	CLRF gbl_string_02+D'7', 1

		'-', 0,
12BE  0E2D      	MOVLW 0x2D
12C0  6F80      	MOVWF gbl_string_02+D'8', 1
12C2  6B81      	CLRF gbl_string_02+D'9', 1

		'M', 0,
12C4  0E4D      	MOVLW 0x4D
12C6  6F82      	MOVWF gbl_string_02+D'10', 1
12C8  6B83      	CLRF gbl_string_02+D'11', 1

		'o', 0,
12CA  0E6F      	MOVLW 0x6F
12CC  6F84      	MOVWF gbl_string_02+D'12', 1
12CE  6B85      	CLRF gbl_string_02+D'13', 1

		'u', 0,
12D0  0E75      	MOVLW 0x75
12D2  6F86      	MOVWF gbl_string_02+D'14', 1
12D4  6B87      	CLRF gbl_string_02+D'15', 1

		's', 0,
12D6  0E73      	MOVLW 0x73
12D8  6F88      	MOVWF gbl_string_02+D'16', 1
12DA  6B89      	CLRF gbl_string_02+D'17', 1

		'e', 0,
12DC  0E65      	MOVLW 0x65
12DE  6F8A      	MOVWF gbl_string_02+D'18', 1
12E0  6B8B      	CLRF gbl_string_02+D'19', 1

	};


void usb_get_descriptor_callback(uns8 descriptor_type, uns8 descriptor_num,

                                 uns8 **rtn_descriptor_ptr, uns16 *rtn_descriptor_size) {
	
	uns8 *descriptor_ptr;
	uns16 descriptor_size;
	
	descriptor_ptr = (uns8 *) 0;	// this means we didn't find it
03C8  6BF7      	CLRF usb_get_de_00025_1_descrip_00048, 1
03CA  6BF8      	CLRF usb_get_de_00025_1_descrip_00048+D'1', 1

	switch (descriptor_type) {
05E0            label37

		case dt_DEVICE:
03CC  05F1      	DECF usb_get_de_00025_arg_descr_00026, W, 1
03CE  E010      	BZ	label28
03F0            label28
0686            label39
06A6            label41

			serial_print_str(" Device ");
03F0  0E20      	MOVLW 0x20
03F2  0102      	MOVLB 0x02
03F4  6F00      	MOVWF CompTempVar991, 1
03F6  6F07      	MOVWF CompTempVar991+D'7', 1
03F8  0E44      	MOVLW 0x44
03FA  6F01      	MOVWF CompTempVar991+D'1', 1
03FC  0E63      	MOVLW 0x63
03FE  6F05      	MOVWF CompTempVar991+D'5', 1
0400  0E65      	MOVLW 0x65
0402  6F02      	MOVWF CompTempVar991+D'2', 1
0404  6F06      	MOVWF CompTempVar991+D'6', 1
0406  0E69      	MOVLW 0x69
0408  6F04      	MOVWF CompTempVar991+D'4', 1
040A  0E76      	MOVLW 0x76
040C  6F03      	MOVWF CompTempVar991+D'3', 1
040E  6B08      	CLRF CompTempVar991+D'8', 1
0410  0E02      	MOVLW HIGH(CompTempVar991+D'0')
0412  0100      	MOVLB 0x00
0414  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0416  0E00      	MOVLW LOW(CompTempVar991+D'0')
0418  6FFB      	MOVWF serial_pri_00012_arg_str, 1
041A  EC86F000  	CALL serial_pri_00012

			descriptor_ptr = (uns8 *)&my_device_descriptor;
041E  0E00      	MOVLW HIGH(gbl_my_device_descriptor+D'0')
0420  6FFB      	MOVWF CompTempVar993, 1
0422  0E8C      	MOVLW LOW(gbl_my_device_descriptor+D'0')
0424  6FF7      	MOVWF usb_get_de_00025_1_descrip_00048, 1
0426  51FB      	MOVF CompTempVar993, W, 1
0428  6FF8      	MOVWF usb_get_de_00025_1_descrip_00048+D'1', 1

			descriptor_size = sizeof(my_device_descriptor);
042A  0E12      	MOVLW 0x12
042C  6FF9      	MOVWF usb_get_de_00025_1_descrip_00049, 1
042E  6BFA      	CLRF usb_get_de_00025_1_descrip_00049+D'1', 1

			break;
0430  D0D7      	BRA	label37

		case dt_CONFIGURATION:
03D0  0E02      	MOVLW 0x02
03D2  63F1      	CPFSEQ usb_get_de_00025_arg_descr_00026, 1
03D4  D001      	BRA	label25
03D6  D02D      	BRA	label29
03D8            label25
03EE  D0BA      	BRA	label35
0432            label29
04C2  D014      	BRA	label33

			serial_print_str(" Config ");
0432  0E20      	MOVLW 0x20
0434  0102      	MOVLB 0x02
0436  6F00      	MOVWF CompTempVar994, 1
0438  6F07      	MOVWF CompTempVar994+D'7', 1
043A  0E43      	MOVLW 0x43
043C  6F01      	MOVWF CompTempVar994+D'1', 1
043E  0E66      	MOVLW 0x66
0440  6F04      	MOVWF CompTempVar994+D'4', 1
0442  0E67      	MOVLW 0x67
0444  6F06      	MOVWF CompTempVar994+D'6', 1
0446  0E69      	MOVLW 0x69
0448  6F05      	MOVWF CompTempVar994+D'5', 1
044A  0E6E      	MOVLW 0x6E
044C  6F03      	MOVWF CompTempVar994+D'3', 1
044E  0E6F      	MOVLW 0x6F
0450  6F02      	MOVWF CompTempVar994+D'2', 1
0452  6B08      	CLRF CompTempVar994+D'8', 1
0454  0E02      	MOVLW HIGH(CompTempVar994+D'0')
0456  0100      	MOVLB 0x00
0458  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
045A  0E00      	MOVLW LOW(CompTempVar994+D'0')
045C  6FFB      	MOVWF serial_pri_00012_arg_str, 1
045E  EC86F000  	CALL serial_pri_00012

			descriptor_ptr = (uns8 *) &complete_mouse_configuration;
0462  0E00      	MOVLW HIGH(gbl_complete_mouse_configuration+D'0')
0464  6FFB      	MOVWF CompTempVar996, 1
0466  0E37      	MOVLW LOW(gbl_complete_mouse_configuration+D'0')
0468  6FF7      	MOVWF usb_get_de_00025_1_descrip_00048, 1
046A  51FB      	MOVF CompTempVar996, W, 1
046C  6FF8      	MOVWF usb_get_de_00025_1_descrip_00048+D'1', 1

			descriptor_size = sizeof(complete_mouse_configuration);
046E  0E22      	MOVLW 0x22
0470  6FF9      	MOVWF usb_get_de_00025_1_descrip_00049, 1
0472  6BFA      	CLRF usb_get_de_00025_1_descrip_00049+D'1', 1

			break;
0474  D0B5      	BRA	label37

		case dt_STRING:
03D8  0E03      	MOVLW 0x03
03DA  63F1      	CPFSEQ usb_get_de_00025_arg_descr_00026, 1
03DC  D001      	BRA	label26
03DE  D04B      	BRA	label30
03E0            label26
0476            label30

			serial_print_str(" String: ");
0476  0E20      	MOVLW 0x20
0478  0102      	MOVLB 0x02
047A  6F00      	MOVWF CompTempVar997, 1
047C  6F08      	MOVWF CompTempVar997+D'8', 1
047E  0E3A      	MOVLW 0x3A
0480  6F07      	MOVWF CompTempVar997+D'7', 1
0482  0E53      	MOVLW 0x53
0484  6F01      	MOVWF CompTempVar997+D'1', 1
0486  0E67      	MOVLW 0x67
0488  6F06      	MOVWF CompTempVar997+D'6', 1
048A  0E69      	MOVLW 0x69
048C  6F04      	MOVWF CompTempVar997+D'4', 1
048E  0E6E      	MOVLW 0x6E
0490  6F05      	MOVWF CompTempVar997+D'5', 1
0492  0E72      	MOVLW 0x72
0494  6F03      	MOVWF CompTempVar997+D'3', 1
0496  0E74      	MOVLW 0x74
0498  6F02      	MOVWF CompTempVar997+D'2', 1
049A  6B09      	CLRF CompTempVar997+D'9', 1
049C  0E02      	MOVLW HIGH(CompTempVar997+D'0')
049E  0100      	MOVLB 0x00
04A0  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
04A2  0E00      	MOVLW LOW(CompTempVar997+D'0')
04A4  6FFB      	MOVWF serial_pri_00012_arg_str, 1
04A6  EC86F000  	CALL serial_pri_00012

			serial_print_int(descriptor_num);
04AA  51F2      	MOVF usb_get_de_00025_arg_descr_00027, W, 1
04AC  6FFB      	MOVWF serial_pri_00014_arg_i, 1
04AE  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
04B0  EC60F001  	CALL serial_pri_00014

			switch (descriptor_num) {
				case 00: 
04B4  53F2      	MOVF usb_get_de_00025_arg_descr_00027, F, 1
04B6  E006      	BZ	label31
04C4            label31

					descriptor_size = sizeof(string_00);
04C4  0E04      	MOVLW 0x04
04C6  6FF9      	MOVWF usb_get_de_00025_1_descrip_00049, 1
04C8  6BFA      	CLRF usb_get_de_00025_1_descrip_00049+D'1', 1

					descriptor_ptr = string_00;
04CA  0E00      	MOVLW HIGH(gbl_string_00+D'0')
04CC  6FFB      	MOVWF CompTempVar999, 1
04CE  0EBA      	MOVLW LOW(gbl_string_00+D'0')
04D0  6FF7      	MOVWF usb_get_de_00025_1_descrip_00048, 1
04D2  51FB      	MOVF CompTempVar999, W, 1
04D4  6FF8      	MOVWF usb_get_de_00025_1_descrip_00048+D'1', 1

					break;
04D6  D084      	BRA	label37

				case 01: 
04B8  05F2      	DECF usb_get_de_00025_arg_descr_00027, W, 1
04BA  E00E      	BZ	label32
04D8            label32

					descriptor_size = sizeof(string_01);
04D8  0E18      	MOVLW 0x18
04DA  6FF9      	MOVWF usb_get_de_00025_1_descrip_00049, 1
04DC  6BFA      	CLRF usb_get_de_00025_1_descrip_00049+D'1', 1

					descriptor_ptr = string_01;
04DE  0E00      	MOVLW HIGH(gbl_string_01+D'0')
04E0  6FFB      	MOVWF CompTempVar1000, 1
04E2  0E60      	MOVLW LOW(gbl_string_01+D'0')
04E4  6FF7      	MOVWF usb_get_de_00025_1_descrip_00048, 1
04E6  51FB      	MOVF CompTempVar1000, W, 1
04E8  6FF8      	MOVWF usb_get_de_00025_1_descrip_00048+D'1', 1

					break;
04EA  D07A      	BRA	label37

				case 02: 
04BC  0E02      	MOVLW 0x02
04BE  63F2      	CPFSEQ usb_get_de_00025_arg_descr_00027, 1
04C0  D08F      	BRA	label37
04EC            label33

					descriptor_size = sizeof(string_02);
04EC  0E14      	MOVLW 0x14
04EE  6FF9      	MOVWF usb_get_de_00025_1_descrip_00049, 1
04F0  6BFA      	CLRF usb_get_de_00025_1_descrip_00049+D'1', 1

					descriptor_ptr = string_02;
04F2  0E00      	MOVLW HIGH(gbl_string_02+D'0')
04F4  6FFB      	MOVWF CompTempVar1001, 1
04F6  0E78      	MOVLW LOW(gbl_string_02+D'0')
04F8  6FF7      	MOVWF usb_get_de_00025_1_descrip_00048, 1
04FA  51FB      	MOVF CompTempVar1001, W, 1
04FC  6FF8      	MOVWF usb_get_de_00025_1_descrip_00048+D'1', 1

					break;
					
			}		
			break;
04FE  D070      	BRA	label37

		case dt_DEVICE_QUALIFIER:
03E0  0E06      	MOVLW 0x06
03E2  63F1      	CPFSEQ usb_get_de_00025_arg_descr_00026, 1
03E4  D001      	BRA	label27
03E6  D08C      	BRA	label34
03E8            label27
0500            label34

			serial_print_str(" Device Qual (unhandled) ");
0500  0E20      	MOVLW 0x20
0502  0102      	MOVLB 0x02
0504  6F00      	MOVWF CompTempVar1002, 1
0506  6F07      	MOVWF CompTempVar1002+D'7', 1
0508  6F0C      	MOVWF CompTempVar1002+D'12', 1
050A  6F18      	MOVWF CompTempVar1002+D'24', 1
050C  0E28      	MOVLW 0x28
050E  6F0D      	MOVWF CompTempVar1002+D'13', 1
0510  0E29      	MOVLW 0x29
0512  6F17      	MOVWF CompTempVar1002+D'23', 1
0514  0E44      	MOVLW 0x44
0516  6F01      	MOVWF CompTempVar1002+D'1', 1
0518  0E51      	MOVLW 0x51
051A  6F08      	MOVWF CompTempVar1002+D'8', 1
051C  0E61      	MOVLW 0x61
051E  6F0A      	MOVWF CompTempVar1002+D'10', 1
0520  6F11      	MOVWF CompTempVar1002+D'17', 1
0522  0E63      	MOVLW 0x63
0524  6F05      	MOVWF CompTempVar1002+D'5', 1
0526  0E64      	MOVLW 0x64
0528  6F13      	MOVWF CompTempVar1002+D'19', 1
052A  6F16      	MOVWF CompTempVar1002+D'22', 1
052C  0E65      	MOVLW 0x65
052E  6F02      	MOVWF CompTempVar1002+D'2', 1
0530  6F06      	MOVWF CompTempVar1002+D'6', 1
0532  6F15      	MOVWF CompTempVar1002+D'21', 1
0534  0E68      	MOVLW 0x68
0536  6F10      	MOVWF CompTempVar1002+D'16', 1
0538  0E69      	MOVLW 0x69
053A  6F04      	MOVWF CompTempVar1002+D'4', 1
053C  0E6C      	MOVLW 0x6C
053E  6F0B      	MOVWF CompTempVar1002+D'11', 1
0540  6F14      	MOVWF CompTempVar1002+D'20', 1
0542  0E6E      	MOVLW 0x6E
0544  6F0F      	MOVWF CompTempVar1002+D'15', 1
0546  6F12      	MOVWF CompTempVar1002+D'18', 1
0548  0E75      	MOVLW 0x75
054A  6F09      	MOVWF CompTempVar1002+D'9', 1
054C  6F0E      	MOVWF CompTempVar1002+D'14', 1
054E  0E76      	MOVLW 0x76
0550  6F03      	MOVWF CompTempVar1002+D'3', 1
0552  6B19      	CLRF CompTempVar1002+D'25', 1
0554  0E02      	MOVLW HIGH(CompTempVar1002+D'0')
0556  0100      	MOVLB 0x00
0558  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
055A  0E00      	MOVLW LOW(CompTempVar1002+D'0')
055C  6FFB      	MOVWF serial_pri_00012_arg_str, 1
055E  EC86F000  	CALL serial_pri_00012

			// we don't handle this, send a stall
			break;
0562  D03E      	BRA	label37

		case dt_HID_REPORT:
03E8  0E22      	MOVLW 0x22
03EA  63F1      	CPFSEQ usb_get_de_00025_arg_descr_00026, 1
03EC  D0E4      	BRA	label36
0564            label35

			serial_print_str(" HID Report ");
0564  0E20      	MOVLW 0x20
0566  0102      	MOVLB 0x02
0568  6F00      	MOVWF CompTempVar1004, 1
056A  6F04      	MOVWF CompTempVar1004+D'4', 1
056C  6F0B      	MOVWF CompTempVar1004+D'11', 1
056E  0E44      	MOVLW 0x44
0570  6F03      	MOVWF CompTempVar1004+D'3', 1
0572  0E48      	MOVLW 0x48
0574  6F01      	MOVWF CompTempVar1004+D'1', 1
0576  0E49      	MOVLW 0x49
0578  6F02      	MOVWF CompTempVar1004+D'2', 1
057A  0E52      	MOVLW 0x52
057C  6F05      	MOVWF CompTempVar1004+D'5', 1
057E  0E65      	MOVLW 0x65
0580  6F06      	MOVWF CompTempVar1004+D'6', 1
0582  0E6F      	MOVLW 0x6F
0584  6F08      	MOVWF CompTempVar1004+D'8', 1
0586  0E70      	MOVLW 0x70
0588  6F07      	MOVWF CompTempVar1004+D'7', 1
058A  0E72      	MOVLW 0x72
058C  6F09      	MOVWF CompTempVar1004+D'9', 1
058E  0E74      	MOVLW 0x74
0590  6F0A      	MOVWF CompTempVar1004+D'10', 1
0592  6B0C      	CLRF CompTempVar1004+D'12', 1
0594  0E02      	MOVLW HIGH(CompTempVar1004+D'0')
0596  0100      	MOVLB 0x00
0598  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
059A  0E00      	MOVLW LOW(CompTempVar1004+D'0')
059C  6FFB      	MOVWF serial_pri_00012_arg_str, 1
059E  EC86F000  	CALL serial_pri_00012

			descriptor_size = sizeof(mouse_report_descriptor);
05A2  0E32      	MOVLW 0x32
05A4  6FF9      	MOVWF usb_get_de_00025_1_descrip_00049, 1
05A6  6BFA      	CLRF usb_get_de_00025_1_descrip_00049+D'1', 1

			descriptor_ptr = (uns8 *) &mouse_report_descriptor;
05A8  0E00      	MOVLW HIGH(gbl_mouse_report_descriptor+D'0')
05AA  6FFB      	MOVWF CompTempVar1006, 1
05AC  0E05      	MOVLW LOW(gbl_mouse_report_descriptor+D'0')
05AE  6FF7      	MOVWF usb_get_de_00025_1_descrip_00048, 1
05B0  51FB      	MOVF CompTempVar1006, W, 1
05B2  6FF8      	MOVWF usb_get_de_00025_1_descrip_00048+D'1', 1

			break;
05B4  D015      	BRA	label37

		default:
05B6            label36

			serial_print_str("?? ");
05B6  0E3F      	MOVLW 0x3F
05B8  0102      	MOVLB 0x02
05BA  6F00      	MOVWF CompTempVar1007, 1
05BC  6F01      	MOVWF CompTempVar1007+D'1', 1
05BE  0E20      	MOVLW 0x20
05C0  6F02      	MOVWF CompTempVar1007+D'2', 1
05C2  6B03      	CLRF CompTempVar1007+D'3', 1
05C4  0E02      	MOVLW HIGH(CompTempVar1007+D'0')
05C6  0100      	MOVLB 0x00
05C8  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
05CA  0E00      	MOVLW LOW(CompTempVar1007+D'0')
05CC  6FFB      	MOVWF serial_pri_00012_arg_str, 1
05CE  EC86F000  	CALL serial_pri_00012

			serial_print_int(descriptor_type);
05D2  51F1      	MOVF usb_get_de_00025_arg_descr_00026, W, 1
05D4  6FFB      	MOVWF serial_pri_00014_arg_i, 1
05D6  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
05D8  EC60F001  	CALL serial_pri_00014

			serial_print_spc();
05DC  EC5AF001  	CALL serial_pri_00018

			
	}
	*rtn_descriptor_ptr = descriptor_ptr;
05E0  0100      	MOVLB 0x00
05E2  51F4      	MOVF usb_get_de_00025_arg_rtn_d_00028+D'1', W, 1
05E4  6EEA      	MOVWF FSR0H
05E6  51F3      	MOVF usb_get_de_00025_arg_rtn_d_00028, W, 1
05E8  6EE9      	MOVWF FSR0L
05EA  2AE9      	INCF FSR0L, F
05EC  51F7      	MOVF usb_get_de_00025_1_descrip_00048, W, 1
05EE  6FFB      	MOVWF CompTempVar1009, 1
05F0  51F8      	MOVF usb_get_de_00025_1_descrip_00048+D'1', W, 1
05F2  6EEF      	MOVWF INDF0
05F4  06E9      	DECF FSR0L, F
05F6  51FB      	MOVF CompTempVar1009, W, 1
05F8  6EEF      	MOVWF INDF0

	*rtn_descriptor_size = descriptor_size;		
05FA  51F6      	MOVF usb_get_de_00025_arg_rtn_d_00029+D'1', W, 1
05FC  6EEA      	MOVWF FSR0H
05FE  51F5      	MOVF usb_get_de_00025_arg_rtn_d_00029, W, 1
0600  6EE9      	MOVWF FSR0L
0602  2AE9      	INCF FSR0L, F
0604  51F9      	MOVF usb_get_de_00025_1_descrip_00049, W, 1
0606  6FFB      	MOVWF CompTempVar1010, 1
0608  51FA      	MOVF usb_get_de_00025_1_descrip_00049+D'1', W, 1
060A  6EEF      	MOVWF INDF0
060C  06E9      	DECF FSR0L, F
060E  51FB      	MOVF CompTempVar1010, W, 1
0610  6EEF      	MOVWF INDF0

}
0612  0012      	RETURN




/*! \file usb_hid_class.c
    \brief Pic Human Interface Device USB routines

	Human Interface Device USB routines

	Ian Harris 2008
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if it breaks, you get to keep both pieces" license
    
   
*/

#include "config.h"

// PicPack includes
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"
#include "pic_serial.h"

// local includes
#include "usb_hid_class.h"

// system includes
#include "memory.h"


void usb_handle_class_ctrl_read_callback() {

}	
08A2  0012      	RETURN


void usb_handle_class_ctrl_write_callback(uns8 *data, uns16 count) {

}
08A0  0012      	RETURN


void usb_handle_class_request_callback(setup_data_packet sdp) {

	serial_print_str("Class request: ");
08A4  0E20      	MOVLW 0x20
08A6  0102      	MOVLB 0x02
08A8  6F05      	MOVWF CompTempVar1011+D'5', 1
08AA  6F0E      	MOVWF CompTempVar1011+D'14', 1
08AC  0E3A      	MOVLW 0x3A
08AE  6F0D      	MOVWF CompTempVar1011+D'13', 1
08B0  0E43      	MOVLW 0x43
08B2  6F00      	MOVWF CompTempVar1011, 1
08B4  0E61      	MOVLW 0x61
08B6  6F02      	MOVWF CompTempVar1011+D'2', 1
08B8  0E65      	MOVLW 0x65
08BA  6F07      	MOVWF CompTempVar1011+D'7', 1
08BC  6F0A      	MOVWF CompTempVar1011+D'10', 1
08BE  0E6C      	MOVLW 0x6C
08C0  6F01      	MOVWF CompTempVar1011+D'1', 1
08C2  0E71      	MOVLW 0x71
08C4  6F08      	MOVWF CompTempVar1011+D'8', 1
08C6  0E72      	MOVLW 0x72
08C8  6F06      	MOVWF CompTempVar1011+D'6', 1
08CA  0E73      	MOVLW 0x73
08CC  6F03      	MOVWF CompTempVar1011+D'3', 1
08CE  6F04      	MOVWF CompTempVar1011+D'4', 1
08D0  6F0B      	MOVWF CompTempVar1011+D'11', 1
08D2  0E74      	MOVLW 0x74
08D4  6F0C      	MOVWF CompTempVar1011+D'12', 1
08D6  0E75      	MOVLW 0x75
08D8  6F09      	MOVWF CompTempVar1011+D'9', 1
08DA  6B0F      	CLRF CompTempVar1011+D'15', 1
08DC  0E02      	MOVLW HIGH(CompTempVar1011+D'0')
08DE  0100      	MOVLB 0x00
08E0  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
08E2  0E00      	MOVLW LOW(CompTempVar1011+D'0')
08E4  6FFB      	MOVWF serial_pri_00012_arg_str, 1
08E6  EC86F000  	CALL serial_pri_00012

	serial_print_int(sdp.bRequest);
08EA  51E5      	MOVF usb_handle_00022_arg_sdp+D'1', W, 1
08EC  6FFB      	MOVWF serial_pri_00014_arg_i, 1
08EE  6BFC      	CLRF serial_pri_00014_arg_i+D'1', 1
08F0  EC60F001  	CALL serial_pri_00014

	
	switch(sdp.bRequest) {
		case req_GET_REPORT:
08F4  05E5      	DECF usb_handle_00022_arg_sdp+D'1', W, 1
08F6  B4D8      	BTFSC STATUS,Z

			break;
		case req_GET_IDLE:
08FA  0E02      	MOVLW 0x02
08FC  63E5      	CPFSEQ usb_handle_00022_arg_sdp+D'1', 1
08FE  D001      	BRA	label54
0902            label54

			break;
		case req_GET_PROTOCOL:
0902  0E03      	MOVLW 0x03
0904  63E5      	CPFSEQ usb_handle_00022_arg_sdp+D'1', 1
0906  D001      	BRA	label55
090A            label55

			break;
		case req_SET_REPORT:
090A  0E09      	MOVLW 0x09
090C  63E5      	CPFSEQ usb_handle_00022_arg_sdp+D'1', 1
090E  D001      	BRA	label56
0912            label56

			break;
		case req_SET_IDLE:
0912  0E0A      	MOVLW 0x0A
0914  63E5      	CPFSEQ usb_handle_00022_arg_sdp+D'1', 1
0916  D001      	BRA	label57
0918  D004      	BRA	label58
091A            label57
0922            label58

			serial_print_str(" Set_idle ");
0922  0E20      	MOVLW 0x20
0924  0102      	MOVLB 0x02
0926  6F00      	MOVWF CompTempVar1013, 1
0928  6F09      	MOVWF CompTempVar1013+D'9', 1
092A  0E53      	MOVLW 0x53
092C  6F01      	MOVWF CompTempVar1013+D'1', 1
092E  0E5F      	MOVLW 0x5F
0930  6F04      	MOVWF CompTempVar1013+D'4', 1
0932  0E64      	MOVLW 0x64
0934  6F06      	MOVWF CompTempVar1013+D'6', 1
0936  0E65      	MOVLW 0x65
0938  6F02      	MOVWF CompTempVar1013+D'2', 1
093A  6F08      	MOVWF CompTempVar1013+D'8', 1
093C  0E69      	MOVLW 0x69
093E  6F05      	MOVWF CompTempVar1013+D'5', 1
0940  0E6C      	MOVLW 0x6C
0942  6F07      	MOVWF CompTempVar1013+D'7', 1
0944  0E74      	MOVLW 0x74
0946  6F03      	MOVWF CompTempVar1013+D'3', 1
0948  6B0A      	CLRF CompTempVar1013+D'10', 1
094A  0E02      	MOVLW HIGH(CompTempVar1013+D'0')
094C  0100      	MOVLB 0x00
094E  6FFC      	MOVWF serial_pri_00012_arg_str+D'1', 1
0950  0E00      	MOVLW LOW(CompTempVar1013+D'0')
0952  6FFB      	MOVWF serial_pri_00012_arg_str, 1
0954  EC86F000  	CALL serial_pri_00012

			// we don't support whatever they want
			usb_stall_ep0();
0958  ECAAF001  	CALL usb_stall__00020

			break;
		case req_SET_PROTOCOL:
091A  0E0B      	MOVLW 0x0B
091C  63E5      	CPFSEQ usb_handle_00022_arg_sdp+D'1', 1

			break;
		
	}

}	
08F8  0012      	RETURN
0900  0012      	RETURN
0908  0012      	RETURN
0910  0012      	RETURN
091E  0012      	RETURN
0920  0012      	RETURN
095C  0012      	RETURN

	
	
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF35F008  	GOTO	_startup

0008  EF73F009  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53DE      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF9      	MOVLW 0xF9
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0FFF      	ADDLW 0xFF
0040  A4D8      	BTFSS STATUS,Z
0042  D7E9      	BRA	label2
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  0000      	NOP
0062  0000      	NOP
0064  0000      	NOP
0066  0000      	NOP
0068  0000      	NOP
006A  0000      	NOP
006C  0000      	NOP
006E  2FDE      	DECFSZ delay_ms_00000_arg_del, F, 1
0070  D7D1      	BRA	label1
0072  0012      	RETURN
0074            ; } delay_ms function end





0136            __rem_16_1_00006
0136            ; { __rem_16_16 ; function begin
0136  0102      	MOVLB 0x02
0138  6B0D      	CLRF CompTempVarRet350, 1
013A  6B0E      	CLRF CompTempVarRet350+D'1', 1
013C  6B09      	CLRF __rem_16_1_00006_1_c, 1
013E  6B0A      	CLRF __rem_16_1_00006_1_c+D'1', 1
0140  6B0B      	CLRF __rem_16_1_00006_1_i, 1
0142            label11
0142  0E10      	MOVLW 0x10
0144  150B      	ANDWF __rem_16_1_00006_1_i, W, 1
0146  6F0C      	MOVWF CompTempVar352, 1
0148  670C      	TSTFSZ CompTempVar352, 1
014A  0012      	RETURN
014C  90D8      	BCF STATUS,C
014E  3709      	RLCF __rem_16_1_00006_1_c, F, 1
0150  370A      	RLCF __rem_16_1_00006_1_c+D'1', F, 1
0152  0100      	MOVLB 0x00
0154  37FE      	RLCF __rem_16_1_00006_arg_a, F, 1
0156  37FF      	RLCF __rem_16_1_00006_arg_a+D'1', F, 1
0158  0102      	MOVLB 0x02
015A  370D      	RLCF CompTempVarRet350, F, 1
015C  370E      	RLCF CompTempVarRet350+D'1', F, 1
015E  0101      	MOVLB 0x01
0160  51FE      	MOVF __rem_16_1_00006_arg_b, W, 1
0162  0102      	MOVLB 0x02
0164  5D0D      	SUBWF CompTempVarRet350, W, 1
0166  0101      	MOVLB 0x01
0168  51FF      	MOVF __rem_16_1_00006_arg_b+D'1', W, 1
016A  0102      	MOVLB 0x02
016C  630E      	CPFSEQ CompTempVarRet350+D'1', 1
016E  5D0E      	SUBWF CompTempVarRet350+D'1', W, 1
0170  E309      	BNC	label12
0172  0101      	MOVLB 0x01
0174  51FE      	MOVF __rem_16_1_00006_arg_b, W, 1
0176  0102      	MOVLB 0x02
0178  5F0D      	SUBWF CompTempVarRet350, F, 1
017A  0101      	MOVLB 0x01
017C  51FF      	MOVF __rem_16_1_00006_arg_b+D'1', W, 1
017E  0102      	MOVLB 0x02
0180  5B0E      	SUBWFB CompTempVarRet350+D'1', F, 1
0182  8109      	BSF __rem_16_1_00006_1_c,0, 1
0184            label12
0184  2B0B      	INCF __rem_16_1_00006_1_i, F, 1
0186  D7DD      	BRA	label11
0188            ; } __rem_16_16 function end

0188            __div_16_1_00005
0188            ; { __div_16_16 ; function begin
0188  0102      	MOVLB 0x02
018A  6B06      	CLRF __div_16_1_00005_1_r, 1
018C  6B07      	CLRF __div_16_1_00005_1_r+D'1', 1
018E  6B0A      	CLRF CompTempVarRet347, 1
0190  6B0B      	CLRF CompTempVarRet347+D'1', 1
0192  6B08      	CLRF __div_16_1_00005_1_i, 1
0194            label13
0194  0E10      	MOVLW 0x10
0196  1508      	ANDWF __div_16_1_00005_1_i, W, 1
0198  6F09      	MOVWF CompTempVar349, 1
019A  6709      	TSTFSZ CompTempVar349, 1
019C  0012      	RETURN
019E  90D8      	BCF STATUS,C
01A0  370A      	RLCF CompTempVarRet347, F, 1
01A2  370B      	RLCF CompTempVarRet347+D'1', F, 1
01A4  0100      	MOVLB 0x00
01A6  37FE      	RLCF __div_16_1_00005_arg_a, F, 1
01A8  37FF      	RLCF __div_16_1_00005_arg_a+D'1', F, 1
01AA  0102      	MOVLB 0x02
01AC  3706      	RLCF __div_16_1_00005_1_r, F, 1
01AE  3707      	RLCF __div_16_1_00005_1_r+D'1', F, 1
01B0  0101      	MOVLB 0x01
01B2  51FE      	MOVF __div_16_1_00005_arg_b, W, 1
01B4  0102      	MOVLB 0x02
01B6  5D06      	SUBWF __div_16_1_00005_1_r, W, 1
01B8  0101      	MOVLB 0x01
01BA  51FF      	MOVF __div_16_1_00005_arg_b+D'1', W, 1
01BC  0102      	MOVLB 0x02
01BE  6307      	CPFSEQ __div_16_1_00005_1_r+D'1', 1
01C0  5D07      	SUBWF __div_16_1_00005_1_r+D'1', W, 1
01C2  E309      	BNC	label14
01C4  0101      	MOVLB 0x01
01C6  51FE      	MOVF __div_16_1_00005_arg_b, W, 1
01C8  0102      	MOVLB 0x02
01CA  5F06      	SUBWF __div_16_1_00005_1_r, F, 1
01CC  0101      	MOVLB 0x01
01CE  51FF      	MOVF __div_16_1_00005_arg_b+D'1', W, 1
01D0  0102      	MOVLB 0x02
01D2  5B07      	SUBWFB __div_16_1_00005_1_r+D'1', F, 1
01D4  810A      	BSF CompTempVarRet347,0, 1
01D6            label14
01D6  2B08      	INCF __div_16_1_00005_1_i, F, 1
01D8  D7DD      	BRA	label13
01DA            ; } __div_16_16 function end





































095E            memcpy8_00000
095E            ; { memcpy8 ; function begin
095E  51E4      	MOVF memcpy8_00000_arg_dst, W, 1
0960  6FE9      	MOVWF memcpy8_00000_1_dst2, 1
0962  51E5      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
0964  6FEA      	MOVWF memcpy8_00000_1_dst2+D'1', 1
0966  51E6      	MOVF memcpy8_00000_arg_src, W, 1
0968  6FEB      	MOVWF memcpy8_00000_1_src2, 1
096A  51E7      	MOVF memcpy8_00000_arg_src+D'1', W, 1
096C  6FEC      	MOVWF memcpy8_00000_1_src2+D'1', 1
096E            label59
096E  0E00      	MOVLW 0x00
0970  65E8      	CPFSGT memcpy8_00000_arg_len, 1
0972  D012      	BRA	label60
0974  51EC      	MOVF memcpy8_00000_1_src2+D'1', W, 1
0976  6EEA      	MOVWF FSR0H
0978  51EB      	MOVF memcpy8_00000_1_src2, W, 1
097A  6EE9      	MOVWF FSR0L
097C  4BEB      	INFSNZ memcpy8_00000_1_src2, F, 1
097E  2BEC      	INCF memcpy8_00000_1_src2+D'1', F, 1
0980  50EF      	MOVF INDF0, W
0982  6FED      	MOVWF CompTempVar568, 1
0984  51EA      	MOVF memcpy8_00000_1_dst2+D'1', W, 1
0986  6EEA      	MOVWF FSR0H
0988  51E9      	MOVF memcpy8_00000_1_dst2, W, 1
098A  6EE9      	MOVWF FSR0L
098C  4BE9      	INFSNZ memcpy8_00000_1_dst2, F, 1
098E  2BEA      	INCF memcpy8_00000_1_dst2+D'1', F, 1
0990  51ED      	MOVF CompTempVar568, W, 1
0992  6EEF      	MOVWF INDF0
0994  07E8      	DECF memcpy8_00000_arg_len, F, 1
0996  D7EB      	BRA	label59
0998            label60
0998  51E4      	MOVF memcpy8_00000_arg_dst, W, 1
099A  6FED      	MOVWF CompTempVarRet567, 1
099C  51E5      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
099E  6FEE      	MOVWF CompTempVarRet567+D'1', 1
09A0  0012      	RETURN
09A2            ; } memcpy8 function end















































106A            _startup








12E2  EF20F008  	GOTO	main



300000  0E30      	DW 0x0E30
300002  1E3E      	DW 0x1E3E
300004  00FF      	DW 0x00FF
300006  FF80      	DW 0xFF80
300008  C00F      	DW 0xC00F
30000A  E00F      	DW 0xE00F
30000C  400F      	DW 0x400F
