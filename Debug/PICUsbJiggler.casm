;/////////////////////////////////////////////////////////////////////////////////
;// Code Generator: BoostC Compiler - http://www.sourceboost.com
;// Version       : 8.01
;// License Type  : Pro License
;// Limitations   : PIC18 max code size:Unlimited, max RAM banks:Unlimited
;/////////////////////////////////////////////////////////////////////////////////

#ifndef _PICUSBJIGGLER_H_
#define _PICUSBJIGGLER_H_

#define LED (portb.1) // LED pin
#define BUTTON (portb.2) // Button (switch) pin

bit isJiggling = 0; // When 0, device does nothing
0926  0100      	MOVLB 0x00
0928  91D2      	BCF gbl_isJiggling,0, 1


#endif //_PICUSBJIGGLER_H_

/*
 
 \file pic_tick.h
 
 Timer helper routines

 Ian Harris 2008
 imharris [at] gmail.com

 Released under the "do whatever you like with this
 but it breaks, you get to keep both pieces" license.

*/
#ifndef __pic_tick_h
#define __pic_tick_h

#include "pic_utils.h"

/** Global tick counter */
static uns16 tick = 0;
092A  6A5E      	CLRF gbl_19_tick
092C  6A5F      	CLRF gbl_19_tick+D'1'


/**
	\brief Return current tick count
	
	Returns the current tick count. Thread and interrupt safe.
*/
uns16 tick_get_count();
/**
	\brief Calculate the tick time difference between two values
	
	Calculates how many ticks have elapsed between two tick values. Covers
	cases where the tick count wraps beyond its 16 bit value.
*/
uns16 tick_calc_diff(uns16 a, uns16 b);

/**
	\brief Call this routine to increment tick count
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine.
*/
void handle_tick();

/**
	\brief Call this routine to increment tick count - inline version
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine. Inline version so you
	don't use up one stack level
*/
inline void handle_tick_inline() {
   tick++;	// we assume that interrupts are off at this point
}   		

#endif   
#endif   
#include <system.h>
#include "PICUsbJiggler.h"

/* 
Requires http://embeddedadventures.blogspot.com/2009/01/picpack-20-released.html
*/

// Pic Pack includes
#include "pic_pack_lib/pic_utils.h"
#include "pic_pack_lib/pic_usb.h"
#include "pic_pack_lib/pic_tick.h"
#include "pic_pack_lib/pic_timer.h"


// Configuration registers
// FOSC3:FOSC0 = HSPLL PLLDIV2:PLLDIV0 = 0, CPUDIV1:CPUDIV0 = 10 (/4)
#pragma DATA    _CONFIG1L, 00110000b // USBDIV on, CPU divide by 4, PLL direct
#pragma DATA    _CONFIG1H, 00001110b // disable oscillator switchover, disable failsafe clock monitor, HSPLL
#pragma DATA    _CONFIG2L, 00111110b // USB voltage regulator enabled, brownout set for 2.1 volts, hardware brownout only, PWRT enabled
#pragma DATA    _CONFIG2H, 00011110b // Watchdog timer disabled
#pragma DATA    _CONFIG3H, 00000000b // MCLR disabled, RB4:RB0 digital on POR
#pragma DATA    _CONFIG4L, 10000000b // Debug off, extended instructions disabled, LVP disabled, disable stack full/underflow reset
#pragma DATA    _CONFIG5L, 00001111b // Read code protection off
#pragma DATA    _CONFIG5H, 11000000b // Read EEPROM and boot block protection off
#pragma DATA    _CONFIG6L, 00001111b // Write code protection off
#pragma DATA    _CONFIG6H, 11100000b // Write EEPROM, boot block and config register protection off
#pragma DATA    _CONFIG7L, 00001111b // Table read protection off
#pragma DATA    _CONFIG7H, 01000000b // Boot block table read protection off

// 4 MHz crystal but the system clock is 24MHz due to CPUDIV configuration
#pragma CLOCK_FREQ 24000000

// See if we need to do a task
uns8 do_task = 0;
092E  6BD3      	CLRF gbl_do_task, 1


// Flag if we received something
bit receive = 0;
0930  93D2      	BCF gbl_receive,1, 1


// Dummy variable to show we can set it 
uns8 send_to = 0;
0932  6BD4      	CLRF gbl_send_to, 1


/******************************************************
  Function called once only to initialise variables and
  setup the PIC registers
*******************************************************/
void initialise() {

    // IO ports setup
    trisa = 0x00; // all ouptuts
0846  6A92      	CLRF gbl_trisa

    porta = 0x00; // set to off
0848  6A80      	CLRF gbl_porta

    trisb = 0x04; // RB2 input
084A  0E04      	MOVLW 0x04
084C  6E93      	MOVWF gbl_trisb

    portb = 0x00; // set to off
084E  6A81      	CLRF gbl_portb

    trisc = 0x00; // all ouptuts
0850  6A94      	CLRF gbl_trisc

    portc = 0x00; // set to off
0852  6A82      	CLRF gbl_portc


    // ADC setup
    adcon0 = 0x00; //  ADC off
0854  6AC2      	CLRF gbl_adcon0

    adcon1 = 0x0F; // All digital I/O
0856  0E0F      	MOVLW 0x0F
0858  6EC1      	MOVWF gbl_adcon1

    
    // USB setup
    ucon.USBEN = 1; // USB on
085A  866D      	BSF gbl_ucon,3


    intcon2.RBPU = 0; // Port B pull-ups enabled
085C  9EF1      	BCF gbl_intcon2,7


    
    timer_setup_0(TIMER_16BIT_MODE, TIMER_PRESCALER_OFF, 59530); // close enough to 1ms at 24Mhz
085E  0100      	MOVLB 0x00
0860  91E7      	BCF timer_setu_00024_arg_mode_8_bit,0, 1
0862  69E8      	SETF timer_setu_00024_arg_presc_00025, 1
0864  0E8A      	MOVLW 0x8A
0866  6FE9      	MOVWF timer_setu_00024_arg_timer_00026, 1
0868  0EE8      	MOVLW 0xE8
086A  6FEA      	MOVWF timer_setu_00024_arg_timer_00026+D'1', 1
086C  EC79F003  	CALL timer_setu_00024


	turn_usb_ints_on();
0870  EC6DF003  	CALL turn_usb_i_00020

    intcon.PEIE = 1; // Enables all unmasked peripheral interrupts
0874  8CF2      	BSF gbl_intcon,6

    intcon.GIE = 1;
0876  8EF2      	BSF gbl_intcon,7

    
    timer_start_0();
0878  EC72F003  	CALL timer_star_00027

}
087C  0012      	RETURN


// Interrupt routine - - - - - - - - - -
void timer_0_callback() {

	handle_tick();
06D4  EC53F003  	CALL handle_tic_00023

}	
06D8  0012      	RETURN


//------------------------------------------------------------------------------
// Interrupt handler
//------------------------------------------------------------------------------
void interrupt(void) {

	usb_handle_isr();
0B9A  CFEAF001  	MOVFF FSR0H,  Int1Context
0B9E  CFE9F002  	MOVFF FSR0L,  Int1Context+D'1'
0BA2  CFF4F003  	MOVFF PRODH,  Int1Context+D'2'
0BA6  CFF3F004  	MOVFF PRODL,  Int1Context+D'3'
0BAA  EC57F003  	CALL usb_handle_0000E

	timer_handle_0_isr();
0BAE  A4F2      	BTFSS gbl_intcon,2
0BB0  D011      	BRA	label74
0BB2  0100      	MOVLB 0x00
0BB4  6BF5      	CLRF interrupt_6_start_value+D'1', 1
0BB6  51C4      	MOVF gbl_timer_0_start_value, W, 1
0BB8  24D6      	ADDWF gbl_tmr0l, W
0BBA  6FF4      	MOVWF interrupt_6_start_value, 1
0BBC  51C5      	MOVF gbl_timer_0_start_value+D'1', W, 1
0BBE  23F5      	ADDWFC interrupt_6_start_value+D'1', F, 1
0BC0  2BF4      	INCF interrupt_6_start_value, F, 1
0BC2  B4D8      	BTFSC STATUS,Z
0BC4  2BF5      	INCF interrupt_6_start_value+D'1', F, 1
0BC6  51F5      	MOVF interrupt_6_start_value+D'1', W, 1
0BC8  6ED7      	MOVWF gbl_tmr0h
0BCA  51F4      	MOVF interrupt_6_start_value, W, 1
0BCC  6ED6      	MOVWF gbl_tmr0l
0BCE  94F2      	BCF gbl_intcon,2
0BD0  EC6AF003  	CALL timer_0_ca_00029
0BD4            label74

}
0BD4  C004FFF3  	MOVFF Int1Context+D'3',  PRODL
0BD8  C003FFF4  	MOVFF Int1Context+D'2',  PRODH
0BDC  C002FFE9  	MOVFF Int1Context+D'1',  FSR0L
0BE0  C001FFEA  	MOVFF Int1Context,  FSR0H
0BE4  0011      	RETFIE 1


//-----------------------------------------------------------------------------
// MAIN PROGRAM
//------------------------------------------------------------------------------
void main() {

    initialise();
087E  EC23F004  	CALL initialise_00000

    
    uns16 tick_marker = 0;
0882  6BDE      	CLRF main_1_tick_marker, 1
0884  6BDF      	CLRF main_1_tick_marker+D'1', 1

	uns16 test_tick;
	uns8 left_count = 0;
0886  6BE2      	CLRF main_1_left_count, 1

	uns8 check_count = 0;
0888  6BE3      	CLRF main_1_check_count, 1

	signed char buffer[3];
    
    while (1) {
088A            label68
0924  D7B2      	BRA	label68

		test_tick = tick_get_count();	// find out what we're up to
088A  ECEEF003  	CALL tick_get_c_00021
088E  51EA      	MOVF CompTempVarRet735, W, 1
0890  6FE0      	MOVWF main_1_test_tick, 1
0892  51EB      	MOVF CompTempVarRet735+D'1', W, 1
0894  6FE1      	MOVWF main_1_test_tick+D'1', 1

		if (tick_calc_diff(tick_marker, test_tick) > 3) {	// every 3 ms
0896  51DE      	MOVF main_1_tick_marker, W, 1
0898  6FE7      	MOVWF tick_calc__00022_arg_a, 1
089A  51DF      	MOVF main_1_tick_marker+D'1', W, 1
089C  6FE8      	MOVWF tick_calc__00022_arg_a+D'1', 1
089E  51E0      	MOVF main_1_test_tick, W, 1
08A0  6FE9      	MOVWF tick_calc__00022_arg_b, 1
08A2  51E1      	MOVF main_1_test_tick+D'1', W, 1
08A4  6FEA      	MOVWF tick_calc__00022_arg_b+D'1', 1
08A6  EC02F004  	CALL tick_calc__00022
08AA  0E03      	MOVLW 0x03
08AC  65EB      	CPFSGT CompTempVarRet736, 1
08AE  67EC      	TSTFSZ CompTempVarRet736+D'1', 1
08B0  D001      	BRA	label69
08B2  D029      	BRA	label71
08B4            label69

			tick_marker = test_tick;
08B4  51E0      	MOVF main_1_test_tick, W, 1
08B6  6FDE      	MOVWF main_1_tick_marker, 1
08B8  51E1      	MOVF main_1_test_tick+D'1', W, 1
08BA  6FDF      	MOVWF main_1_tick_marker+D'1', 1

			left_count++;
08BC  2BE2      	INCF main_1_left_count, F, 1

			check_count++;
08BE  2BE3      	INCF main_1_check_count, F, 1

			if (check_count == 5) {
08C0  0E05      	MOVLW 0x05
08C2  63E3      	CPFSEQ main_1_check_count, 1
08C4  D020      	BRA	label71
0906            label71

				check_count = 0;
08C6  6BE3      	CLRF main_1_check_count, 1

				if (usb_get_state() == st_CONFIGURED) {
08C8  ECEAF003  	CALL usb_get_st_00012
08CC  0E03      	MOVLW 0x03
08CE  63E7      	CPFSEQ CompTempVarRet791, 1
08D0  D018      	BRA	label70

                    if (isJiggling) {
08D2  A1D2      	BTFSS gbl_isJiggling,0, 1
08D4  D016      	BRA	label70

                        // Emit random movement
                        buffer[0] = 0;
08D6  6BE4      	CLRF main_1_buffer, 1

                        buffer[1] = 0 - left_count;	
08D8  51E2      	MOVF main_1_left_count, W, 1
08DA  0800      	SUBLW 0x00
08DC  6FE5      	MOVWF main_1_buffer+D'1', 1

                        buffer[2] = 0;
08DE  6BE6      	CLRF main_1_buffer+D'2', 1

                        if (buffer[0] | buffer[1] | buffer[2])
08E0  51E5      	MOVF main_1_buffer+D'1', W, 1
08E2  11E4      	IORWF main_1_buffer, W, 1
08E4  6FE7      	MOVWF CompTempVar730, 1
08E6  51E6      	MOVF main_1_buffer+D'2', W, 1
08E8  11E7      	IORWF CompTempVar730, W, 1
08EA  E00B      	BZ	label70
0902            label70

                            usb_send_data(1, (uns8 *)&buffer, 3, /*first*/ 0); // ep 1
08EC  0E01      	MOVLW 0x01
08EE  6FE8      	MOVWF usb_send_d_0000F_arg_ep, 1
08F0  0E00      	MOVLW HIGH(main_1_buffer+D'0')
08F2  6FEA      	MOVWF usb_send_d_0000F_arg_data+D'1', 1
08F4  0EE4      	MOVLW LOW(main_1_buffer+D'0')
08F6  6FE9      	MOVWF usb_send_d_0000F_arg_data, 1
08F8  0E03      	MOVLW 0x03
08FA  6FEB      	MOVWF usb_send_d_0000F_arg_send_count, 1
08FC  91EC      	BCF usb_send_d_0000F_arg_first,0, 1
08FE  EC8FF003  	CALL usb_send_d_0000F

                    }
				}
				left_count = 0;
0902  6BE2      	CLRF main_1_left_count, 1

				check_count = 0;
0904  6BE3      	CLRF main_1_check_count, 1

			}	
		}
        // Check for button press
        if(BUTTON) {
0906  A481      	BTFSS gbl_portb,2
0908  D7C0      	BRA	label68

			delay_ms(100);
090A  0E64      	MOVLW 0x64
090C  6FE7      	MOVWF delay_ms_00000_arg_del, 1
090E  EC06F000  	CALL delay_ms_00000

			if(BUTTON) {
0912  A481      	BTFSS gbl_portb,2
0914  D7BA      	BRA	label68

				if (isJiggling) {
0916  A1D2      	BTFSS gbl_isJiggling,0, 1
0918  D003      	BRA	label72
0920            label72

					isJiggling = 1;
091A  81D2      	BSF gbl_isJiggling,0, 1

					LED = 1;
091C  8281      	BSF gbl_portb,1

				} else {
091E  D7B5      	BRA	label68

					isJiggling = 0;
0920  91D2      	BCF gbl_isJiggling,0, 1

					LED = 0;
0922  9281      	BCF gbl_portb,1

				}
			}
        }
    }
} 


/*
 
 \file pic_tick.h
 
 Timer helper routines

 Ian Harris 2008
 imharris [at] gmail.com

 Released under the "do whatever you like with this
 but it breaks, you get to keep both pieces" license.

*/
#ifndef __pic_tick_h
#define __pic_tick_h

#include "pic_utils.h"

/** Global tick counter */
static uns16 tick = 0;
0934  6BC2      	CLRF gbl_20_tick, 1
0936  6BC3      	CLRF gbl_20_tick+D'1', 1


/**
	\brief Return current tick count
	
	Returns the current tick count. Thread and interrupt safe.
*/
uns16 tick_get_count();
/**
	\brief Calculate the tick time difference between two values
	
	Calculates how many ticks have elapsed between two tick values. Covers
	cases where the tick count wraps beyond its 16 bit value.
*/
uns16 tick_calc_diff(uns16 a, uns16 b);

/**
	\brief Call this routine to increment tick count
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine.
*/
void handle_tick();

/**
	\brief Call this routine to increment tick count - inline version
	
	Typically called during the interrupt routine of a timer to increment
	the tick count.  Note this routine assumes that interupts are off - which
	is always the case in an interrupt sub routine. Inline version so you
	don't use up one stack level
*/
inline void handle_tick_inline() {
   tick++;	// we assume that interrupts are off at this point
}   		

#endif   
#endif   
/*
 
 pic_tick.c
 ----------
 
 Timer helper routines

 Ian Harris 2008
 imharris [at] gmail.com

 Released under the "do whatever you like with this
 but if you use it send me an email" license. Oh, and
 if it breaks, you get to keep both pieces.

*/
#include "pic_tick.h"

uns16 tick_get_count() {


bit my_store_gie;
uns16 result;

	my_store_gie = intcon.GIE;	// save global interrupt       
07DC  0100      	MOVLB 0x00
07DE  91E7      	BCF tick_get_c_00021_1_my_store_gie,0, 1
07E0  BEF2      	BTFSC gbl_intcon,7
07E2  81E7      	BSF tick_get_c_00021_1_my_store_gie,0, 1
07E4            label66

	kill_interrupts();	// turn them off
07E4  9EF2      	BCF gbl_intcon,7
07E6  BEF2      	BTFSC gbl_intcon,7
07E8  D7FD      	BRA	label66


	result = tick;	// Grab a copy
07EA  51C2      	MOVF gbl_20_tick, W, 1
07EC  6FE8      	MOVWF tick_get_c_00021_1_result, 1
07EE  51C3      	MOVF gbl_20_tick+D'1', W, 1
07F0  6FE9      	MOVWF tick_get_c_00021_1_result+D'1', 1

			
	intcon.GIE = my_store_gie;	// interrupts back to normal
07F2  B1E7      	BTFSC tick_get_c_00021_1_my_store_gie,0, 1
07F4  8EF2      	BSF gbl_intcon,7
07F6  A1E7      	BTFSS tick_get_c_00021_1_my_store_gie,0, 1
07F8  9EF2      	BCF gbl_intcon,7

	return result;	// return the result
07FA  51E8      	MOVF tick_get_c_00021_1_result, W, 1
07FC  6FEA      	MOVWF CompTempVarRet735, 1
07FE  51E9      	MOVF tick_get_c_00021_1_result+D'1', W, 1
0800  6FEB      	MOVWF CompTempVarRet735+D'1', 1

}	
0802  0012      	RETURN

	
uns16 tick_calc_diff(uns16 a, uns16 b) {

	if (a <= b) {	// simple case
0804  51E7      	MOVF tick_calc__00022_arg_a, W, 1
0806  5DE9      	SUBWF tick_calc__00022_arg_b, W, 1
0808  51E8      	MOVF tick_calc__00022_arg_a+D'1', W, 1
080A  63EA      	CPFSEQ tick_calc__00022_arg_b+D'1', 1
080C  5DEA      	SUBWF tick_calc__00022_arg_b+D'1', W, 1
080E  E307      	BNC	label67
081E            label67

		return b-a;
0810  51E7      	MOVF tick_calc__00022_arg_a, W, 1
0812  5DE9      	SUBWF tick_calc__00022_arg_b, W, 1
0814  6FEB      	MOVWF CompTempVarRet736, 1
0816  51E8      	MOVF tick_calc__00022_arg_a+D'1', W, 1
0818  59EA      	SUBWFB tick_calc__00022_arg_b+D'1', W, 1
081A  6FEC      	MOVWF CompTempVarRet736+D'1', 1

	} else {
		return 65535 - a + b + 1;	// more complex case
081E  51E7      	MOVF tick_calc__00022_arg_a, W, 1
0820  08FF      	SUBLW 0xFF
0822  6FEE      	MOVWF CompTempVar743, 1
0824  0EFF      	MOVLW 0xFF
0826  55E8      	SUBFWB tick_calc__00022_arg_a+D'1', W, 1
0828  6FED      	MOVWF CompTempVar740, 1
082A  51E9      	MOVF tick_calc__00022_arg_b, W, 1
082C  27EE      	ADDWF CompTempVar743, F, 1
082E  51EA      	MOVF tick_calc__00022_arg_b+D'1', W, 1
0830  6FEF      	MOVWF CompTempVar744, 1
0832  51ED      	MOVF CompTempVar740, W, 1
0834  23EF      	ADDWFC CompTempVar744, F, 1
0836  2BEE      	INCF CompTempVar743, F, 1
0838  B4D8      	BTFSC STATUS,Z
083A  2BEF      	INCF CompTempVar744, F, 1
083C  51EE      	MOVF CompTempVar743, W, 1
083E  6FEB      	MOVWF CompTempVarRet736, 1
0840  51EF      	MOVF CompTempVar744, W, 1
0842  6FEC      	MOVWF CompTempVarRet736+D'1', 1

	}
}
081C  0012      	RETURN
0844  0012      	RETURN


void handle_tick() {

   tick++;	// we assume that interrupts are off at this point
06A6  0100      	MOVLB 0x00
06A8  4BC2      	INFSNZ gbl_20_tick, F, 1
06AA  2BC3      	INCF gbl_20_tick+D'1', F, 1

}   		
06AC  0012      	RETURN

		
		
		
/*! \file pic_timer.h
    \brief Pic timer routines

	It's the way cool interrupt driven timer library

	Ian Harris 2007
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if you use it send me an email" license. Oh, and
	if it breaks, you get to keep both pieces.
    
   
*/

#include "pic_timer.h"

#ifdef _PIC18
	uns16 timer_0_start_value = 0;
0938  6BC4      	CLRF gbl_timer_0_start_value, 1
093A  6BC5      	CLRF gbl_timer_0_start_value+D'1', 1

#endif
#ifdef _PIC16
	uns8 timer_0_start_value = 0;
#endif;	

#ifdef _PIC18
void timer_setup_0(bit mode_8_bit, uns8 prescaler_setting, uns16 timer_start_value) {


	clear_bit(t0con, TMR0ON);	// turn off timer if it was on so we can get it set up
06F2  9ED5      	BCF gbl_t0con,7

	if (mode_8_bit) {
06F4  A1E7      	BTFSS timer_setu_00024_arg_mode_8_bit,0, 1
06F6  D002      	BRA	label59
06FC            label59

		set_bit(t0con, T08BIT); 	// enable 8 bit mode 
06F8  8CD5      	BSF gbl_t0con,6

	} else {
06FA  D001      	BRA	label60
06FE            label60

		clear_bit(t0con, T08BIT);
06FC  9CD5      	BCF gbl_t0con,6

	}	
	clear_bit(t0con, T0CS);	// Internal instruction cycle clock
06FE  9AD5      	BCF gbl_t0con,5

	// T0SE -- don't care
	if (prescaler_setting == TIMER_PRESCALER_OFF) {
0700  29E8      	INCF timer_setu_00024_arg_presc_00025, W, 1
0702  E102      	BNZ	label61
0708            label61

		set_bit(t0con, PSA);
0704  86D5      	BSF gbl_t0con,3

	} else {
0706  D005      	BRA	label62
0712            label62

		clear_bit(t0con, PSA);
0708  96D5      	BCF gbl_t0con,3

		t0con &= 0b11111000;
070A  0EF8      	MOVLW 0xF8
070C  16D5      	ANDWF gbl_t0con, F

		t0con |= prescaler_setting;
070E  51E8      	MOVF timer_setu_00024_arg_presc_00025, W, 1
0710  12D5      	IORWF gbl_t0con, F

	}
	timer_0_start_value = timer_start_value;
0712  51E9      	MOVF timer_setu_00024_arg_timer_00026, W, 1
0714  6FC4      	MOVWF gbl_timer_0_start_value, 1
0716  51EA      	MOVF timer_setu_00024_arg_timer_00026+D'1', W, 1
0718  6FC5      	MOVWF gbl_timer_0_start_value+D'1', 1

	set_bit(intcon, TMR0IE); 	// Turn on timer 0 interrupts
071A  8AF2      	BSF gbl_intcon,5

}		
071C  0012      	RETURN

#endif

#ifdef _PIC16

void timer_setup_0(bit mode_8_bit, uns8 prescaler_setting, uns16 timer_start_value) {

	clear_bit( option_reg, T0CS ); // configure timer0 as a timer
	// T0SE -- don't care
	if (prescaler_setting == TIMER_PRESCALER_OFF) {
		set_bit(option_reg, PSA);	// Asign it to watchdog timer (ie, not us)
	} else {
		clear_bit(option_reg, PSA);	// prescaler assigned to us
		option_reg &= 0b11111000;
		option_reg |= prescaler_setting;
	}
	timer_0_start_value = timer_start_value;
}		
#endif

#ifdef _PIC18
void timer_start_0() {

	tmr0h = timer_0_start_value >> 8;
06E4  0100      	MOVLB 0x00
06E6  51C5      	MOVF gbl_timer_0_start_value+D'1', W, 1
06E8  6ED7      	MOVWF gbl_tmr0h

	tmr0l = timer_0_start_value & 0xff;
06EA  51C4      	MOVF gbl_timer_0_start_value, W, 1
06EC  6ED6      	MOVWF gbl_tmr0l

	set_bit(t0con, TMR0ON);
06EE  8ED5      	BSF gbl_t0con,7

}
06F0  0012      	RETURN

#endif

#ifdef _PIC16
void timer_start_0() {
	tmr0 = timer_0_start_value;
	// There's no "on" for timer 0
	set_bit(intcon, TMR0IE); 	// Turn on timer 0 interrupts
}
#endif

#ifdef _PIC18
void timer_stop_0() {
	clear_bit(t0con, TMR0ON);
}
#endif
#ifdef _PIC16
void timer_stop_0() {
	clear_bit(intcon, TMR0IE); 	// turn off timer 0 interrupts
}
#endif


/*! \file pic_usb.c
    \brief Pic USB routines

	It's the way cool interrupt driven usb library

	Ian Harris 2008
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if it breaks, you get to keep both pieces" license
    
   
*/

#include "pic_usb.h"
#include "memory.h"
#include "config.h"
#include "pic_usb_buffer_mgt.h"

// globally accessable variables

usb_state_type usb_state = st_POWERED;
093C  6BD5      	CLRF gbl_usb_state, 1


setup_data_packet usb_sdp;

uns8 usb_address;
control_mode_type control_mode;
uns16 delivery_bytes_to_send,
	  delivery_bytes_max_send,
		delivery_bytes_sent;
uns8 *delivery_ptr;	
uns8 delivery_buffer_size;
uns8 *delivery_buffer;
buffer_descriptor *delivery_bd;

usb_status_type usb_status;

void usb_configure_endpoints() {

	
#ifdef USB_EP1
	set_bit  (uep1, EPHSHK);	// EP handshaking on
02A4  8871      	BSF gbl_uep1,4

	#ifdef USB_EP1_OUT_SIZE
		set_bit(uep1, EPOUTEN);	// EP OUT enabled
	#else
		clear_bit(uep1, EPOUTEN);	// EP OUT disabled
02A6  9471      	BCF gbl_uep1,2

	#endif
	#ifdef USB_EP1_IN_SIZE
		set_bit(uep1, EPINEN);	// EP IN enabled
02A8  8271      	BSF gbl_uep1,1

	#else
		clear_bit(uep1, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep1, EPCONDIS);	// control transfers off
02AA  8671      	BSF gbl_uep1,3

	
	// for IN
	#ifdef USB_EP1_IN_SIZE
		set_bit(bd1in.stat, DTS);	// turn on data togle sync TOGGLE
02AC  0104      	MOVLB 0x04
02AE  8D0C      	BSF gbl_bd1in,6, 1

		clear_bit(bd1in.stat, KEN);	// clear the keep bit
02B0  9B0C      	BCF gbl_bd1in,5, 1

		clear_bit(bd1in.stat, INCDIS);	// clear the increment disable
02B2  990C      	BCF gbl_bd1in,4, 1

		clear_bit(bd1in.stat, DTSEN);
02B4  970C      	BCF gbl_bd1in,3, 1

		clear_bit(bd1in.stat, BSTALL);	// clear stall bit
02B6  950C      	BCF gbl_bd1in,2, 1

		clear_bit(bd1in.stat, BC9);
02B8  930C      	BCF gbl_bd1in,1, 1

		clear_bit(bd1in.stat, BC8);
02BA  910C      	BCF gbl_bd1in,0, 1

	
		clear_bit(bd1in.stat, UOWN);	// uC owns the buffer
02BC  9F0C      	BCF gbl_bd1in,7, 1

	#endif
	// for OUT
	#ifdef USB_EP1_OUT_SIZE
		bd1out.count = USB_EP1_OUT_SIZE;
		bd1out.addr  = USB_EP1_OUT_ADDR;
		
		clear_bit(bd1out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd1out.stat, KEN);	// clear the keep bit
		clear_bit(bd1out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd1out.stat, DTSEN);
		clear_bit(bd1out.stat, BSTALL);	// clear stall bit
		clear_bit(bd1out.stat, BC9);
		clear_bit(bd1out.stat, BC8);
		set_bit  (bd1out.stat, UOWN);	// SIE owns the buffer
		
	#endif
	

#endif

#ifdef USB_EP2
	set_bit  (uep2, EPHSHK);	// EP handshaking on
	#ifdef USB_EP2_OUT_SIZE
		set_bit(uep2, EPOUTEN);	// EP OUT enabled
	#else
		clear_bit(uep2, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP2_IN_SIZE
		set_bit(uep2, EPINEN);	// EP IN enabled
	#else
		clear_bit(uep2, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep2, EPCONDIS);	// control transfers off

	// for IN
	#ifdef USB_EP2_IN_SIZE
	
		set_bit(bd2in.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd2in.stat, KEN);	// clear the keep bit
		clear_bit(bd2in.stat, INCDIS);	// clear the increment disable
		clear_bit(bd2in.stat, DTSEN);
		clear_bit(bd2in.stat, BSTALL);	// clear stall bit
		clear_bit(bd2in.stat, BC9);
		clear_bit(bd2in.stat, BC8);
	
		clear_bit(bd2in.stat, UOWN);	// uC owns the buffer
	#endif
	// for OUT
	#ifdef USB_EP2_OUT_SIZE
		bd2out.count = USB_EP2_OUT_SIZE;
		bd2out.addr  = USB_EP2_OUT_ADDR;

		clear_bit(bd2out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd2out.stat, KEN);	// clear the keep bit
		clear_bit(bd2out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd2out.stat, DTSEN);
		clear_bit(bd2out.stat, BSTALL);	// clear stall bit
		clear_bit(bd2out.stat, BC9);
		clear_bit(bd2out.stat, BC8);
		set_bit  (bd2out.stat, UOWN);	// SIE owns the buffer
	#endif
#endif

#ifdef USB_EP3
	set_bit  (uep3, EPHSHK);	// EP handshaking on
	#ifdef USB_EP3_OUT_SIZE
		set_bit(uep3, EPOUTEN);	// EP OUT enabled
	#else
		clear_bit(uep3, EPOUTEN);	// EP OUT disabled
	#endif
	#ifdef USB_EP3_IN_SIZE
		set_bit(uep3, EPINEN);	// EP IN enabled
	#else
		clear_bit(uep3, EPINEN);	// EP IN disabled
	#endif
	set_bit  (uep3, EPCONDIS);	// control transfers off
	// for IN
	#ifdef USB_EP3_IN_SIZE
		set_bit(bd3in.stat, DTS);	// ready for toggle
		clear_bit(bd3in.stat, KEN);	// clear the keep bit
		clear_bit(bd3in.stat, INCDIS);	// clear the increment disable
		clear_bit(bd3in.stat, DTSEN);
		clear_bit(bd3in.stat, BSTALL);	// clear stall bit
		clear_bit(bd3in.stat, BC9);
		clear_bit(bd3in.stat, BC8);
	
		clear_bit(bd3in.stat, UOWN);	// uC owns the buffer
	#endif
	// for OUT
	#ifdef USB_EP3_OUT_SIZE
		bd3out.count = USB_EP3_OUT_SIZE;
		bd3out.addr  = USB_EP3_OUT_ADDR;

		clear_bit(bd3out.stat, DTS);	// turn on data togle sync TOGGLE
		clear_bit(bd3out.stat, KEN);	// clear the keep bit
		clear_bit(bd3out.stat, INCDIS);	// clear the increment disable
		clear_bit(bd3out.stat, DTSEN);
		clear_bit(bd3out.stat, BSTALL);	// clear stall bit
		clear_bit(bd3out.stat, BC9);
		clear_bit(bd3out.stat, BC8);
		set_bit  (bd3out.stat, UOWN);	// SIE owns the buffer
	#endif

#endif
	
}
02BE  0012      	RETURN


void usb_stall_ep0() {

	set_bit(bd0in.stat, BSTALL);	// stall
0108  0104      	MOVLB 0x04
010A  8504      	BSF gbl_bd0in,2, 1

	set_bit(bd0in.stat, UOWN);	// SIE owns the buffer
010C  8F04      	BSF gbl_bd0in,7, 1

	set_bit(bd0out.stat, BSTALL);	// stall
010E  8500      	BSF gbl_bd0out,2, 1

	set_bit(bd0out.stat, UOWN);	// SIE owns the buffer
0110  8F00      	BSF gbl_bd0out,7, 1

	//set_bit(uep0,EPSTALL);
}
0112  0012      	RETURN


void usb_send_data(uns8 ep, uns8 *data, uns8 send_count, bit first) {

uns8 count;
buffer_descriptor *bd;
uns8 *buffer;

	// this is going to be an IN transaction
	
	// need to grab buffer descriptor
	buffer = ep_in_buffer_location[ep];
071E  EE00F0AE  	LFSR 0x00,  gbl_ep_in_buffer_location
0722  50E9      	MOVF FSR0L, W
0724  51E8      	MOVF usb_send_d_0000F_arg_ep, W, 1
0726  6FF2      	MOVWF CompTempVar775, 1
0728  90D8      	BCF STATUS,C
072A  35F2      	RLCF CompTempVar775, W, 1
072C  26E9      	ADDWF FSR0L, F
072E  50EE      	MOVF POSTINC0, W
0730  6FF0      	MOVWF usb_send_d_0000F_1_buffer, 1
0732  50EF      	MOVF INDF0, W
0734  6FF1      	MOVWF usb_send_d_0000F_1_buffer+D'1', 1

	
	bd = ep_in_bd_location[ep];
0736  EE00F0A6  	LFSR 0x00,  gbl_ep_in_bd_location
073A  50E9      	MOVF FSR0L, W
073C  51E8      	MOVF usb_send_d_0000F_arg_ep, W, 1
073E  6FF2      	MOVWF CompTempVar778, 1
0740  90D8      	BCF STATUS,C
0742  35F2      	RLCF CompTempVar778, W, 1
0744  26E9      	ADDWF FSR0L, F
0746  50EE      	MOVF POSTINC0, W
0748  6FEE      	MOVWF usb_send_d_0000F_1_bd, 1
074A  50EF      	MOVF INDF0, W
074C  6FEF      	MOVWF usb_send_d_0000F_1_bd+D'1', 1

	
	if (test_bit(bd->stat, UOWN)) {
074E  51EF      	MOVF usb_send_d_0000F_1_bd+D'1', W, 1
0750  6EEA      	MOVWF FSR0H
0752  51EE      	MOVF usb_send_d_0000F_1_bd, W, 1
0754  6EE9      	MOVWF FSR0L
0756  BEEF      	BTFSC INDF0,7

		return;
	}
	
	count = 0;	
075A  6BED      	CLRF usb_send_d_0000F_1_count, 1

	while ((count < send_count)) {
075C            label63
075C  51EB      	MOVF usb_send_d_0000F_arg_send_count, W, 1
075E  61ED      	CPFSLT usb_send_d_0000F_1_count, 1
0760  D013      	BRA	label64
0786  D7EA      	BRA	label63
0788            label64

	    buffer[count] = data[count];
0762  51EA      	MOVF usb_send_d_0000F_arg_data+D'1', W, 1
0764  6EEA      	MOVWF FSR0H
0766  51E9      	MOVF usb_send_d_0000F_arg_data, W, 1
0768  6EE9      	MOVWF FSR0L
076A  51ED      	MOVF usb_send_d_0000F_1_count, W, 1
076C  6FF2      	MOVWF CompTempVar781, 1
076E  51F2      	MOVF CompTempVar781, W, 1
0770  26E9      	ADDWF FSR0L, F
0772  50EF      	MOVF INDF0, W
0774  6FF3      	MOVWF CompTempVar782, 1
0776  51F1      	MOVF usb_send_d_0000F_1_buffer+D'1', W, 1
0778  6EEA      	MOVWF FSR0H
077A  51F0      	MOVF usb_send_d_0000F_1_buffer, W, 1
077C  25ED      	ADDWF usb_send_d_0000F_1_count, W, 1
077E  6EE9      	MOVWF FSR0L
0780  51F3      	MOVF CompTempVar782, W, 1
0782  6EEF      	MOVWF INDF0

	    count++;
0784  2BED      	INCF usb_send_d_0000F_1_count, F, 1

	}       	
	

	bd->count = count;
0788  51EF      	MOVF usb_send_d_0000F_1_bd+D'1', W, 1
078A  6EEA      	MOVWF FSR0H
078C  29EE      	INCF usb_send_d_0000F_1_bd, W, 1
078E  6EE9      	MOVWF FSR0L
0790  51ED      	MOVF usb_send_d_0000F_1_count, W, 1
0792  6EEF      	MOVWF INDF0

	bd->addr = (uns16)buffer;
0794  06E9      	DECF FSR0L, F
0796  0E02      	MOVLW 0x02
0798  26E9      	ADDWF FSR0L, F
079A  2AE9      	INCF FSR0L, F
079C  51F0      	MOVF usb_send_d_0000F_1_buffer, W, 1
079E  6FF2      	MOVWF CompTempVar783, 1
07A0  51F1      	MOVF usb_send_d_0000F_1_buffer+D'1', W, 1
07A2  6EEF      	MOVWF INDF0
07A4  06E9      	DECF FSR0L, F
07A6  51F2      	MOVF CompTempVar783, W, 1
07A8  6EEF      	MOVWF INDF0

	if (first) {
07AA  A1EC      	BTFSS usb_send_d_0000F_arg_first,0, 1
07AC  D005      	BRA	label65
07B8            label65

		clear_bit(bd->stat, DTS);	// So when it flips, will end up set 
07AE  51EF      	MOVF usb_send_d_0000F_1_bd+D'1', W, 1
07B0  6EEA      	MOVWF FSR0H
07B2  51EE      	MOVF usb_send_d_0000F_1_bd, W, 1
07B4  6EE9      	MOVWF FSR0L
07B6  9CEF      	BCF INDF0,6

	}

	toggle_bit(bd->stat, DTS);	// flip the DTS bit
07B8  51EF      	MOVF usb_send_d_0000F_1_bd+D'1', W, 1
07BA  6EEA      	MOVWF FSR0H
07BC  51EE      	MOVF usb_send_d_0000F_1_bd, W, 1
07BE  6EE9      	MOVWF FSR0L
07C0  0E40      	MOVLW 0x40
07C2  1AEF      	XORWF INDF0, F

	clear_bit(bd->stat, KEN);	// clear the keep bit
07C4  9AEF      	BCF INDF0,5

	clear_bit(bd->stat, INCDIS);	// clear the increment disable
07C6  98EF      	BCF INDF0,4

	set_bit  (bd->stat, DTSEN);
07C8  86EF      	BSF INDF0,3

	clear_bit(bd->stat, BSTALL);	// clear stall bit
07CA  94EF      	BCF INDF0,2

	clear_bit(bd->stat, BC9);
07CC  92EF      	BCF INDF0,1

	clear_bit(bd->stat, BC8);
07CE  90EF      	BCF INDF0,0


	set_bit  (bd->stat, UOWN);	// SIE owns the buffer
07D0  8EEF      	BSF INDF0,7

}	
0758  0012      	RETURN
07D2  0012      	RETURN




void usb_send_data_chunk() {

	
uns8 count;

	if (test_bit(bd0in.stat, UOWN)) {
0074  0104      	MOVLB 0x04
0076  BF04      	BTFSC gbl_bd0in,7, 1

		return;
	}

	count = 0;
007A  0100      	MOVLB 0x00
007C  6BFC      	CLRF usb_send_d_0002E_1_count, 1

	while ((count < delivery_buffer_size) &&
007E            label3
007E  51D8      	MOVF gbl_delivery_buffer_size, W, 1
0080  61FC      	CPFSLT usb_send_d_0002E_1_count, 1
0082  D01F      	BRA	label6
00C0  D7DE      	BRA	label3
00C2            label6

	       (delivery_bytes_sent < delivery_bytes_to_send) && 
0084  51C7      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
0086  5DCB      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0088  E102      	BNZ	label4
008A  51C6      	MOVF gbl_delivery_bytes_to_send, W, 1
008C  5DCA      	SUBWF gbl_delivery_bytes_sent, W, 1
008E            label4
008E  E219      	BC	label6

	       (delivery_bytes_sent < delivery_bytes_max_send)) {
0090  51C9      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
0092  5DCB      	SUBWF gbl_delivery_bytes_sent+D'1', W, 1
0094  E102      	BNZ	label5
0096  51C8      	MOVF gbl_delivery_bytes_max_send, W, 1
0098  5DCA      	SUBWF gbl_delivery_bytes_sent, W, 1
009A            label5
009A  E213      	BC	label6

	    delivery_buffer[count] = *delivery_ptr;
009C  51CD      	MOVF gbl_delivery_ptr+D'1', W, 1
009E  6EEA      	MOVWF FSR0H
00A0  51CC      	MOVF gbl_delivery_ptr, W, 1
00A2  6EE9      	MOVWF FSR0L
00A4  50EF      	MOVF INDF0, W
00A6  6FFD      	MOVWF CompTempVar789, 1
00A8  51CF      	MOVF gbl_delivery_buffer+D'1', W, 1
00AA  6EEA      	MOVWF FSR0H
00AC  51CE      	MOVF gbl_delivery_buffer, W, 1
00AE  25FC      	ADDWF usb_send_d_0002E_1_count, W, 1
00B0  6EE9      	MOVWF FSR0L
00B2  51FD      	MOVF CompTempVar789, W, 1
00B4  6EEF      	MOVWF INDF0

	    delivery_ptr++;
00B6  4BCC      	INFSNZ gbl_delivery_ptr, F, 1
00B8  2BCD      	INCF gbl_delivery_ptr+D'1', F, 1

	    delivery_bytes_sent++;
00BA  4BCA      	INFSNZ gbl_delivery_bytes_sent, F, 1
00BC  2BCB      	INCF gbl_delivery_bytes_sent+D'1', F, 1

	    count++;
00BE  2BFC      	INCF usb_send_d_0002E_1_count, F, 1

	}       	
	
	if ((count < delivery_buffer_size) && 
00C2  51D8      	MOVF gbl_delivery_buffer_size, W, 1
00C4  61FC      	CPFSLT usb_send_d_0002E_1_count, 1
00C6  D00F      	BRA	label9
00E6            label9

	    ((delivery_bytes_sent == delivery_bytes_max_send) ||
00C8  51C8      	MOVF gbl_delivery_bytes_max_send, W, 1
00CA  63CA      	CPFSEQ gbl_delivery_bytes_sent, 1
00CC  D004      	BRA	label7
00CE  51C9      	MOVF gbl_delivery_bytes_max_send+D'1', W, 1
00D0  63CB      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
00D2  D001      	BRA	label7
00D4  D006      	BRA	label8
00D6            label7

	    (delivery_bytes_sent == delivery_bytes_to_send)))  {
00D6  51C6      	MOVF gbl_delivery_bytes_to_send, W, 1
00D8  63CA      	CPFSEQ gbl_delivery_bytes_sent, 1
00DA  D005      	BRA	label9
00DC  51C7      	MOVF gbl_delivery_bytes_to_send+D'1', W, 1
00DE  63CB      	CPFSEQ gbl_delivery_bytes_sent+D'1', 1
00E0  D002      	BRA	label9
00E2            label8

		control_mode = cm_CTRL_READ_AWAITING_STATUS;	// we're done with data stage
00E2  0E05      	MOVLW 0x05
00E4  6FD7      	MOVWF gbl_control_mode, 1

	}	

	
	bd0in.count = count;
00E6  51FC      	MOVF usb_send_d_0002E_1_count, W, 1
00E8  0104      	MOVLB 0x04
00EA  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in.addr = (uns16)&buffer_0_in;
00EC  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
00EE  6F07      	MOVWF gbl_bd0in+D'3', 1
00F0  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
00F2  6F06      	MOVWF gbl_bd0in+D'2', 1

	toggle_bit(bd0in.stat, DTS);
00F4  0E40      	MOVLW 0x40
00F6  1B04      	XORWF gbl_bd0in, F, 1

	clear_bit(bd0in.stat, KEN);	// clear the keep bit
00F8  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in.stat, INCDIS);	// clear the increment disable
00FA  9904      	BCF gbl_bd0in,4, 1

	set_bit  (bd0in.stat, DTSEN);
00FC  8704      	BSF gbl_bd0in,3, 1

	clear_bit(bd0in.stat, BSTALL);	// clear stall bit
00FE  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in.stat, BC9);
0100  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in.stat, BC8);
0102  9104      	BCF gbl_bd0in,0, 1


	set_bit  (bd0in.stat, UOWN);	// SIE owns the buffer
0104  8F04      	BSF gbl_bd0in,7, 1

	/*
	delivery_bd->count = count;
	delivery_bd->addr = (uns16)delivery_buffer;
	toggle_bit(delivery_bd->stat, DTS);
	clear_bit(delivery_bd->stat, KEN);	// clear the keep bit
	clear_bit(delivery_bd->stat, INCDIS);	// clear the increment disable
	set_bit  (delivery_bd->stat, DTSEN);
	clear_bit(delivery_bd->stat, BSTALL);	// clear stall bit
	clear_bit(delivery_bd->stat, BC9);
	clear_bit(delivery_bd->stat, BC8);

	set_bit  (delivery_bd->stat, UOWN);	// SIE owns the buffer
	*/
}
0078  0012      	RETURN
0106  0012      	RETURN



void usb_send_empty_data_pkt() {

	delivery_buffer_size = USB_EP0_IN_SIZE;
014C  0E08      	MOVLW 0x08
014E  0100      	MOVLB 0x00
0150  6FD8      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bd = &bd0in;	
0152  0E04      	MOVLW HIGH(gbl_bd0in+D'0')
0154  6FD1      	MOVWF gbl_delivery_bd+D'1', 1
0156  0E04      	MOVLW LOW(gbl_bd0in+D'0')
0158  6FD0      	MOVWF gbl_delivery_bd, 1

	delivery_buffer = &buffer_0_in;	
015A  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
015C  6FCF      	MOVWF gbl_delivery_buffer+D'1', 1
015E  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
0160  6FCE      	MOVWF gbl_delivery_buffer, 1

	delivery_bytes_sent = 0;
0162  6BCA      	CLRF gbl_delivery_bytes_sent, 1
0164  6BCB      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 0;
0166  6BC6      	CLRF gbl_delivery_bytes_to_send, 1
0168  6BC7      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
016A  6BC8      	CLRF gbl_delivery_bytes_max_send, 1
016C  6BC9      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	delivery_ptr = (uns8 *) 0;
016E  6BCC      	CLRF gbl_delivery_ptr, 1
0170  6BCD      	CLRF gbl_delivery_ptr+D'1', 1

	clear_bit(bd0in.stat, DTS);	// ready to get toggled 
0172  0104      	MOVLB 0x04
0174  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
0176  EC3AF000  	CALL usb_send_d_0002E

}
017A  0012      	RETURN


uns8 buffer_byte;

void usb_send_one_byte(uns8 data) {

	delivery_buffer_size = USB_EP0_IN_SIZE;
0114  0E08      	MOVLW 0x08
0116  6FD8      	MOVWF gbl_delivery_buffer_size, 1

	delivery_bytes_sent = 0;
0118  6BCA      	CLRF gbl_delivery_bytes_sent, 1
011A  6BCB      	CLRF gbl_delivery_bytes_sent+D'1', 1

	delivery_bytes_to_send = 1;
011C  0E01      	MOVLW 0x01
011E  6FC6      	MOVWF gbl_delivery_bytes_to_send, 1
0120  6BC7      	CLRF gbl_delivery_bytes_to_send+D'1', 1

	delivery_bytes_max_send = 0;
0122  6BC8      	CLRF gbl_delivery_bytes_max_send, 1
0124  6BC9      	CLRF gbl_delivery_bytes_max_send+D'1', 1

	buffer_byte = data;
0126  51FB      	MOVF usb_send_o_00030_arg_data, W, 1
0128  6FDA      	MOVWF gbl_buffer_byte, 1

	delivery_ptr = (uns8 *) &buffer_byte;
012A  0E00      	MOVLW HIGH(gbl_buffer_byte+D'0')
012C  6FCD      	MOVWF gbl_delivery_ptr+D'1', 1
012E  0EDA      	MOVLW LOW(gbl_buffer_byte+D'0')
0130  6FCC      	MOVWF gbl_delivery_ptr, 1

	delivery_bd = &bd0in;
0132  0E04      	MOVLW HIGH(gbl_bd0in+D'0')
0134  6FD1      	MOVWF gbl_delivery_bd+D'1', 1
0136  0E04      	MOVLW LOW(gbl_bd0in+D'0')
0138  6FD0      	MOVWF gbl_delivery_bd, 1

	delivery_buffer = &buffer_0_in;
013A  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
013C  6FCF      	MOVWF gbl_delivery_buffer+D'1', 1
013E  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
0140  6FCE      	MOVWF gbl_delivery_buffer, 1

	
	clear_bit(bd0in.stat, DTS);	// ready to get toggled
0142  0104      	MOVLB 0x04
0144  9D04      	BCF gbl_bd0in,6, 1

	usb_send_data_chunk();
0146  EC3AF000  	CALL usb_send_d_0002E

}
014A  0012      	RETURN


void usb_prime_ep0_out() {

	bd0out.count = USB_EP0_OUT_SIZE;
02C0  0E08      	MOVLW 0x08
02C2  0104      	MOVLB 0x04
02C4  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out.addr = USB_EP0_OUT_ADDR;
02C6  6B02      	CLRF gbl_bd0out+D'2', 1
02C8  0E05      	MOVLW 0x05
02CA  6F03      	MOVWF gbl_bd0out+D'3', 1

	//changed from clear to set
	set_bit(bd0out.stat, DTS);	// turn on data togle sync TOGGLE
02CC  8D00      	BSF gbl_bd0out,6, 1

	clear_bit(bd0out.stat, KEN);	// clear the keep bit
02CE  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out.stat, INCDIS);	// clear the increment disable
02D0  9900      	BCF gbl_bd0out,4, 1

	// !! changed here to not be dtsen....
	set_bit  (bd0out.stat, DTSEN);
02D2  8700      	BSF gbl_bd0out,3, 1

	clear_bit(bd0out.stat, BSTALL);	// clear stall bit
02D4  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out.stat, BC9);
02D6  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out.stat, BC8);
02D8  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out.stat, UOWN);	// SIE owns the buffer
02DA  8F00      	BSF gbl_bd0out,7, 1

}						  
02DC  0012      	RETURN


void usb_handle_standard_request(setup_data_packet sdp) {


	switch (sdp.bRequest) {

		case req_Get_Descriptor:
02DE  0E06      	MOVLW 0x06
02E0  6301      	CPFSEQ usb_handle_00032_arg_sdp+D'1', 1
02E2  D001      	BRA	label21
02E4  D00F      	BRA	label25
02E6            label21
0304            label25

			uns8 descriptor_type = sdp.wValue >> 8; // high byte is descriptor
0304  5103      	MOVF usb_handle_00032_arg_sdp+D'3', W, 1
0306  0100      	MOVLB 0x00
0308  6FF9      	MOVWF usb_handle_00032_1_descrip_00033, 1

			uns8 descriptor_num  = sdp.wValue & 0xff; // low byte is particular descriptor
030A  0101      	MOVLB 0x01
030C  5102      	MOVF usb_handle_00032_arg_sdp+D'2', W, 1
030E  0100      	MOVLB 0x00
0310  6FFA      	MOVWF usb_handle_00032_1_descrip_00034, 1

			usb_get_descriptor_callback(descriptor_type, descriptor_num, &delivery_ptr, &delivery_bytes_to_send);
0312  51F9      	MOVF usb_handle_00032_1_descrip_00033, W, 1
0314  6FFB      	MOVWF usb_get_de_00016_arg_descr_00017, 1
0316  51FA      	MOVF usb_handle_00032_1_descrip_00034, W, 1
0318  6FFC      	MOVWF usb_get_de_00016_arg_descr_00018, 1
031A  0E00      	MOVLW HIGH(gbl_delivery_ptr+D'0')
031C  6FFE      	MOVWF usb_get_de_00016_arg_rtn_d_00019+D'1', 1
031E  0ECC      	MOVLW LOW(gbl_delivery_ptr+D'0')
0320  6FFD      	MOVWF usb_get_de_00016_arg_rtn_d_00019, 1
0322  0E00      	MOVLW HIGH(gbl_delivery_bytes_to_send+D'0')
0324  0101      	MOVLB 0x01
0326  6F09      	MOVWF usb_get_de_00016_arg_rtn_d_0001A+D'1', 1
0328  0EC6      	MOVLW LOW(gbl_delivery_bytes_to_send+D'0')
032A  6F08      	MOVWF usb_get_de_00016_arg_rtn_d_0001A, 1
032C  ECBEF000  	CALL usb_get_de_00016

			if (delivery_ptr != 0) {	// we've got something
0330  53CC      	MOVF gbl_delivery_ptr, F, 1
0332  E102      	BNZ	label26
0334  53CD      	MOVF gbl_delivery_ptr+D'1', F, 1
0336  E01B      	BZ	label27
0338            label26
036E            label27

				control_mode = cm_CTRL_READ_DATA_STAGE;
0338  0E03      	MOVLW 0x03
033A  6FD7      	MOVWF gbl_control_mode, 1

				delivery_bytes_max_send = sdp.wLength;	// maximum host wants
033C  0101      	MOVLB 0x01
033E  5106      	MOVF usb_handle_00032_arg_sdp+D'6', W, 1
0340  0100      	MOVLB 0x00
0342  6FC8      	MOVWF gbl_delivery_bytes_max_send, 1
0344  0101      	MOVLB 0x01
0346  5107      	MOVF usb_handle_00032_arg_sdp+D'7', W, 1
0348  0100      	MOVLB 0x00
034A  6FC9      	MOVWF gbl_delivery_bytes_max_send+D'1', 1

				delivery_bytes_sent = 0;	// clear our sent countr
034C  6BCA      	CLRF gbl_delivery_bytes_sent, 1
034E  6BCB      	CLRF gbl_delivery_bytes_sent+D'1', 1

				delivery_buffer_size = USB_EP0_IN_SIZE;
0350  0E08      	MOVLW 0x08
0352  6FD8      	MOVWF gbl_delivery_buffer_size, 1

				delivery_bd = &bd0in;
0354  0E04      	MOVLW HIGH(gbl_bd0in+D'0')
0356  6FD1      	MOVWF gbl_delivery_bd+D'1', 1
0358  0E04      	MOVLW LOW(gbl_bd0in+D'0')
035A  6FD0      	MOVWF gbl_delivery_bd, 1

				delivery_buffer = (uns8 *)USB_EP0_IN_ADDR;
035C  0E08      	MOVLW 0x08
035E  6FCE      	MOVWF gbl_delivery_buffer, 1
0360  0E05      	MOVLW 0x05
0362  6FCF      	MOVWF gbl_delivery_buffer+D'1', 1

				clear_bit(bd0in.stat, DTS);	// ready to get toggled
0364  0104      	MOVLB 0x04
0366  9D04      	BCF gbl_bd0in,6, 1

				usb_send_data_chunk();
0368  EC3AF000  	CALL usb_send_d_0002E

			} else {
				usb_stall_ep0();
036E  EC84F000  	CALL usb_stall__00011

			}
		
			break;
		case req_Set_Address:
02E6  0E05      	MOVLW 0x05
02E8  6301      	CPFSEQ usb_handle_00032_arg_sdp+D'1', 1
02EA  D001      	BRA	label22
02EC  D043      	BRA	label28
02EE            label22
0374            label28

			usb_address = sdp.wValue & 0xff;
0374  5102      	MOVF usb_handle_00032_arg_sdp+D'2', W, 1
0376  0100      	MOVLB 0x00
0378  6FD6      	MOVWF gbl_usb_address, 1

			usb_status = us_SET_ADDRESS;
037A  0E01      	MOVLW 0x01
037C  6FD9      	MOVWF gbl_usb_status, 1

			
			// Send a status ack - when we confirm that, THEN change address
			usb_send_status_ack();
037E  ECA6F000  	CALL usb_send_e_00010

			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
0382  0E06      	MOVLW 0x06
0384  0100      	MOVLB 0x00
0386  6FD7      	MOVWF gbl_control_mode, 1

			break;
		case req_Set_Configuration:
02EE  0E09      	MOVLW 0x09
02F0  6301      	CPFSEQ usb_handle_00032_arg_sdp+D'1', 1
02F2  D001      	BRA	label23
02F4  D04A      	BRA	label29
02F6            label23
038A            label29

			//sdp.wValue & 0xff; // MORE WORK see p136
			control_mode = cm_CTRL_WRITE_SENDING_STATUS;
038A  0E06      	MOVLW 0x06
038C  0100      	MOVLB 0x00
038E  6FD7      	MOVWF gbl_control_mode, 1

			usb_send_status_ack();
0390  ECA6F000  	CALL usb_send_e_00010

			
			usb_state = st_CONFIGURED;
0394  0E03      	MOVLW 0x03
0396  0100      	MOVLB 0x00
0398  6FD5      	MOVWF gbl_usb_state, 1

			
			// device is up - so now get the endpoints happy
			usb_configure_endpoints();
039A  EC52F001  	CALL usb_config_0002F

			// and do a call back to let the app know we're ready
			#ifdef USB_CALLBACK_ON_DEVICE_CONFIGURED
				usb_device_configured_callback();
			#endif	
			break;
		case req_Get_Interface:
02F6  0E0A      	MOVLW 0x0A
02F8  6301      	CPFSEQ usb_handle_00032_arg_sdp+D'1', 1
02FA  D001      	BRA	label24
02FC  D051      	BRA	label30
02FE            label24
03A0            label30

				control_mode = cm_CTRL_READ_DATA_STAGE;
03A0  0E03      	MOVLW 0x03
03A2  0100      	MOVLB 0x00
03A4  6FD7      	MOVWF gbl_control_mode, 1

				usb_send_one_byte(1);
03A6  0E01      	MOVLW 0x01
03A8  6FFB      	MOVWF usb_send_o_00030_arg_data, 1
03AA  EC8AF000  	CALL usb_send_o_00030

		case req_Get_Status:
02FE  5301      	MOVF usb_handle_00032_arg_sdp+D'1', F, 1
0300  E056      	BZ	label31
03AE            label31

				// this is wrong - needs to send two bytes !!
				#ifdef USB_SELF_POWERED
					usb_send_one_byte(1);
				#else
					usb_send_one_byte(0);	// bus powered
03AE  0100      	MOVLB 0x00
03B0  6BFB      	CLRF usb_send_o_00030_arg_data, 1
03B2  EC8AF000  	CALL usb_send_o_00030

				#endif
				break;			
	}	
}	
0302  0012      	RETURN
036C  0012      	RETURN
0372  0012      	RETURN
0388  0012      	RETURN
039E  0012      	RETURN
03B6  0012      	RETURN



void usb_handle_transaction() {


uns8 end_point, pid;

	end_point = ustat >> 3;
0492  306C      	RRCF gbl_ustat, W
0494  0100      	MOVLB 0x00
0496  6FF4      	MOVWF usb_handle_0002B_1_end_point, 1
0498  33F4      	RRCF usb_handle_0002B_1_end_point, F, 1
049A  33F4      	RRCF usb_handle_0002B_1_end_point, F, 1
049C  0E1F      	MOVLW 0x1F
049E  17F4      	ANDWF usb_handle_0002B_1_end_point, F, 1

	
	if (test_bit(ustat, DIR)) {
04A0  A46C      	BTFSS gbl_ustat,2
04A2  D00A      	BRA	label39
04B8            label39

		pid = (bd0in.stat >> 2) & 0x0f;	// mask out pid
04A4  0104      	MOVLB 0x04
04A6  3104      	RRCF gbl_bd0in, W, 1
04A8  0100      	MOVLB 0x00
04AA  6FF5      	MOVWF usb_handle_0002B_1_pid, 1
04AC  33F5      	RRCF usb_handle_0002B_1_pid, F, 1
04AE  0E3F      	MOVLW 0x3F
04B0  17F5      	ANDWF usb_handle_0002B_1_pid, F, 1
04B2  0E0F      	MOVLW 0x0F
04B4  17F5      	ANDWF usb_handle_0002B_1_pid, F, 1


	} else {
04B6  D00A      	BRA	label40
04CC            label40

		pid = (bd0out.stat >> 2) & 0x0f;	// mask out pid	
04B8  0104      	MOVLB 0x04
04BA  3100      	RRCF gbl_bd0out, W, 1
04BC  0100      	MOVLB 0x00
04BE  6FF6      	MOVWF CompTempVar755, 1
04C0  33F6      	RRCF CompTempVar755, F, 1
04C2  0E3F      	MOVLW 0x3F
04C4  17F6      	ANDWF CompTempVar755, F, 1
04C6  0E0F      	MOVLW 0x0F
04C8  15F6      	ANDWF CompTempVar755, W, 1
04CA  6FF5      	MOVWF usb_handle_0002B_1_pid, 1

	}
	
	if (end_point == 0) {
04CC  53F4      	MOVF usb_handle_0002B_1_end_point, F, 1
04CE  A4D8      	BTFSS STATUS,Z
04D0  D0BD      	BRA	label55
064C            label55

		if (pid == pid_SETUP) {
04D2  0E0D      	MOVLW 0x0D
04D4  63F5      	CPFSEQ usb_handle_0002B_1_pid, 1
04D6  D065      	BRA	label43
05A2            label43

			memcpy(/*dst*/ (void*)&usb_sdp, /*src*/ (void *)&buffer_0_out, 8);
04D8  0E00      	MOVLW HIGH(gbl_usb_sdp+D'0')
04DA  6FFA      	MOVWF memcpy8_00000_arg_dst+D'1', 1
04DC  0E9E      	MOVLW LOW(gbl_usb_sdp+D'0')
04DE  6FF9      	MOVWF memcpy8_00000_arg_dst, 1
04E0  0E05      	MOVLW HIGH(gbl_buffer_0_out+D'0')
04E2  6FFC      	MOVWF memcpy8_00000_arg_src+D'1', 1
04E4  0E00      	MOVLW LOW(gbl_buffer_0_out+D'0')
04E6  6FFB      	MOVWF memcpy8_00000_arg_src, 1
04E8  0E08      	MOVLW 0x08
04EA  6FFD      	MOVWF memcpy8_00000_arg_len, 1
04EC  ECF8F001  	CALL memcpy8_00000

			usb_prime_ep0_out();
04F0  EC60F001  	CALL usb_prime__00031

			
			if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // std request
04F4  0E40      	MOVLW 0x40
04F6  0100      	MOVLB 0x00
04F8  159E      	ANDWF gbl_usb_sdp, W, 1
04FA  6FF6      	MOVWF CompTempVar758, 1
04FC  67F6      	TSTFSZ CompTempVar758, 1
04FE  D027      	BRA	label41
054E            label41

			    !test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
0500  0E20      	MOVLW 0x20
0502  159E      	ANDWF gbl_usb_sdp, W, 1
0504  6FF7      	MOVWF CompTempVar759, 1
0506  67F7      	TSTFSZ CompTempVar759, 1
0508  D022      	BRA	label41

				usb_handle_standard_request(usb_sdp);	
050A  51A5      	MOVF gbl_usb_sdp+D'7', W, 1
050C  0101      	MOVLB 0x01
050E  6F07      	MOVWF usb_handle_00032_arg_sdp+D'7', 1
0510  0100      	MOVLB 0x00
0512  51A4      	MOVF gbl_usb_sdp+D'6', W, 1
0514  0101      	MOVLB 0x01
0516  6F06      	MOVWF usb_handle_00032_arg_sdp+D'6', 1
0518  0100      	MOVLB 0x00
051A  51A3      	MOVF gbl_usb_sdp+D'5', W, 1
051C  0101      	MOVLB 0x01
051E  6F05      	MOVWF usb_handle_00032_arg_sdp+D'5', 1
0520  0100      	MOVLB 0x00
0522  51A2      	MOVF gbl_usb_sdp+D'4', W, 1
0524  0101      	MOVLB 0x01
0526  6F04      	MOVWF usb_handle_00032_arg_sdp+D'4', 1
0528  0100      	MOVLB 0x00
052A  51A1      	MOVF gbl_usb_sdp+D'3', W, 1
052C  0101      	MOVLB 0x01
052E  6F03      	MOVWF usb_handle_00032_arg_sdp+D'3', 1
0530  0100      	MOVLB 0x00
0532  51A0      	MOVF gbl_usb_sdp+D'2', W, 1
0534  0101      	MOVLB 0x01
0536  6F02      	MOVWF usb_handle_00032_arg_sdp+D'2', 1
0538  0100      	MOVLB 0x00
053A  519F      	MOVF gbl_usb_sdp+D'1', W, 1
053C  0101      	MOVLB 0x01
053E  6F01      	MOVWF usb_handle_00032_arg_sdp+D'1', 1
0540  0100      	MOVLB 0x00
0542  519E      	MOVF gbl_usb_sdp, W, 1
0544  0101      	MOVLB 0x01
0546  6F00      	MOVWF usb_handle_00032_arg_sdp, 1
0548  EC6FF001  	CALL usb_handle_00032

			} else if (!test_bit(usb_sdp.bmRequestType, REQUEST_TYPE1) && // class request
054C  D028      	BRA	label42
054E  0E40      	MOVLW 0x40
0550  159E      	ANDWF gbl_usb_sdp, W, 1
0552  6FF8      	MOVWF CompTempVar761, 1
0554  67F8      	TSTFSZ CompTempVar761, 1
0556  D023      	BRA	label42
059E            label42

					test_bit(usb_sdp.bmRequestType, REQUEST_TYPE0)) {
0558  AB9E      	BTFSS gbl_usb_sdp,5, 1
055A  D021      	BRA	label42

				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_request_callback(usb_sdp);
055C  51A5      	MOVF gbl_usb_sdp+D'7', W, 1
055E  0101      	MOVLB 0x01
0560  6F07      	MOVWF usb_handle_00013_arg_sdp+D'7', 1
0562  0100      	MOVLB 0x00
0564  51A4      	MOVF gbl_usb_sdp+D'6', W, 1
0566  0101      	MOVLB 0x01
0568  6F06      	MOVWF usb_handle_00013_arg_sdp+D'6', 1
056A  0100      	MOVLB 0x00
056C  51A3      	MOVF gbl_usb_sdp+D'5', W, 1
056E  0101      	MOVLB 0x01
0570  6F05      	MOVWF usb_handle_00013_arg_sdp+D'5', 1
0572  0100      	MOVLB 0x00
0574  51A2      	MOVF gbl_usb_sdp+D'4', W, 1
0576  0101      	MOVLB 0x01
0578  6F04      	MOVWF usb_handle_00013_arg_sdp+D'4', 1
057A  0100      	MOVLB 0x00
057C  51A1      	MOVF gbl_usb_sdp+D'3', W, 1
057E  0101      	MOVLB 0x01
0580  6F03      	MOVWF usb_handle_00013_arg_sdp+D'3', 1
0582  0100      	MOVLB 0x00
0584  51A0      	MOVF gbl_usb_sdp+D'2', W, 1
0586  0101      	MOVLB 0x01
0588  6F02      	MOVWF usb_handle_00013_arg_sdp+D'2', 1
058A  0100      	MOVLB 0x00
058C  519F      	MOVF gbl_usb_sdp+D'1', W, 1
058E  0101      	MOVLB 0x01
0590  6F01      	MOVWF usb_handle_00013_arg_sdp+D'1', 1
0592  0100      	MOVLB 0x00
0594  519E      	MOVF gbl_usb_sdp, W, 1
0596  0101      	MOVLB 0x01
0598  6F00      	MOVWF usb_handle_00013_arg_sdp, 1
059A  ECDEF001  	CALL usb_handle_00013

				#endif	
			}
			clear_bit(ucon, PKTDIS);	// Trap for young players right there - and do it early!
059E  986D      	BCF gbl_ucon,4


		} else if (pid == pid_IN) {
05A2  0E09      	MOVLW 0x09
05A4  63F5      	CPFSEQ usb_handle_0002B_1_pid, 1
05A6  D020      	BRA	label48
05E8            label48

			if (control_mode == cm_CTRL_READ_DATA_STAGE) {
05A8  0E03      	MOVLW 0x03
05AA  63D7      	CPFSEQ gbl_control_mode, 1
05AC  D003      	BRA	label44
05B4            label44

				// it's ours, so send next chunk
				usb_send_data_chunk();
05AE  EC3AF000  	CALL usb_send_d_0002E

			} else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS) {
05B4  0E06      	MOVLW 0x06
05B6  63D7      	CPFSEQ gbl_control_mode, 1
05B8  D00A      	BRA	label45
05CE            label45

				control_mode = cm_IDLE;
05BA  6BD7      	CLRF gbl_control_mode, 1

				if (usb_status == us_SET_ADDRESS) {
05BC  05D9      	DECF gbl_usb_status, W, 1
05BE  A4D8      	BTFSS STATUS,Z

					usb_state = st_ADDRESS;
05C2  0E02      	MOVLW 0x02
05C4  6FD5      	MOVWF gbl_usb_state, 1

					uaddr = usb_address;
05C6  51D6      	MOVF gbl_usb_address, W, 1
05C8  6E6E      	MOVWF gbl_uaddr

					usb_status = us_IDLE;
05CA  6BD9      	CLRF gbl_usb_status, 1

				}
			} else if (control_mode == cm_CTRL_READ_AWAITING_STATUS) {
05CE  0E05      	MOVLW 0x05
05D0  63D7      	CPFSEQ gbl_control_mode, 1
05D2  D002      	BRA	label46
05D8            label46

				// Must have been last IN of the read, so still waiting for status
				nop(); // boostc bug
05D4  0000      	NOP

			} else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS) {
05D8  0E04      	MOVLW 0x04
05DA  63D7      	CPFSEQ gbl_control_mode, 1
05DC  D003      	BRA	label47
05E4            label47

				// Must be more to come
				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_ctrl_read_callback();
05DE  ECDDF001  	CALL usb_handle_00014

				#else
					nop(); // otherwise boostc bug
				#endif	
			} else {
				nop(); // boostc bug
05E4  0000      	NOP

			}
		} else if (pid == pid_ACK) {
05E8  0E02      	MOVLW 0x02
05EA  63F5      	CPFSEQ usb_handle_0002B_1_pid, 1
05EC  D011      	BRA	label51
0610            label51

			if (control_mode == cm_CTRL_READ_DATA_STAGE) {	
05EE  0E03      	MOVLW 0x03
05F0  63D7      	CPFSEQ gbl_control_mode, 1
05F2  D003      	BRA	label49
05FA            label49

				usb_send_data_chunk();
05F4  EC3AF000  	CALL usb_send_d_0002E

			} else if (control_mode == cm_CTRL_READ_DATA_STAGE_CLASS) {
05FA  0E04      	MOVLW 0x04
05FC  63D7      	CPFSEQ gbl_control_mode, 1
05FE  D003      	BRA	label50
0606            label50

				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_ctrl_read_callback();
0600  ECDDF001  	CALL usb_handle_00014

				#else
					nop(); // boostc bug
				#endif	
			} else if (control_mode == cm_CTRL_WRITE_SENDING_STATUS) {
0606  0E06      	MOVLW 0x06
0608  63D7      	CPFSEQ gbl_control_mode, 1

				control_mode = cm_IDLE;
060C  6BD7      	CLRF gbl_control_mode, 1

			}	
	
		} else if (pid == pid_OUT) {
0610  05F5      	DECF usb_handle_0002B_1_pid, W, 1
0612  A4D8      	BTFSS STATUS,Z

			// We've done an out
			if (control_mode == cm_CTRL_READ_AWAITING_STATUS) {
0616  0E05      	MOVLW 0x05
0618  63D7      	CPFSEQ gbl_control_mode, 1
061A  D002      	BRA	label52
0620            label52

				control_mode = cm_IDLE;
061C  6BD7      	CLRF gbl_control_mode, 1

			} else if (control_mode == cm_CTRL_WRITE_DATA_STAGE_CLASS) {
061E  D013      	BRA	label54
0620  0E02      	MOVLW 0x02
0622  63D7      	CPFSEQ gbl_control_mode, 1
0624  D00C      	BRA	label53
063E            label53

				#ifdef USB_CALLBACK_ON_CLASS_CTRL
					usb_handle_class_ctrl_write_callback((uns8 *)&buffer_0_out, bd0out.count);
0626  0E05      	MOVLW HIGH(gbl_buffer_0_out+D'0')
0628  6FF7      	MOVWF usb_handle_00015_arg_data+D'1', 1
062A  0E00      	MOVLW LOW(gbl_buffer_0_out+D'0')
062C  6FF6      	MOVWF usb_handle_00015_arg_data, 1
062E  0104      	MOVLB 0x04
0630  5101      	MOVF gbl_bd0out+D'1', W, 1
0632  0100      	MOVLB 0x00
0634  6FF8      	MOVWF usb_handle_00015_arg_count, 1
0636  6BF9      	CLRF usb_handle_00015_arg_count+D'1', 1
0638  ECDCF001  	CALL usb_handle_00015

					// !! should include bc bits here for total count
					// this only works for 8 bit data packets
				#else
					nop(); // boostc bug
				#endif	
			} else if (control_mode == cm_CTRL_READ_DATA_STAGE) {
063C  D004      	BRA	label54
063E  0E03      	MOVLW 0x03
0640  63D7      	CPFSEQ gbl_control_mode, 1
0642  D001      	BRA	label54
0646            label54

				control_mode = cm_IDLE;
0644  6BD7      	CLRF gbl_control_mode, 1

			}
			usb_prime_ep0_out();
0646  EC60F001  	CALL usb_prime__00031

				
		}

	} else {	// Not endpoint 0
		buffer_descriptor *bd;
		if (test_bit(ustat, DIR)) {
064C  A46C      	BTFSS gbl_ustat,2
064E  D002      	BRA	label56
0654            label56

			// in
			#ifdef USB_EP_DATA_CALLBACK
				bd = ep_in_bd_location[end_point];
				usb_ep_data_in_callback(end_point, bd->count);
			#else
				nop();
0650  0000      	NOP

			#endif	
		} else { // out

			bd = ep_out_bd_location[end_point];
0654  EE00F0AA  	LFSR 0x00,  gbl_ep_out_bd_location
0658  50E9      	MOVF FSR0L, W
065A  51F4      	MOVF usb_handle_0002B_1_end_point, W, 1
065C  6FF8      	MOVWF CompTempVar767, 1
065E  90D8      	BCF STATUS,C
0660  35F8      	RLCF CompTempVar767, W, 1
0662  26E9      	ADDWF FSR0L, F
0664  50EE      	MOVF POSTINC0, W
0666  6FF6      	MOVWF usb_handle_0002B_88_bd, 1
0668  50EF      	MOVF INDF0, W
066A  6FF7      	MOVWF usb_handle_0002B_88_bd+D'1', 1

			// issue callback
			#ifdef USB_EP_DATA_CALLBACK
				usb_ep_data_out_callback(end_point, ep_out_buffer_location[end_point],
									bd->count);
			#endif						
			// re-prime endpoint
			bd->count = ep_out_buffer_size[end_point];
066C  EE00F0BA  	LFSR 0x00,  gbl_ep_out_buffer_size
0670  50E9      	MOVF FSR0L, W
0672  51F4      	MOVF usb_handle_0002B_1_end_point, W, 1
0674  6FF8      	MOVWF CompTempVar770, 1
0676  90D8      	BCF STATUS,C
0678  37F8      	RLCF CompTempVar770, F, 1
067A  51F8      	MOVF CompTempVar770, W, 1
067C  26E9      	ADDWF FSR0L, F
067E  50EE      	MOVF POSTINC0, W
0680  6FF9      	MOVWF CompTempVar772, 1
0682  50EF      	MOVF INDF0, W
0684  6FFA      	MOVWF CompTempVar772+D'1', 1
0686  51F7      	MOVF usb_handle_0002B_88_bd+D'1', W, 1
0688  6EEA      	MOVWF FSR0H
068A  29F6      	INCF usb_handle_0002B_88_bd, W, 1
068C  6EE9      	MOVWF FSR0L
068E  51F9      	MOVF CompTempVar772, W, 1
0690  6EEF      	MOVWF INDF0

			
			// Address shouldn't change, so don't need to update it

			clear_bit(bd->stat, DTS);	// turn on data togle sync TOGGLE
0692  06E9      	DECF FSR0L, F
0694  9CEF      	BCF INDF0,6

			clear_bit(bd->stat, KEN);	// clear the keep bit
0696  9AEF      	BCF INDF0,5

			clear_bit(bd->stat, INCDIS);	// clear the increment disable
0698  98EF      	BCF INDF0,4

			clear_bit(bd->stat, DTSEN);
069A  96EF      	BCF INDF0,3

			clear_bit(bd->stat, BSTALL);	// clear stall bit
069C  94EF      	BCF INDF0,2

			clear_bit(bd->stat, BC9);
069E  92EF      	BCF INDF0,1

			clear_bit(bd->stat, BC8);
06A0  90EF      	BCF INDF0,0

			set_bit  (bd->stat, UOWN);	// SIE owns the buffer
06A2  8EEF      	BSF INDF0,7

						
				
		}   
	}	
}
05A0  0012      	RETURN
05B2  0012      	RETURN
05C0  0012      	RETURN
05CC  0012      	RETURN
05D6  0012      	RETURN
05E2  0012      	RETURN
05E6  0012      	RETURN
05F8  0012      	RETURN
0604  0012      	RETURN
060A  0012      	RETURN
060E  0012      	RETURN
0614  0012      	RETURN
064A  0012      	RETURN
0652  0012      	RETURN
06A4  0012      	RETURN


void usb_handle_reset() {

	usb_address = 0;
044C  0100      	MOVLB 0x00
044E  6BD6      	CLRF gbl_usb_address, 1

	//uaddr = 0;
	
	control_mode = cm_IDLE;
0450  6BD7      	CLRF gbl_control_mode, 1

	usb_status   = us_IDLE;
0452  6BD9      	CLRF gbl_usb_status, 1

	
	// clear fifo
	clear_bit(uir, TRNIF);
0454  9668      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0456  9668      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
0458  9668      	BCF gbl_uir,3

	clear_bit(uir, TRNIF);
045A  9668      	BCF gbl_uir,3

	
	// init buffers

	
	// EP0 OUT
	bd0out.count = 8;	// 8 byte buffer
045C  0E08      	MOVLW 0x08
045E  0104      	MOVLB 0x04
0460  6F01      	MOVWF gbl_bd0out+D'1', 1

	bd0out.addr = 0x0500;
0462  6B02      	CLRF gbl_bd0out+D'2', 1
0464  0E05      	MOVLW 0x05
0466  6F03      	MOVWF gbl_bd0out+D'3', 1

	
	clear_bit(bd0out.stat, DTS);	// turn on data togle sync TOGGLE
0468  9D00      	BCF gbl_bd0out,6, 1

	clear_bit(bd0out.stat, KEN);	// clear the keep bit
046A  9B00      	BCF gbl_bd0out,5, 1

	clear_bit(bd0out.stat, INCDIS);	// clear the increment disable
046C  9900      	BCF gbl_bd0out,4, 1

	clear_bit  (bd0out.stat, DTSEN);	// !!!!!!
046E  9700      	BCF gbl_bd0out,3, 1

	clear_bit(bd0out.stat, BSTALL);	// clear stall bit
0470  9500      	BCF gbl_bd0out,2, 1

	clear_bit(bd0out.stat, BC9);
0472  9300      	BCF gbl_bd0out,1, 1

	clear_bit(bd0out.stat, BC8);
0474  9100      	BCF gbl_bd0out,0, 1


	set_bit  (bd0out.stat, UOWN);	// SIE owns the buffer
0476  8F00      	BSF gbl_bd0out,7, 1

								// since we expect frist transaction to be SETUP
								
	// EP0 IN
	bd0in.count = 8;	// 8 byte buffer
0478  0E08      	MOVLW 0x08
047A  6F05      	MOVWF gbl_bd0in+D'1', 1

	bd0in.addr = 0x0508;
047C  6F06      	MOVWF gbl_bd0in+D'2', 1
047E  0E05      	MOVLW 0x05
0480  6F07      	MOVWF gbl_bd0in+D'3', 1

	clear_bit(bd0in.stat, DTS);	// turn on data togle sync TOGGLE
0482  9D04      	BCF gbl_bd0in,6, 1

	clear_bit(bd0in.stat, KEN);	// clear the keep bit
0484  9B04      	BCF gbl_bd0in,5, 1

	clear_bit(bd0in.stat, INCDIS);	// clear the increment disable
0486  9904      	BCF gbl_bd0in,4, 1

	clear_bit(bd0in.stat, BSTALL);	// clear stall bit
0488  9504      	BCF gbl_bd0in,2, 1

	clear_bit(bd0in.stat, BC9);
048A  9304      	BCF gbl_bd0in,1, 1

	clear_bit(bd0in.stat, BC8);
048C  9104      	BCF gbl_bd0in,0, 1

	
	clear_bit(bd0in.stat, UOWN);	// uC owns the buffer
048E  9F04      	BCF gbl_bd0in,7, 1


}
0490  0012      	RETURN

	
void usb_handle_stall() {


}
044A  0012      	RETURN




void usb_handle_isr() {

	
	if (test_bit(pir2, USBIF)) {
06AE  AAA1      	BTFSS gbl_pir2,5

		clear_bit(pir2, USBIF);
06B2  9AA1      	BCF gbl_pir2,5

		
		if (test_bit(uir, TRNIF)) {
06B4  A668      	BTFSS gbl_uir,3
06B6  D003      	BRA	label57
06BE            label57

			usb_handle_transaction();
06B8  EC49F002  	CALL usb_handle_0002B

			clear_bit(uir, TRNIF);
06BC  9668      	BCF gbl_uir,3

		}
		
		if (test_bit(uir, URSTIF)) {
06BE  A068      	BTFSS gbl_uir,0
06C0  D003      	BRA	label58
06C8            label58

			usb_handle_reset();
06C2  EC26F002  	CALL usb_handle_0002C

			clear_bit(uir, URSTIF);
06C6  9068      	BCF gbl_uir,0

		}	
		
		if (test_bit(uir, STALLIF)) {
06C8  AA68      	BTFSS gbl_uir,5

			usb_handle_stall();
06CC  EC25F002  	CALL usb_handle_0002D

			clear_bit(uir, STALLIF);
06D0  9A68      	BCF gbl_uir,5

		}
		#ifdef USB_CALLBACK_ON_SOF
			if (test_bit(uir, SOFIF)) {
				usb_SOF_callback(ufrm);	// sourceboost defines this
				clear_bit(uir, SOFIF);
			}
		#endif
	}
}
06B0  0012      	RETURN
06CA  0012      	RETURN
06D2  0012      	RETURN


void turn_usb_ints_on() {

	
	set_bit(uie,  STALLIE);	// interrupt on stall
06DA  8A69      	BSF gbl_uie,5

	set_bit(uie,  TRNIE);	//   on transaction complete
06DC  8669      	BSF gbl_uie,3

	set_bit(uie,  URSTIE);	//   on reset 
06DE  8069      	BSF gbl_uie,0

	set_bit(pie2, USBIE);	// general USB interrupts
06E0  8AA0      	BSF gbl_pie2,5

	#ifdef USB_CALLBACK_ON_SOF 
		set_bit(uie, SOFIE);
	#endif	
}
06E2  0012      	RETURN


void usb_setup() {

	usb_state = st_POWERED;
	
	// init hardware
	clear_bit(ucfg, UTRDIS);	// enable internal tranceiver
	set_bit  (ucfg, FSEN);	// clear for low speed, set for high speed
	set_bit  (ucfg, UPUEN);	// enable on-chip pull-ups

	clear_bit(ucfg, PPB1);	// disable double buffering for now
	clear_bit(ucfg, PPB0);	

	// if using ping pong buffers, need to do this:
	// set_bit(ucon, PPBRST);	// reset ping pong buffers to even
	// clear_bit(ucon, PPBRST);

	// init endpoint 0
		
	set_bit(uep0,   EPHSHK);	// EP0 handshaking on
	set_bit(uep0,   EPOUTEN);	// EP0 OUT enable 
	set_bit(uep0,   EPINEN); 	// EP0 IN enable 
	clear_bit(uep0, EPCONDIS);	// EP0 control transfers on (and IN and OUT)
	
	// init interrupts
	// Config buffer descriptor table

	ep_out_bd_location[0] = &bd0out;
	#if USB_HIGHEST_EP >= 1
		ep_out_bd_location[1] = &bd1out;
	#endif
	#if USB_HIGHEST_EP >= 2
		ep_out_bd_location[2] = &bd2out;
	#endif
	#if USB_HIGHEST_EP >= 3
		ep_out_bd_location[3] = &bd3out;
	#endif
	#if USB_HIGHEST_EP >= 4
		ep_out_bd_location[4] = &bd4out;
	#endif
	
	ep_in_bd_location[0] = &bd0in;
	#if USB_HIGHEST_EP >= 1
		ep_in_bd_location[1] = &bd1in;
	#endif
	#if USB_HIGHEST_EP >= 2
		ep_in_bd_location[2] = &bd2in;
	#endif
	#if USB_HIGHEST_EP >= 3
		ep_in_bd_location[3] = &bd3in;
	#endif
	#if USB_HIGHEST_EP >= 4
		ep_in_bd_location[4] = &bd4in;
	#endif


}
	
// enable usb module
void usb_enable_module() {
	uir = 0;
	set_bit(ucon, USBEN);	// enable USB serial interface engine (SIE)
	usb_state = st_DEFAULT;
}

usb_state_type usb_get_state() {

	return usb_state;
07D4  0100      	MOVLB 0x00
07D6  51D5      	MOVF gbl_usb_state, W, 1
07D8  6FE7      	MOVWF CompTempVarRet791, 1

}	
07DA  0012      	RETURN

}	
/*! \file pic_usb_buffer_mgt.c
    \brief Pic USB buffer routines

	Declarations of the buffer data structures for USB transfers
	
	Ian Harris 2008
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if it breaks, you get to keep both pieces" license.
    
   
*/

#include "pic_usb_buffer_mgt.h"

buffer_descriptor bd0out@0x400;
buffer_descriptor bd0in @0x404;
buffer_descriptor bd1out@0x408;
buffer_descriptor bd1in @0x40C;
buffer_descriptor bd2out@0x410;
buffer_descriptor bd2in @0x414;
buffer_descriptor bd3out@0x418;
buffer_descriptor bd3in @0x41c;
buffer_descriptor bd4out@0x420;
buffer_descriptor bd4in @0x424;
buffer_descriptor bd5out@0x428;
buffer_descriptor bd5in @0x42C;
buffer_descriptor bd6out@0x430;
buffer_descriptor bd6in @0x434;
buffer_descriptor bd7out@0x438;
buffer_descriptor bd7in @0x43C;

uns8 buffer_0_out[USB_EP0_OUT_SIZE]@ USB_EP0_OUT_ADDR;
uns8 buffer_0_in [USB_EP0_IN_SIZE] @ USB_EP0_IN_ADDR;

#ifdef USB_EP1_IN_SIZE
	uns8 buffer_1_in [USB_EP1_IN_SIZE] @USB_EP1_IN_ADDR;
#endif
#ifdef USB_EP1_OUT_SIZE
	uns8 buffer_1_out [USB_EP1_OUT_SIZE] @ USB_EP1_OUT_ADDR;
#endif
#ifdef USB_EP2_IN_SIZE
	uns8 buffer_2_in [USB_EP2_IN_SIZE] @ USB_EP2_IN_ADDR;
#endif
#ifdef USB_EP2_OUT_SIZE
	uns8 buffer_2_out [USB_EP2_OUT_SIZE] @ USB_EP2_OUT_ADDR;
#endif
#ifdef USB_EP3_IN_SIZE
	uns8 buffer_3_in [USB_EP3_IN_SIZE] @ USB_EP3_IN_ADDR;
#endif
#ifdef USB_EP3_OUT_SIZE
	uns8 buffer_3_out [USB_EP3_OUT_SIZE] @ USB_EP3_OUT_ADDR;
#endif

buffer_descriptor * ep_in_bd_location[USB_HIGHEST_EP + 1];
buffer_descriptor * ep_out_bd_location[USB_HIGHEST_EP + 1];

uns8 * ep_in_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0
	
	&buffer_0_in,	// ep 0 in buffer location
093E  0E05      	MOVLW HIGH(gbl_buffer_0_in+D'0')
0940  6FDB      	MOVWF CompGblVar99, 1
0942  0E08      	MOVLW LOW(gbl_buffer_0_in+D'0')
0944  6FAE      	MOVWF gbl_ep_in_buffer_location, 1
0946  51DB      	MOVF CompGblVar99, W, 1
0948  6FAF      	MOVWF gbl_ep_in_buffer_location+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			&buffer_1_in,	// ep 1 in buffer location
094A  0E05      	MOVLW HIGH(gbl_buffer_1_in+D'0')
094C  6FDC      	MOVWF CompGblVar100, 1
094E  0E10      	MOVLW LOW(gbl_buffer_1_in+D'0')
0950  6FB0      	MOVWF gbl_ep_in_buffer_location+D'2', 1
0952  51DC      	MOVF CompGblVar100, W, 1
0954  6FB1      	MOVWF gbl_ep_in_buffer_location+D'3', 1

		#else
			0,
		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			&buffer_2_in,	// ep 2 in buffer location
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			&buffer_3_in,	// ep 3 in buffer location
		#else
			0,
		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_IN_SIZE
			&buffer_4_in,	// ep 4 in buffer location
		#else
			0,
		#endif
	#endif	
};	   

uns8 * ep_out_buffer_location[USB_HIGHEST_EP + 1] = {
	// we always have EP0
	
	&buffer_0_out,	// ep 0 in buffer location
0956  0E05      	MOVLW HIGH(gbl_buffer_0_out+D'0')
0958  6FDD      	MOVWF CompGblVar101, 1
095A  0E00      	MOVLW LOW(gbl_buffer_0_out+D'0')
095C  6FB2      	MOVWF gbl_ep_out_buffer_location, 1
095E  51DD      	MOVF CompGblVar101, W, 1
0960  6FB3      	MOVWF gbl_ep_out_buffer_location+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			&buffer_1_out,	// ep 1 in buffer location
		#else
			0,
0962  6BB4      	CLRF gbl_ep_out_buffer_location+D'2', 1
0964  6BB5      	CLRF gbl_ep_out_buffer_location+D'3', 1

		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			&buffer_2_out,	// ep 2 in buffer location
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			&buffer_3_out,	// ep 3 in buffer location
		#else
			0,
		#endif
	#endif
		
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_OUT_SIZE
			&buffer_4_out,	// ep 4 in buffer location
		#else
			0,
		#endif
	#endif	
};	   


uns16 ep_in_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_IN_SIZE,
0966  0E08      	MOVLW 0x08
0968  6FB6      	MOVWF gbl_ep_in_buffer_size, 1
096A  6BB7      	CLRF gbl_ep_in_buffer_size+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_IN_SIZE
			USB_EP1_IN_SIZE,
096C  0E08      	MOVLW 0x08
096E  6FB8      	MOVWF gbl_ep_in_buffer_size+D'2', 1
0970  6BB9      	CLRF gbl_ep_in_buffer_size+D'3', 1

		#else
			0,
		#endif
	#endif		

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_IN_SIZE
			USB_EP2_IN_SIZE,
		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_IN_SIZE
			USB_EP3_IN_SIZE,
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_IN_SIZE
			USB_EP4_IN_SIZE,
		#else
			0,
		#endif
	#endif		
};	



uns16 ep_out_buffer_size[USB_HIGHEST_EP + 1] = {
	USB_EP0_OUT_SIZE,
0972  0E08      	MOVLW 0x08
0974  6FBA      	MOVWF gbl_ep_out_buffer_size, 1
0976  6BBB      	CLRF gbl_ep_out_buffer_size+D'1', 1

	
	#if USB_HIGHEST_EP >= 1
		#ifdef USB_EP1_OUT_SIZE
			USB_EP1_OUT_SIZE,
		#else
			0,
0978  6BBC      	CLRF gbl_ep_out_buffer_size+D'2', 1
097A  6BBD      	CLRF gbl_ep_out_buffer_size+D'3', 1

		#endif
	#endif		

	#if USB_HIGHEST_EP >= 2
		#ifdef USB_EP2_OUT_SIZE
			USB_EP2_OUT_SIZE,
		#else
			0,
		#endif
	#endif

	#if USB_HIGHEST_EP >= 3
		#ifdef USB_EP3_OUT_SIZE
			USB_EP3_OUT_SIZE,
		#else
			0,
		#endif
	#endif
	
	#if USB_HIGHEST_EP >= 4
		#ifdef USB_EP4_OUT_SIZE
			USB_EP4_OUT_SIZE,
		#else
			0,
		#endif
	#endif		
};	

#include "pic_utils.h"


// Use shadowed ports to prevent read-before-write problems

// This is the one place the port_shadow variable actually gets declared

#if NUMBER_PORTS == 2
uns8 port_shadow[NUMBER_PORTS] = {0, 0};
#endif

#if NUMBER_PORTS == 3
uns8 port_shadow[NUMBER_PORTS] = {0, 0, 0};
#endif

#if NUMBER_PORTS == 4
uns8 port_shadow[NUMBER_PORTS] = {0, 0, 0, 0};
#endif

#if NUMBER_PORTS == 5
uns8 port_shadow[NUMBER_PORTS] = {0, 0, 0, 0, 0};
097C  6A59      	CLRF gbl_port_shadow
097E  6A5A      	CLRF gbl_port_shadow+D'1'
0980  6A5B      	CLRF gbl_port_shadow+D'2'
0982  6A5C      	CLRF gbl_port_shadow+D'3'
0984  6A5D      	CLRF gbl_port_shadow+D'4'

#endif


void set_pin_var(uns8 port, uns8 pin) {
	uns8 array_location = port - PORTA;
	set_bit(port_shadow[array_location], pin); 
	port_array[array_location] = port_shadow[array_location]; 
}	

void clear_pin_var(uns8 port, uns8 pin) {
	uns8 array_location = port - PORTA;
	clear_bit(port_shadow[array_location], pin);
	port_array[array_location] = port_shadow[array_location]; 
}
	
void toggle_pin_var(uns8 port, uns8 pin) {
	uns8 array_location = port - PORTA;
    port_shadow[array_location] ^= (1 << (pin));
    port_array[array_location] = port_shadow[array_location]; 
}


void change_pin_var(uns8 port, uns8 pin, bit value) {
	uns8 array_location = port - PORTA;
	if (value) {
		set_bit(port_shadow[array_location], pin); 
	} else {
		clear_bit(port_shadow[array_location], pin);
	}
    port_array[array_location] = port_shadow[array_location]; 
}

  

//-----------------------------------------------------
// Pic Pack library
// 
// usb_config_mouse.c
//
// All the mouse specific USB code lives here
//
// Ian Harris 2008
// imharris [at] gmail.com
//
// Released under the "do whatever you like with this
// but if it breaks, you get to keep both pieces" license.
//-----------------------------------------------------

#include "pic_utils.h"
#include "pic_usb.h"


device_descriptor my_device_descriptor = {
	sizeof(my_device_descriptor), 	// 18 bytes long
0986  0E12      	MOVLW 0x12
0988  6F8C      	MOVWF gbl_my_device_descriptor, 1

	dt_DEVICE, 	// DEVICE 01h
098A  0E01      	MOVLW 0x01
098C  6F8D      	MOVWF gbl_my_device_descriptor+D'1', 1

	0x0110,	// usb version 1.10
098E  0E10      	MOVLW 0x10
0990  6F8E      	MOVWF gbl_my_device_descriptor+D'2', 1
0992  0E01      	MOVLW 0x01
0994  6F8F      	MOVWF gbl_my_device_descriptor+D'3', 1

	0,		// class
0996  6B90      	CLRF gbl_my_device_descriptor+D'4', 1

	0,		// subclass
0998  6B91      	CLRF gbl_my_device_descriptor+D'5', 1

	0,		// protocol
099A  6B92      	CLRF gbl_my_device_descriptor+D'6', 1

	8,		// max packet size for end point 0
099C  0E08      	MOVLW 0x08
099E  6F93      	MOVWF gbl_my_device_descriptor+D'7', 1

	0x04d8,	// Microchip's vendor
09A0  0ED8      	MOVLW 0xD8
09A2  6F94      	MOVWF gbl_my_device_descriptor+D'8', 1
09A4  0E04      	MOVLW 0x04
09A6  6F95      	MOVWF gbl_my_device_descriptor+D'9', 1

	0x000C,	// Microchip's product 
09A8  0E0C      	MOVLW 0x0C
09AA  6F96      	MOVWF gbl_my_device_descriptor+D'10', 1
09AC  6B97      	CLRF gbl_my_device_descriptor+D'11', 1

	0x0200, // version 2.0 of the product
09AE  6B98      	CLRF gbl_my_device_descriptor+D'12', 1
09B0  0E02      	MOVLW 0x02
09B2  6F99      	MOVWF gbl_my_device_descriptor+D'13', 1

	1,		// string 1 for manufacturer
09B4  0E01      	MOVLW 0x01
09B6  6F9A      	MOVWF gbl_my_device_descriptor+D'14', 1

	2,		// string 2 for product
09B8  0E02      	MOVLW 0x02
09BA  6F9B      	MOVWF gbl_my_device_descriptor+D'15', 1

	0,		// string 3 for serial number
09BC  6B9C      	CLRF gbl_my_device_descriptor+D'16', 1

	1		// number of configurations
09BE  0E01      	MOVLW 0x01
09C0  6F9D      	MOVWF gbl_my_device_descriptor+D'17', 1

};

const char mouse_report_descriptor[] = {
   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
09C2  0E05      	MOVLW 0x05
09C4  6E05      	MOVWF gbl_mouse_report_descriptor
09C6  0E01      	MOVLW 0x01
09C8  6E06      	MOVWF gbl_mouse_report_descriptor+D'1'

   0x09, 0x02,                    //  USAGE (Mouse)
09CA  0E09      	MOVLW 0x09
09CC  6E07      	MOVWF gbl_mouse_report_descriptor+D'2'
09CE  0E02      	MOVLW 0x02
09D0  6E08      	MOVWF gbl_mouse_report_descriptor+D'3'

   0xa1, 0x01,                    //  COLLECTION (Application)
09D2  0EA1      	MOVLW 0xA1
09D4  6E09      	MOVWF gbl_mouse_report_descriptor+D'4'
09D6  0E01      	MOVLW 0x01
09D8  6E0A      	MOVWF gbl_mouse_report_descriptor+D'5'

   0x09, 0x01,                    //  USAGE (Pointer)
09DA  0E09      	MOVLW 0x09
09DC  6E0B      	MOVWF gbl_mouse_report_descriptor+D'6'
09DE  0E01      	MOVLW 0x01
09E0  6E0C      	MOVWF gbl_mouse_report_descriptor+D'7'

   0xa1, 0x00,                    //  COLLECTION (Physical)
09E2  0EA1      	MOVLW 0xA1
09E4  6E0D      	MOVWF gbl_mouse_report_descriptor+D'8'
09E6  6A0E      	CLRF gbl_mouse_report_descriptor+D'9'

   0x05, 0x09,                    //  USAGE_PAGE (Button)
09E8  0E05      	MOVLW 0x05
09EA  6E0F      	MOVWF gbl_mouse_report_descriptor+D'10'
09EC  0E09      	MOVLW 0x09
09EE  6E10      	MOVWF gbl_mouse_report_descriptor+D'11'

   0x19, 0x01,                    //  USAGE_MINIMUM (Button 1)
09F0  0E19      	MOVLW 0x19
09F2  6E11      	MOVWF gbl_mouse_report_descriptor+D'12'
09F4  0E01      	MOVLW 0x01
09F6  6E12      	MOVWF gbl_mouse_report_descriptor+D'13'

   0x29, 0x03,                    //  USAGE_MAXIMUM (Button 3)
09F8  0E29      	MOVLW 0x29
09FA  6E13      	MOVWF gbl_mouse_report_descriptor+D'14'
09FC  0E03      	MOVLW 0x03
09FE  6E14      	MOVWF gbl_mouse_report_descriptor+D'15'

   0x15, 0x00,                    //  LOGICAL_MINIMUM (0)
0A00  0E15      	MOVLW 0x15
0A02  6E15      	MOVWF gbl_mouse_report_descriptor+D'16'
0A04  6A16      	CLRF gbl_mouse_report_descriptor+D'17'

   0x25, 0x01,                    //  LOGICAL_MAXIMUM (1)
0A06  0E25      	MOVLW 0x25
0A08  6E17      	MOVWF gbl_mouse_report_descriptor+D'18'
0A0A  0E01      	MOVLW 0x01
0A0C  6E18      	MOVWF gbl_mouse_report_descriptor+D'19'

   0x95, 0x03,                    //  REPORT_COUNT (3)
0A0E  0E95      	MOVLW 0x95
0A10  6E19      	MOVWF gbl_mouse_report_descriptor+D'20'
0A12  0E03      	MOVLW 0x03
0A14  6E1A      	MOVWF gbl_mouse_report_descriptor+D'21'

   0x75, 0x01,                    //  REPORT_SIZE (1)
0A16  0E75      	MOVLW 0x75
0A18  6E1B      	MOVWF gbl_mouse_report_descriptor+D'22'
0A1A  0E01      	MOVLW 0x01
0A1C  6E1C      	MOVWF gbl_mouse_report_descriptor+D'23'

   0x81, 0x02,                    //  INPUT (Data,Var,Abs)
0A1E  0E81      	MOVLW 0x81
0A20  6E1D      	MOVWF gbl_mouse_report_descriptor+D'24'
0A22  0E02      	MOVLW 0x02
0A24  6E1E      	MOVWF gbl_mouse_report_descriptor+D'25'

   0x95, 0x01,                    //  REPORT_COUNT (1)
0A26  0E95      	MOVLW 0x95
0A28  6E1F      	MOVWF gbl_mouse_report_descriptor+D'26'
0A2A  0E01      	MOVLW 0x01
0A2C  6E20      	MOVWF gbl_mouse_report_descriptor+D'27'

   0x75, 0x05,                    //  REPORT_SIZE (5)
0A2E  0E75      	MOVLW 0x75
0A30  6E21      	MOVWF gbl_mouse_report_descriptor+D'28'
0A32  0E05      	MOVLW 0x05
0A34  6E22      	MOVWF gbl_mouse_report_descriptor+D'29'

   0x81, 0x01,                    //  INPUT (Cnst,Ary,Abs)
0A36  0E81      	MOVLW 0x81
0A38  6E23      	MOVWF gbl_mouse_report_descriptor+D'30'
0A3A  0E01      	MOVLW 0x01
0A3C  6E24      	MOVWF gbl_mouse_report_descriptor+D'31'

   0x05, 0x01,                    //  USAGE_PAGE (Generic Desktop)
0A3E  0E05      	MOVLW 0x05
0A40  6E25      	MOVWF gbl_mouse_report_descriptor+D'32'
0A42  0E01      	MOVLW 0x01
0A44  6E26      	MOVWF gbl_mouse_report_descriptor+D'33'

   0x09, 0x30,                    //  USAGE (X)
0A46  0E09      	MOVLW 0x09
0A48  6E27      	MOVWF gbl_mouse_report_descriptor+D'34'
0A4A  0E30      	MOVLW 0x30
0A4C  6E28      	MOVWF gbl_mouse_report_descriptor+D'35'

   0x09, 0x31,                    //  USAGE (Y)
0A4E  0E09      	MOVLW 0x09
0A50  6E29      	MOVWF gbl_mouse_report_descriptor+D'36'
0A52  0E31      	MOVLW 0x31
0A54  6E2A      	MOVWF gbl_mouse_report_descriptor+D'37'

   0x15, 0x81,                    //  LOGICAL_MINIMUM (-127)
0A56  0E15      	MOVLW 0x15
0A58  6E2B      	MOVWF gbl_mouse_report_descriptor+D'38'
0A5A  0E81      	MOVLW 0x81
0A5C  6E2C      	MOVWF gbl_mouse_report_descriptor+D'39'

   0x25, 0x7f,                    //  LOGICAL_MAXIMUM (127)
0A5E  0E25      	MOVLW 0x25
0A60  6E2D      	MOVWF gbl_mouse_report_descriptor+D'40'
0A62  0E7F      	MOVLW 0x7F
0A64  6E2E      	MOVWF gbl_mouse_report_descriptor+D'41'

   0x75, 0x08,                    //  REPORT_SIZE (8)
0A66  0E75      	MOVLW 0x75
0A68  6E2F      	MOVWF gbl_mouse_report_descriptor+D'42'
0A6A  0E08      	MOVLW 0x08
0A6C  6E30      	MOVWF gbl_mouse_report_descriptor+D'43'

   0x95, 0x02,                    //  REPORT_COUNT (2)
0A6E  0E95      	MOVLW 0x95
0A70  6E31      	MOVWF gbl_mouse_report_descriptor+D'44'
0A72  0E02      	MOVLW 0x02
0A74  6E32      	MOVWF gbl_mouse_report_descriptor+D'45'

   0x81, 0x06,                    //  INPUT (Data,Var,Rel)
0A76  0E81      	MOVLW 0x81
0A78  6E33      	MOVWF gbl_mouse_report_descriptor+D'46'
0A7A  0E06      	MOVLW 0x06
0A7C  6E34      	MOVWF gbl_mouse_report_descriptor+D'47'

   0xc0,                          //  END_COLLECTION
0A7E  0EC0      	MOVLW 0xC0
0A80  6E35      	MOVWF gbl_mouse_report_descriptor+D'48'

   0xc0                           //  END_COLLECTION
0A82  0EC0      	MOVLW 0xC0
0A84  6E36      	MOVWF gbl_mouse_report_descriptor+D'49'

};


struct  {
	configuration_descriptor my_config;
	interface_descriptor my_interface;
	hid_descriptor my_hid;
	endpoint_descriptor my_ep;
} complete_mouse_configuration = {
	{	// configuration descriptor - - - - - - - - - - 
		0x09,	// length,
0A86  0E09      	MOVLW 0x09
0A88  6E37      	MOVWF gbl_complete_mouse_configuration

		dt_CONFIGURATION,	// descriptor_type,
0A8A  0E02      	MOVLW 0x02
0A8C  6E38      	MOVWF gbl_complete_mouse_configuration+D'1'

		sizeof(complete_mouse_configuration),	// total_length;
0A8E  0E22      	MOVLW 0x22
0A90  6E39      	MOVWF gbl_complete_mouse_configuration+D'2'
0A92  6A3A      	CLRF gbl_complete_mouse_configuration+D'3'

		0x01,	// num_interfaces,
0A94  0E01      	MOVLW 0x01
0A96  6E3B      	MOVWF gbl_complete_mouse_configuration+D'4'

		0x01,	// configuration_value,
0A98  0E01      	MOVLW 0x01
0A9A  6E3C      	MOVWF gbl_complete_mouse_configuration+D'5'

		0x00,	// configuration_string_id,
0A9C  6A3D      	CLRF gbl_complete_mouse_configuration+D'6'

		0b10000000, // attributes (bus powered, no remote wake up)
0A9E  0E80      	MOVLW 0x80
0AA0  6E3E      	MOVWF gbl_complete_mouse_configuration+D'7'

		100,	// max_power; (200ma)
0AA2  0E64      	MOVLW 0x64
0AA4  6E3F      	MOVWF gbl_complete_mouse_configuration+D'8'

	},
	{	// interface descriptor - - - - - - - - - - - -
		0x09,	// length,
0AA6  0E09      	MOVLW 0x09
0AA8  6E40      	MOVWF gbl_complete_mouse_configuration+D'9'

		dt_INTERFACE,	// descriptor_type,
0AAA  0E04      	MOVLW 0x04
0AAC  6E41      	MOVWF gbl_complete_mouse_configuration+D'10'

		0x00,	// interface_number, (starts at zero)
0AAE  6A42      	CLRF gbl_complete_mouse_configuration+D'11'

		0x00,	// alternate_setting, (no alternatives)
0AB0  6A43      	CLRF gbl_complete_mouse_configuration+D'12'

		0x01,	// num_endpoints,
0AB2  0E01      	MOVLW 0x01
0AB4  6E44      	MOVWF gbl_complete_mouse_configuration+D'13'

		0x03,	// interface_class, (HID)
0AB6  0E03      	MOVLW 0x03
0AB8  6E45      	MOVWF gbl_complete_mouse_configuration+D'14'

		0x01,	// interface_subclass, (boot - is this necessary?)
0ABA  0E01      	MOVLW 0x01
0ABC  6E46      	MOVWF gbl_complete_mouse_configuration+D'15'

		0x02,	// interface_protocol, (mouse)
0ABE  0E02      	MOVLW 0x02
0AC0  6E47      	MOVWF gbl_complete_mouse_configuration+D'16'

		0x00,	// interface_string_id;
0AC2  6A48      	CLRF gbl_complete_mouse_configuration+D'17'

	},
	{	// hid descriptor - - - - - - - - - - - - - - -
		0x09,	// length,
0AC4  0E09      	MOVLW 0x09
0AC6  6E49      	MOVWF gbl_complete_mouse_configuration+D'18'

		dt_HID,	// descriptor_type;
0AC8  0E21      	MOVLW 0x21
0ACA  6E4A      	MOVWF gbl_complete_mouse_configuration+D'19'

		0x0110,	// hid_spec in BCD (1.10)
0ACC  0E10      	MOVLW 0x10
0ACE  6E4B      	MOVWF gbl_complete_mouse_configuration+D'20'
0AD0  0E01      	MOVLW 0x01
0AD2  6E4C      	MOVWF gbl_complete_mouse_configuration+D'21'

		0x00,	// country_code, (0=not country specific)
0AD4  6A4D      	CLRF gbl_complete_mouse_configuration+D'22'

		0x01,	// num_class_descriptors, (1)
0AD6  0E01      	MOVLW 0x01
0AD8  6E4E      	MOVWF gbl_complete_mouse_configuration+D'23'

		0x22,	// class_descriptor_type; (0x22 = report)
0ADA  0E22      	MOVLW 0x22
0ADC  6E4F      	MOVWF gbl_complete_mouse_configuration+D'24'

		sizeof(mouse_report_descriptor)	// class_descriptor_length; (report descriptor length)
0ADE  0E32      	MOVLW 0x32
0AE0  6E50      	MOVWF gbl_complete_mouse_configuration+D'25'
0AE2  6A51      	CLRF gbl_complete_mouse_configuration+D'26'

	},
	{	// endpoint descriptor - - - - - - - - - - - - -
		0x07,	// length,
0AE4  0E07      	MOVLW 0x07
0AE6  6E52      	MOVWF gbl_complete_mouse_configuration+D'27'

		dt_ENDPOINT,	// descriptor_type,
0AE8  0E05      	MOVLW 0x05
0AEA  6E53      	MOVWF gbl_complete_mouse_configuration+D'28'

		0b10000001,	// endpoint_address, (Endpoint 1, IN)
0AEC  0E81      	MOVLW 0x81
0AEE  6E54      	MOVWF gbl_complete_mouse_configuration+D'29'

		0b00000011,	// attributes; (Interrupt)
0AF0  0E03      	MOVLW 0x03
0AF2  6E55      	MOVWF gbl_complete_mouse_configuration+D'30'

		3,	// max_packet_size;
0AF4  0E03      	MOVLW 0x03
0AF6  6E56      	MOVWF gbl_complete_mouse_configuration+D'31'
0AF8  6A57      	CLRF gbl_complete_mouse_configuration+D'32'

		10,	// interval (10ms)
0AFA  0E0A      	MOVLW 0x0A
0AFC  6E58      	MOVWF gbl_complete_mouse_configuration+D'33'

	}	
};	
uns8 string_00 [] = 
	{
		4,	// length,
0AFE  0E04      	MOVLW 0x04
0B00  6FBE      	MOVWF gbl_string_00, 1

		dt_STRING,	// descriptor type
0B02  0E03      	MOVLW 0x03
0B04  6FBF      	MOVWF gbl_string_00+D'1', 1

		9,	// magic for US english
0B06  0E09      	MOVLW 0x09
0B08  6FC0      	MOVWF gbl_string_00+D'2', 1

		4
0B0A  0E04      	MOVLW 0x04
0B0C  6FC1      	MOVWF gbl_string_00+D'3', 1

	};
uns8 string_01[] =
	{
		// string 0 (1) - Manufacturer
		24,	// length,
0B0E  0E18      	MOVLW 0x18
0B10  6F60      	MOVWF gbl_string_01, 1

		dt_STRING,	// descriptor_type;
0B12  0E03      	MOVLW 0x03
0B14  6F61      	MOVWF gbl_string_01+D'1', 1

		
		'P', 0, 
0B16  0E50      	MOVLW 0x50
0B18  6F62      	MOVWF gbl_string_01+D'2', 1
0B1A  6B63      	CLRF gbl_string_01+D'3', 1

		'i', 0,
0B1C  0E69      	MOVLW 0x69
0B1E  6F64      	MOVWF gbl_string_01+D'4', 1
0B20  6B65      	CLRF gbl_string_01+D'5', 1

		'c', 0,
0B22  0E63      	MOVLW 0x63
0B24  6F66      	MOVWF gbl_string_01+D'6', 1
0B26  6B67      	CLRF gbl_string_01+D'7', 1

		'P', 0,
0B28  0E50      	MOVLW 0x50
0B2A  6F68      	MOVWF gbl_string_01+D'8', 1
0B2C  6B69      	CLRF gbl_string_01+D'9', 1

		'a', 0,
0B2E  0E61      	MOVLW 0x61
0B30  6F6A      	MOVWF gbl_string_01+D'10', 1
0B32  6B6B      	CLRF gbl_string_01+D'11', 1

		'c', 0,
0B34  0E63      	MOVLW 0x63
0B36  6F6C      	MOVWF gbl_string_01+D'12', 1
0B38  6B6D      	CLRF gbl_string_01+D'13', 1

		'k', 0,
0B3A  0E6B      	MOVLW 0x6B
0B3C  6F6E      	MOVWF gbl_string_01+D'14', 1
0B3E  6B6F      	CLRF gbl_string_01+D'15', 1

		' ', 0,
0B40  0E20      	MOVLW 0x20
0B42  6F70      	MOVWF gbl_string_01+D'16', 1
0B44  6B71      	CLRF gbl_string_01+D'17', 1

		'I', 0,
0B46  0E49      	MOVLW 0x49
0B48  6F72      	MOVWF gbl_string_01+D'18', 1
0B4A  6B73      	CLRF gbl_string_01+D'19', 1

		'n', 0,
0B4C  0E6E      	MOVLW 0x6E
0B4E  6F74      	MOVWF gbl_string_01+D'20', 1
0B50  6B75      	CLRF gbl_string_01+D'21', 1

		'c', 0
0B52  0E63      	MOVLW 0x63
0B54  6F76      	MOVWF gbl_string_01+D'22', 1
0B56  6B77      	CLRF gbl_string_01+D'23', 1

	};
uns8 string_02[] =
	{	
		20, // length	
0B58  0E14      	MOVLW 0x14
0B5A  6F78      	MOVWF gbl_string_02, 1

		dt_STRING,	// descriptory_type;
0B5C  0E03      	MOVLW 0x03
0B5E  6F79      	MOVWF gbl_string_02+D'1', 1

		'J', 0,
0B60  0E4A      	MOVLW 0x4A
0B62  6F7A      	MOVWF gbl_string_02+D'2', 1
0B64  6B7B      	CLRF gbl_string_02+D'3', 1

		'o', 0,
0B66  0E6F      	MOVLW 0x6F
0B68  6F7C      	MOVWF gbl_string_02+D'4', 1
0B6A  6B7D      	CLRF gbl_string_02+D'5', 1

		'y', 0,
0B6C  0E79      	MOVLW 0x79
0B6E  6F7E      	MOVWF gbl_string_02+D'6', 1
0B70  6B7F      	CLRF gbl_string_02+D'7', 1

		'-', 0,
0B72  0E2D      	MOVLW 0x2D
0B74  6F80      	MOVWF gbl_string_02+D'8', 1
0B76  6B81      	CLRF gbl_string_02+D'9', 1

		'M', 0,
0B78  0E4D      	MOVLW 0x4D
0B7A  6F82      	MOVWF gbl_string_02+D'10', 1
0B7C  6B83      	CLRF gbl_string_02+D'11', 1

		'o', 0,
0B7E  0E6F      	MOVLW 0x6F
0B80  6F84      	MOVWF gbl_string_02+D'12', 1
0B82  6B85      	CLRF gbl_string_02+D'13', 1

		'u', 0,
0B84  0E75      	MOVLW 0x75
0B86  6F86      	MOVWF gbl_string_02+D'14', 1
0B88  6B87      	CLRF gbl_string_02+D'15', 1

		's', 0,
0B8A  0E73      	MOVLW 0x73
0B8C  6F88      	MOVWF gbl_string_02+D'16', 1
0B8E  6B89      	CLRF gbl_string_02+D'17', 1

		'e', 0,
0B90  0E65      	MOVLW 0x65
0B92  6F8A      	MOVWF gbl_string_02+D'18', 1
0B94  6B8B      	CLRF gbl_string_02+D'19', 1

	};


void usb_get_descriptor_callback(uns8 descriptor_type, uns8 descriptor_num,

                                 uns8 **rtn_descriptor_ptr, uns16 *rtn_descriptor_size) {
	
	uns8 *descriptor_ptr;
	uns16 descriptor_size;
	
	descriptor_ptr = (uns8 *) 0;	// this means we didn't find it
017C  6B0A      	CLRF usb_get_de_00016_1_descrip_00039, 1
017E  6B0B      	CLRF usb_get_de_00016_1_descrip_00039+D'1', 1

	switch (descriptor_type) {
0260            label20

		case dt_DEVICE:
0180  0100      	MOVLB 0x00
0182  05FB      	DECF usb_get_de_00016_arg_descr_00017, W, 1
0184  E010      	BZ	label13
01A6            label13

			descriptor_ptr = (uns8 *)&my_device_descriptor;
01A6  0E00      	MOVLW HIGH(gbl_my_device_descriptor+D'0')
01A8  6FFF      	MOVWF CompTempVar831, 1
01AA  0E8C      	MOVLW LOW(gbl_my_device_descriptor+D'0')
01AC  0101      	MOVLB 0x01
01AE  6F0A      	MOVWF usb_get_de_00016_1_descrip_00039, 1
01B0  0100      	MOVLB 0x00
01B2  51FF      	MOVF CompTempVar831, W, 1
01B4  0101      	MOVLB 0x01
01B6  6F0B      	MOVWF usb_get_de_00016_1_descrip_00039+D'1', 1

			descriptor_size = sizeof(my_device_descriptor);
01B8  0E12      	MOVLW 0x12
01BA  6F0C      	MOVWF usb_get_de_00016_1_descrip_0003A, 1
01BC  6B0D      	CLRF usb_get_de_00016_1_descrip_0003A+D'1', 1

			break;
01BE  D050      	BRA	label20

		case dt_CONFIGURATION:
0186  0E02      	MOVLW 0x02
0188  63FB      	CPFSEQ usb_get_de_00016_arg_descr_00017, 1
018A  D001      	BRA	label10
018C  D019      	BRA	label14
018E            label10
01A4  D04F      	BRA	label19
01C0            label14
01E8  D01E      	BRA	label18
0242  D00E      	BRA	label20

			descriptor_ptr = (uns8 *) &complete_mouse_configuration;
01C0  0E00      	MOVLW HIGH(gbl_complete_mouse_configuration+D'0')
01C2  6FFF      	MOVWF CompTempVar832, 1
01C4  0E37      	MOVLW LOW(gbl_complete_mouse_configuration+D'0')
01C6  0101      	MOVLB 0x01
01C8  6F0A      	MOVWF usb_get_de_00016_1_descrip_00039, 1
01CA  0100      	MOVLB 0x00
01CC  51FF      	MOVF CompTempVar832, W, 1
01CE  0101      	MOVLB 0x01
01D0  6F0B      	MOVWF usb_get_de_00016_1_descrip_00039+D'1', 1

			descriptor_size = sizeof(complete_mouse_configuration);
01D2  0E22      	MOVLW 0x22
01D4  6F0C      	MOVWF usb_get_de_00016_1_descrip_0003A, 1
01D6  6B0D      	CLRF usb_get_de_00016_1_descrip_0003A+D'1', 1

			break;
01D8  D043      	BRA	label20

		case dt_STRING:
018E  0E03      	MOVLW 0x03
0190  63FB      	CPFSEQ usb_get_de_00016_arg_descr_00017, 1
0192  D001      	BRA	label11
0194  D022      	BRA	label15
0196            label11
01DA            label15

			switch (descriptor_num) {
				case 00: 
01DA  53FC      	MOVF usb_get_de_00016_arg_descr_00018, F, 1
01DC  E006      	BZ	label16
01EA            label16

					descriptor_size = sizeof(string_00);
01EA  0E04      	MOVLW 0x04
01EC  0101      	MOVLB 0x01
01EE  6F0C      	MOVWF usb_get_de_00016_1_descrip_0003A, 1
01F0  6B0D      	CLRF usb_get_de_00016_1_descrip_0003A+D'1', 1

					descriptor_ptr = string_00;
01F2  0E00      	MOVLW HIGH(gbl_string_00+D'0')
01F4  0100      	MOVLB 0x00
01F6  6FFF      	MOVWF CompTempVar833, 1
01F8  0EBE      	MOVLW LOW(gbl_string_00+D'0')
01FA  0101      	MOVLB 0x01
01FC  6F0A      	MOVWF usb_get_de_00016_1_descrip_00039, 1
01FE  0100      	MOVLB 0x00
0200  51FF      	MOVF CompTempVar833, W, 1
0202  0101      	MOVLB 0x01
0204  6F0B      	MOVWF usb_get_de_00016_1_descrip_00039+D'1', 1

					break;
0206  D02C      	BRA	label20

				case 01: 
01DE  05FC      	DECF usb_get_de_00016_arg_descr_00018, W, 1
01E0  E013      	BZ	label17
0208            label17

					descriptor_size = sizeof(string_01);
0208  0E18      	MOVLW 0x18
020A  0101      	MOVLB 0x01
020C  6F0C      	MOVWF usb_get_de_00016_1_descrip_0003A, 1
020E  6B0D      	CLRF usb_get_de_00016_1_descrip_0003A+D'1', 1

					descriptor_ptr = string_01;
0210  0E00      	MOVLW HIGH(gbl_string_01+D'0')
0212  0100      	MOVLB 0x00
0214  6FFF      	MOVWF CompTempVar834, 1
0216  0E60      	MOVLW LOW(gbl_string_01+D'0')
0218  0101      	MOVLB 0x01
021A  6F0A      	MOVWF usb_get_de_00016_1_descrip_00039, 1
021C  0100      	MOVLB 0x00
021E  51FF      	MOVF CompTempVar834, W, 1
0220  0101      	MOVLB 0x01
0222  6F0B      	MOVWF usb_get_de_00016_1_descrip_00039+D'1', 1

					break;
0224  D01D      	BRA	label20

				case 02: 
01E2  0E02      	MOVLW 0x02
01E4  63FC      	CPFSEQ usb_get_de_00016_arg_descr_00018, 1
01E6  D03C      	BRA	label20
0226            label18

					descriptor_size = sizeof(string_02);
0226  0E14      	MOVLW 0x14
0228  0101      	MOVLB 0x01
022A  6F0C      	MOVWF usb_get_de_00016_1_descrip_0003A, 1
022C  6B0D      	CLRF usb_get_de_00016_1_descrip_0003A+D'1', 1

					descriptor_ptr = string_02;
022E  0E00      	MOVLW HIGH(gbl_string_02+D'0')
0230  0100      	MOVLB 0x00
0232  6FFF      	MOVWF CompTempVar835, 1
0234  0E78      	MOVLW LOW(gbl_string_02+D'0')
0236  0101      	MOVLB 0x01
0238  6F0A      	MOVWF usb_get_de_00016_1_descrip_00039, 1
023A  0100      	MOVLB 0x00
023C  51FF      	MOVF CompTempVar835, W, 1
023E  0101      	MOVLB 0x01
0240  6F0B      	MOVWF usb_get_de_00016_1_descrip_00039+D'1', 1

					break;
					
			}		
			break;
		case dt_DEVICE_QUALIFIER:
0196  0E06      	MOVLW 0x06
0198  63FB      	CPFSEQ usb_get_de_00016_arg_descr_00017, 1
019A  D001      	BRA	label12
019C  D061      	BRA	label20
019E            label12

			// we don't handle this, send a stall
			break;
		case dt_HID_REPORT:
019E  0E22      	MOVLW 0x22
01A0  63FB      	CPFSEQ usb_get_de_00016_arg_descr_00017, 1
01A2  D05E      	BRA	label20
0244            label19

			descriptor_size = sizeof(mouse_report_descriptor);
0244  0E32      	MOVLW 0x32
0246  0101      	MOVLB 0x01
0248  6F0C      	MOVWF usb_get_de_00016_1_descrip_0003A, 1
024A  6B0D      	CLRF usb_get_de_00016_1_descrip_0003A+D'1', 1

			descriptor_ptr = (uns8 *) &mouse_report_descriptor;
024C  0E00      	MOVLW HIGH(gbl_mouse_report_descriptor+D'0')
024E  0100      	MOVLB 0x00
0250  6FFF      	MOVWF CompTempVar836, 1
0252  0E05      	MOVLW LOW(gbl_mouse_report_descriptor+D'0')
0254  0101      	MOVLB 0x01
0256  6F0A      	MOVWF usb_get_de_00016_1_descrip_00039, 1
0258  0100      	MOVLB 0x00
025A  51FF      	MOVF CompTempVar836, W, 1
025C  0101      	MOVLB 0x01
025E  6F0B      	MOVWF usb_get_de_00016_1_descrip_00039+D'1', 1

			break;			
	}
	*rtn_descriptor_ptr = descriptor_ptr;
0260  0100      	MOVLB 0x00
0262  51FE      	MOVF usb_get_de_00016_arg_rtn_d_00019+D'1', W, 1
0264  6EEA      	MOVWF FSR0H
0266  51FD      	MOVF usb_get_de_00016_arg_rtn_d_00019, W, 1
0268  6EE9      	MOVWF FSR0L
026A  2AE9      	INCF FSR0L, F
026C  0101      	MOVLB 0x01
026E  510A      	MOVF usb_get_de_00016_1_descrip_00039, W, 1
0270  0100      	MOVLB 0x00
0272  6FFF      	MOVWF CompTempVar837, 1
0274  0101      	MOVLB 0x01
0276  510B      	MOVF usb_get_de_00016_1_descrip_00039+D'1', W, 1
0278  6EEF      	MOVWF INDF0
027A  06E9      	DECF FSR0L, F
027C  0100      	MOVLB 0x00
027E  51FF      	MOVF CompTempVar837, W, 1
0280  6EEF      	MOVWF INDF0

	*rtn_descriptor_size = descriptor_size;		
0282  0101      	MOVLB 0x01
0284  5109      	MOVF usb_get_de_00016_arg_rtn_d_0001A+D'1', W, 1
0286  6EEA      	MOVWF FSR0H
0288  5108      	MOVF usb_get_de_00016_arg_rtn_d_0001A, W, 1
028A  6EE9      	MOVWF FSR0L
028C  2AE9      	INCF FSR0L, F
028E  510C      	MOVF usb_get_de_00016_1_descrip_0003A, W, 1
0290  0100      	MOVLB 0x00
0292  6FFF      	MOVWF CompTempVar838, 1
0294  0101      	MOVLB 0x01
0296  510D      	MOVF usb_get_de_00016_1_descrip_0003A+D'1', W, 1
0298  6EEF      	MOVWF INDF0
029A  06E9      	DECF FSR0L, F
029C  0100      	MOVLB 0x00
029E  51FF      	MOVF CompTempVar838, W, 1
02A0  6EEF      	MOVWF INDF0

}
02A2  0012      	RETURN




/*! \file usb_hid_class.c
    \brief Pic Human Interface Device USB routines

	Human Interface Device USB routines

	Ian Harris 2008
	imharris [at] gmail.com

	Released under the "do whatever you like with this
	but if it breaks, you get to keep both pieces" license
    
   
*/

#include "config.h"

// PicPack includes
#include "pic_usb.h"
#include "pic_usb_buffer_mgt.h"

// local includes
#include "usb_hid_class.h"

// system includes
#include "memory.h"


void usb_handle_class_ctrl_read_callback() {

}	
03BA  0012      	RETURN


void usb_handle_class_ctrl_write_callback(uns8 *data, uns16 count) {

}
03B8  0012      	RETURN


void usb_handle_class_request_callback(setup_data_packet sdp) {

	switch(sdp.bRequest) {

		case req_GET_REPORT:
03BC  0501      	DECF usb_handle_00013_arg_sdp+D'1', W, 1
03BE  B4D8      	BTFSC STATUS,Z

			break;
		case req_GET_IDLE:
03C2  0E02      	MOVLW 0x02
03C4  6301      	CPFSEQ usb_handle_00013_arg_sdp+D'1', 1
03C6  D001      	BRA	label32
03CA            label32

			break;
		case req_GET_PROTOCOL:
03CA  0E03      	MOVLW 0x03
03CC  6301      	CPFSEQ usb_handle_00013_arg_sdp+D'1', 1
03CE  D001      	BRA	label33
03D2            label33

			break;
		case req_SET_REPORT:
03D2  0E09      	MOVLW 0x09
03D4  6301      	CPFSEQ usb_handle_00013_arg_sdp+D'1', 1
03D6  D001      	BRA	label34
03DA            label34

			break;
		case req_SET_IDLE:
03DA  0E0A      	MOVLW 0x0A
03DC  6301      	CPFSEQ usb_handle_00013_arg_sdp+D'1', 1
03DE  D001      	BRA	label35
03E0  D004      	BRA	label36
03E2            label35
03EA            label36

			// we don't support whatever they want
			usb_stall_ep0();
03EA  EC84F000  	CALL usb_stall__00011

			break;
		case req_SET_PROTOCOL:
03E2  0E0B      	MOVLW 0x0B
03E4  6301      	CPFSEQ usb_handle_00013_arg_sdp+D'1', 1

			break;
		
	}

}	
03C0  0012      	RETURN
03C8  0012      	RETURN
03D0  0012      	RETURN
03D8  0012      	RETURN
03E6  0012      	RETURN
03E8  0012      	RETURN
03EE  0012      	RETURN

	
	
////////////////////////////////////////
// Code with no source :-)
////////////////////////////////////////
0000  EF93F004  	GOTO	_startup

0008  EFCDF005  	GOTO	interrupt
000C            delay_ms_00000
000C            ; { delay_ms ; function begin
000C  53E7      	MOVF delay_ms_00000_arg_del, F, 1
000E  0000      	NOP
0010  E101      	BNZ	label1
0012  0012      	RETURN
0014            label1
0014  0EF9      	MOVLW 0xF9
0016            label2
0016  0000      	NOP
0018  0000      	NOP
001A  0000      	NOP
001C  0000      	NOP
001E  0000      	NOP
0020  0000      	NOP
0022  0000      	NOP
0024  0000      	NOP
0026  0000      	NOP
0028  0000      	NOP
002A  0000      	NOP
002C  0000      	NOP
002E  0000      	NOP
0030  0000      	NOP
0032  0000      	NOP
0034  0000      	NOP
0036  0000      	NOP
0038  0000      	NOP
003A  0000      	NOP
003C  0000      	NOP
003E  0FFF      	ADDLW 0xFF
0040  A4D8      	BTFSS STATUS,Z
0042  D7E9      	BRA	label2
0044  0000      	NOP
0046  0000      	NOP
0048  0000      	NOP
004A  0000      	NOP
004C  0000      	NOP
004E  0000      	NOP
0050  0000      	NOP
0052  0000      	NOP
0054  0000      	NOP
0056  0000      	NOP
0058  0000      	NOP
005A  0000      	NOP
005C  0000      	NOP
005E  0000      	NOP
0060  0000      	NOP
0062  0000      	NOP
0064  0000      	NOP
0066  0000      	NOP
0068  0000      	NOP
006A  0000      	NOP
006C  0000      	NOP
006E  2FE7      	DECFSZ delay_ms_00000_arg_del, F, 1
0070  D7D1      	BRA	label1
0072  0012      	RETURN
0074            ; } delay_ms function end





































03F0            memcpy8_00000
03F0            ; { memcpy8 ; function begin
03F0  51F9      	MOVF memcpy8_00000_arg_dst, W, 1
03F2  6FFE      	MOVWF memcpy8_00000_1_dst2, 1
03F4  51FA      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
03F6  6FFF      	MOVWF memcpy8_00000_1_dst2+D'1', 1
03F8  51FB      	MOVF memcpy8_00000_arg_src, W, 1
03FA  0101      	MOVLB 0x01
03FC  6F00      	MOVWF memcpy8_00000_1_src2, 1
03FE  0100      	MOVLB 0x00
0400  51FC      	MOVF memcpy8_00000_arg_src+D'1', W, 1
0402  0101      	MOVLB 0x01
0404  6F01      	MOVWF memcpy8_00000_1_src2+D'1', 1
0406            label37
0406  0E00      	MOVLW 0x00
0408  0100      	MOVLB 0x00
040A  65FD      	CPFSGT memcpy8_00000_arg_len, 1
040C  D016      	BRA	label38
040E  0101      	MOVLB 0x01
0410  5101      	MOVF memcpy8_00000_1_src2+D'1', W, 1
0412  6EEA      	MOVWF FSR0H
0414  5100      	MOVF memcpy8_00000_1_src2, W, 1
0416  6EE9      	MOVWF FSR0L
0418  4B00      	INFSNZ memcpy8_00000_1_src2, F, 1
041A  2B01      	INCF memcpy8_00000_1_src2+D'1', F, 1
041C  50EF      	MOVF INDF0, W
041E  6F02      	MOVWF CompTempVar493, 1
0420  0100      	MOVLB 0x00
0422  51FF      	MOVF memcpy8_00000_1_dst2+D'1', W, 1
0424  6EEA      	MOVWF FSR0H
0426  51FE      	MOVF memcpy8_00000_1_dst2, W, 1
0428  6EE9      	MOVWF FSR0L
042A  4BFE      	INFSNZ memcpy8_00000_1_dst2, F, 1
042C  2BFF      	INCF memcpy8_00000_1_dst2+D'1', F, 1
042E  0101      	MOVLB 0x01
0430  5102      	MOVF CompTempVar493, W, 1
0432  6EEF      	MOVWF INDF0
0434  0100      	MOVLB 0x00
0436  07FD      	DECF memcpy8_00000_arg_len, F, 1
0438  D7E6      	BRA	label37
043A            label38
043A  51F9      	MOVF memcpy8_00000_arg_dst, W, 1
043C  0101      	MOVLB 0x01
043E  6F02      	MOVWF CompTempVarRet492, 1
0440  0100      	MOVLB 0x00
0442  51FA      	MOVF memcpy8_00000_arg_dst+D'1', W, 1
0444  0101      	MOVLB 0x01
0446  6F03      	MOVWF CompTempVarRet492+D'1', 1
0448  0012      	RETURN
044A            ; } memcpy8 function end


































































0926            _startup







0B96  EF3FF004  	GOTO	main



300000  0E30      	DW 0x0E30
300002  1E3E      	DW 0x1E3E
300004  00FF      	DW 0x00FF
300006  FF80      	DW 0xFF80
300008  C00F      	DW 0xC00F
30000A  E00F      	DW 0xE00F
30000C  400F      	DW 0x400F
